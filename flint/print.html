<!DOCTYPE HTML>
<html lang="en" class="coal sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Flint Engine</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the Flint CLI-first, AI-agent-optimized 3D game engine">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom-8d5049aa.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "coal";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-0d42d88f.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-72460a65.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('coal')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Flint Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/chaps/flint" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="flint-engine"><a class="header" href="#flint-engine">Flint Engine</a></h1>
<p><strong>A CLI-first, AI-agent-optimized 3D game engine written in Rust.</strong></p>
<p>Flint is a general-purpose 3D game engine designed from the ground up to provide an excellent interface for AI coding agents, while maintaining effective workflows for human developers. Unlike existing engines that optimize for GUI-driven workflows, Flint prioritizes programmatic interaction, introspection, and validation.</p>
<h2 id="the-core-idea"><a class="header" href="#the-core-idea">The Core Idea</a></h2>
<p>Current game engines are built around visual editors, drag-and-drop workflows, and GUI-heavy tooling. These become friction points when AI agents attempt to make changes programmatically — the agent ends up fighting against abstractions designed for human spatial reasoning and visual feedback loops.</p>
<p>Flint inverts this: <strong>the primary interface is CLI and code</strong>, with visual tools focused on <em>validating</em> results rather than <em>creating</em> them.</p>
<p>Every scene is a TOML file you can read, diff, and version. Every operation is a composable CLI command. Every piece of engine state is queryable as structured data. The viewer exists to answer one question: <em>“Did the agent do what I asked?”</em></p>
<h2 id="what-it-looks-like"><a class="header" href="#what-it-looks-like">What It Looks Like</a></h2>
<p>Create a scene, add entities, query them, and view the result — all from the command line:</p>
<pre><code class="language-bash"># Initialize a project
flint init my-game

# Create a scene and populate it
flint scene create levels/tavern.scene.toml --name "The Tavern"
flint entity create --archetype room --name "main_hall" --scene levels/tavern.scene.toml
flint entity create --archetype door --name "front_door" --parent "main_hall" --scene levels/tavern.scene.toml

# Query what you've built
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml

# Validate against constraints
flint validate levels/tavern.scene.toml --fix --dry-run

# See it in 3D with PBR rendering
flint serve levels/tavern.scene.toml --watch

# Walk around in first person
flint play levels/tavern.scene.toml
</code></pre>
<h2 id="current-status"><a class="header" href="#current-status">Current Status</a></h2>
<p>All five phases of Flint’s development are complete. The engine supports:</p>
<ul>
<li><strong>Entity CRUD</strong> via CLI with archetype-based creation</li>
<li><strong>Scene serialization</strong> in human-readable TOML</li>
<li><strong>Query language</strong> for filtering and inspecting entities</li>
<li><strong>Schema system</strong> for component and archetype definitions</li>
<li><strong>Constraint validation</strong> with auto-fix capabilities</li>
<li><strong>Asset management</strong> with content-addressed storage and glTF import</li>
<li><strong>PBR renderer</strong> with Cook-Torrance shading, cascaded shadow mapping, and glTF mesh rendering</li>
<li><strong>GPU skeletal animation</strong> with glTF skin/joint import, vertex skinning, and crossfade blending</li>
<li><strong>egui inspector</strong> with entity tree, component editing, and constraint overlay</li>
<li><strong>Hot-reload viewer</strong> that watches for file changes</li>
<li><strong>Headless rendering</strong> for CI and automated screenshots</li>
<li><strong>Physics simulation</strong> via Rapier 3D with kinematic character controller</li>
<li><strong>First-person gameplay</strong> with WASD movement, mouse look, jumping, and sprinting</li>
<li><strong>Game loop</strong> with fixed-timestep accumulator for deterministic physics</li>
<li><strong>Spatial audio</strong> via Kira with 3D positioned sounds, ambient loops, and event-driven triggers</li>
<li><strong>Property animation</strong> with TOML-defined keyframe clips (Step, Linear, CubicSpline interpolation)</li>
<li><strong>Skeletal animation</strong> with glTF skin import, GPU bone matrix skinning, and crossfade blending</li>
<li><strong>Rhai scripting</strong> with entity/input/audio/animation APIs, event callbacks, and hot-reload</li>
<li><strong>Interactable entities</strong> with HUD prompts, proximity detection, and scripted behaviors</li>
<li><strong>AI asset generation</strong> with pluggable providers (Flux textures, Meshy 3D models, ElevenLabs audio), style guides, batch scene resolution, model validation, and build manifests</li>
</ul>
<p>See the <a href="#roadmap">Roadmap</a> for the full development history.</p>
<h2 id="who-is-this-for"><a class="header" href="#who-is-this-for">Who Is This For?</a></h2>
<ul>
<li><strong>AI agent developers</strong> building game content programmatically</li>
<li><strong>Technical game developers</strong> who prefer code over visual editors</li>
<li><strong>Tooling enthusiasts</strong> who want to compose game development operations</li>
<li><strong>Rust game developers</strong> looking for a deterministic, introspectable engine</li>
</ul>
<h2 id="reading-this-guide"><a class="header" href="#reading-this-guide">Reading This Guide</a></h2>
<ul>
<li>Start with <a href="#why-flint">Why Flint?</a> to understand the motivation</li>
<li>Follow the <a href="#installation">Getting Started</a> guide to build from source and create your first project</li>
<li>Explore <a href="#entities-and-ecs">Core Concepts</a> to learn about the engine’s systems</li>
<li>Check the <a href="#architecture-overview">Architecture</a> section if you want to understand the codebase</li>
<li>Browse the <a href="/flint/api/flint_core">API Reference</a> for per-crate Rust documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="why-flint"><a class="header" href="#why-flint">Why Flint?</a></h1>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Game engines today — Unity, Unreal, Godot — are designed around visual editors. You drag objects into scenes, connect nodes in graphs, click through property inspectors. These workflows are excellent for humans using a mouse, but they create friction in two growing scenarios:</p>
<ol>
<li>
<p><strong>AI agents building game content.</strong> When an AI coding agent needs to place a door in a scene, it shouldn’t need to simulate mouse clicks on a GUI. It should issue a command and get structured feedback.</p>
</li>
<li>
<p><strong>Automation and CI pipelines.</strong> Validating a scene, running regression tests on visual output, or batch-processing hundreds of entities — these tasks fight against editor-centric architectures.</p>
</li>
</ol>
<p>The core tension: existing engines treat programmatic access as a <em>secondary</em> concern. The API exists, but it’s bolted onto a system designed for spatial interaction. Scene formats are binary or semi-readable. Introspection is limited. Determinism is not guaranteed.</p>
<h2 id="the-thesis"><a class="header" href="#the-thesis">The Thesis</a></h2>
<p>Flint starts from the opposite assumption: <strong>the primary interface is CLI and code</strong>. Visual tools are for <em>validation</em>, not <em>creation</em>.</p>
<p>This doesn’t mean Flint is hostile to humans. It means every operation flows through a composable, scriptable interface first. If you can do it in the CLI, you can automate it. If you can automate it, an AI agent can do it. The viewer is the place where a human confirms: “Yes, that’s what I wanted.”</p>
<h2 id="what-this-enables"><a class="header" href="#what-this-enables">What This Enables</a></h2>
<h3 id="for-ai-agents"><a class="header" href="#for-ai-agents">For AI agents</a></h3>
<p>An agent working with Flint has a clean contract:</p>
<ul>
<li>Issue CLI commands, get structured JSON/TOML responses</li>
<li>Query any aspect of engine state with a SQL-inspired language</li>
<li>Validate work against declarative constraint rules</li>
<li>Produce visual artifacts (headless renders) for verification</li>
</ul>
<p>No simulated GUI interaction. No screen scraping. No ambiguous visual state.</p>
<h3 id="for-humans"><a class="header" href="#for-humans">For humans</a></h3>
<p>A developer working with Flint gets:</p>
<ul>
<li>Scene files that are human-readable TOML, easily diffable in git</li>
<li>A query language for exploring what’s in a scene without opening an editor</li>
<li>Constraint rules that serve as living documentation of what a “correct” scene looks like</li>
<li>A hot-reload viewer that updates in real-time as files change</li>
</ul>
<h3 id="for-teams"><a class="header" href="#for-teams">For teams</a></h3>
<p>A team using Flint gets:</p>
<ul>
<li>Deterministic builds — same inputs always produce identical outputs</li>
<li>Text-based formats that merge cleanly in version control</li>
<li>Structured output for CI pipelines and automated testing</li>
<li>A shared vocabulary between human developers and AI tools</li>
</ul>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Traditional Engines</th><th>Flint</th></tr>
</thead>
<tbody>
<tr><td>Primary interface</td><td>GUI editor</td><td>CLI</td></tr>
<tr><td>Scene format</td><td>Binary or semi-text</td><td>TOML (fully text)</td></tr>
<tr><td>Programmatic API</td><td>Secondary</td><td>Primary</td></tr>
<tr><td>Introspection</td><td>Limited</td><td>Full (query language)</td></tr>
<tr><td>Deterministic builds</td><td>Generally no</td><td>Yes</td></tr>
<tr><td>AI-agent optimized</td><td>No</td><td>Yes</td></tr>
<tr><td>Validation</td><td>Runtime errors</td><td>Declarative constraints</td></tr>
</tbody>
</table>
</div>
<h2 id="the-name"><a class="header" href="#the-name">The Name</a></h2>
<p>Flint is a tool for starting fires. Simple, reliable, fundamental. Strike it and something sparks into existence. That’s the idea: minimal friction between intent and result.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h1>
<p>Flint’s architecture follows six principles that guide every design decision. They are listed in priority order — when principles conflict, higher-ranked ones win.</p>
<h2 id="1-cli-first"><a class="header" href="#1-cli-first">1. CLI-First</a></h2>
<p>Every operation is expressible as a composable command. There is no operation that <em>requires</em> a GUI. The CLI is the source of truth for what the engine can do.</p>
<p>This means:</p>
<ul>
<li>All commands accept flags for output format (<code>--format json</code>, <code>--format toml</code>)</li>
<li>Commands compose via pipes and standard shell tooling</li>
<li>Batch operations are first-class, not afterthoughts</li>
<li>The viewer is a <em>consumer</em> of state, not a <em>producer</em> of it</li>
</ul>
<h2 id="2-introspectable"><a class="header" href="#2-introspectable">2. Introspectable</a></h2>
<p>You can query any aspect of engine state as structured data. Nothing is hidden behind opaque handles or binary blobs.</p>
<pre><code class="language-bash"># What entities exist?
flint query "entities where archetype == 'door'"

# What does a door look like?
flint schema door

# What would this change break?
flint validate levels/tavern.scene.toml --fix --dry-run
</code></pre>
<p>The query language is the same whether you’re exploring interactively or writing constraint rules. Learn it once, use it everywhere.</p>
<h2 id="3-deterministic"><a class="header" href="#3-deterministic">3. Deterministic</a></h2>
<p>Same inputs always produce identical outputs. No hidden state, no ambient randomness, no order-dependent behavior.</p>
<ul>
<li>Entity IDs are stable across save/load cycles</li>
<li>Procedural generation uses explicit seeds</li>
<li>Build manifests record exact asset hashes</li>
<li>Headless renders are reproducible for regression testing</li>
</ul>
<h2 id="4-text-based"><a class="header" href="#4-text-based">4. Text-Based</a></h2>
<p>Scene and asset formats are human-readable, machine-parseable, and diffable. TOML is the primary format throughout.</p>
<pre><code class="language-toml">[entities.front_door]
archetype = "door"
parent = "main_hall"

[entities.front_door.transform]
position = [5, 0, 0]

[entities.front_door.door]
style = "hinged"
locked = false
</code></pre>
<p>This isn’t just about readability — it’s about <em>collaboration</em>. Text files merge cleanly in version control. Diffs are meaningful. AI agents can read and write them directly.</p>
<h2 id="5-constraint-driven"><a class="header" href="#5-constraint-driven">5. Constraint-Driven</a></h2>
<p>Declarative rules define what a valid scene looks like. The engine validates against these rules and can optionally auto-fix violations.</p>
<p>Constraints serve multiple roles:</p>
<ul>
<li><strong>Validation</strong> — catch errors before they become runtime bugs</li>
<li><strong>Documentation</strong> — constraints describe what “correct” means</li>
<li><strong>Automation</strong> — auto-fix rules handle routine corrections</li>
<li><strong>Communication</strong> — constraints are a shared contract between human and AI</li>
</ul>
<h2 id="6-hybrid-workflows"><a class="header" href="#6-hybrid-workflows">6. Hybrid Workflows</a></h2>
<p>Humans and AI agents collaborate effectively on the same project. Neither workflow is an afterthought.</p>
<p>The typical loop:</p>
<ol>
<li>An AI agent creates or modifies scene content via CLI</li>
<li>Constraints validate the changes automatically</li>
<li>A human reviews the result in the viewer</li>
<li>Feedback flows back to the agent as structured data</li>
</ol>
<p>This principle ensures Flint doesn’t optimize so hard for agents that humans can’t use it, or so hard for humans that agents can’t automate it.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-first-workflow"><a class="header" href="#cli-first-workflow">CLI-First Workflow</a></h1>
<p>Flint’s primary interface is the command line. Every engine operation — creating entities, querying scenes, validating constraints, importing assets, generating content — is a composable CLI command. Visual tools exist to <em>validate</em> results, not to <em>create</em> them.</p>
<h2 id="why-cli-first"><a class="header" href="#why-cli-first">Why CLI-First?</a></h2>
<p>Traditional game engines center on visual editors: drag a mesh into a viewport, tweak a slider, click Save. This works well for a single human at a desk, but it creates friction for:</p>
<ul>
<li><strong>Automation</strong> — you can’t script a drag-and-drop operation</li>
<li><strong>Reproducibility</strong> — a sequence of mouse clicks isn’t version-controllable</li>
<li><strong>AI agents</strong> — they see text, not pixels</li>
<li><strong>CI/CD</strong> — headless servers have no windows to click in</li>
<li><strong>Collaboration</strong> — binary project files don’t merge cleanly in git</li>
</ul>
<p>Flint inverts the priority: text-first, visual-second. The CLI is the engine’s native language.</p>
<h2 id="composable-commands"><a class="header" href="#composable-commands">Composable Commands</a></h2>
<p>Every command reads structured input and produces structured output. This means standard shell patterns work naturally:</p>
<pre><code class="language-bash"># Create a scene with several entities
flint scene create levels/dungeon.scene.toml --name "Dungeon Level 1"
flint entity create --archetype room --name "entrance" --scene levels/dungeon.scene.toml
flint entity create --archetype door --name "iron_gate" --parent "entrance" --scene levels/dungeon.scene.toml

# Query and filter with standard tools
flint query "entities where archetype == 'door'" --scene levels/dungeon.scene.toml --format json

# Validate and capture results
flint validate levels/dungeon.scene.toml --format json

# Render a preview image for review
flint render levels/dungeon.scene.toml --output preview.png --width 1920 --height 1080
</code></pre>
<h2 id="structured-output"><a class="header" href="#structured-output">Structured Output</a></h2>
<p>Commands support <code>--format json</code> and <code>--format toml</code> output modes, making their results machine-readable. This enables pipelines like:</p>
<pre><code class="language-bash"># Count entities of each archetype
flint query "entities" --scene levels/tavern.scene.toml --format json | jq 'group_by(.archetype) | map({archetype: .[0].archetype, count: length})'

# Check if validation passes (exit code 0 = clean, 1 = violations)
flint validate levels/tavern.scene.toml --format json &amp;&amp; echo "Scene is valid"
</code></pre>
<p>JSON output follows consistent schemas, so tools can parse results reliably across engine versions.</p>
<h2 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h2>
<p>Because every operation is a command, building complex scenes is just a script:</p>
<pre><code class="language-bash">#!/bin/bash
SCENE="levels/tavern.scene.toml"

flint scene create "$SCENE" --name "The Rusty Flagon"

# Build the structure
for room in main_hall kitchen storage; do
    flint entity create --archetype room --name "$room" --scene "$SCENE"
done

# Add doors between rooms
flint entity create --archetype door --name "kitchen_door" --parent "main_hall" --scene "$SCENE"
flint entity create --archetype door --name "storage_door" --parent "kitchen" --scene "$SCENE"

# Validate the whole thing
flint validate "$SCENE" --fix
</code></pre>
<p>This script is version-controllable, reproducible, and can run in CI.</p>
<h2 id="the-viewer-as-validator"><a class="header" href="#the-viewer-as-validator">The Viewer as Validator</a></h2>
<p>The <code>flint serve --watch</code> viewer and <code>flint play</code> command are verification tools, not authoring tools. They answer the question: <em>“Does the scene I built look correct?”</em></p>
<pre><code class="language-bash"># Edit the TOML in your text editor, viewer updates automatically
flint serve levels/tavern.scene.toml --watch

# Walk through the scene to verify physics, audio, and interactions
flint play levels/tavern.scene.toml
</code></pre>
<p>The viewer hot-reloads when the scene file changes. Edit TOML, save, see the result — no GUI interaction required.</p>
<h2 id="headless-rendering-for-ci"><a class="header" href="#headless-rendering-for-ci">Headless Rendering for CI</a></h2>
<p>Scenes can be rendered to PNG without a window, enabling automated visual validation:</p>
<pre><code class="language-bash">flint render levels/tavern.scene.toml --output screenshots/tavern.png --width 1920 --height 1080
</code></pre>
<p>This is the foundation for visual regression testing in CI pipelines — render a baseline, then compare future renders against it.</p>
<h2 id="contrast-with-gui-engines"><a class="header" href="#contrast-with-gui-engines">Contrast with GUI Engines</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>GUI Engine</th><th>Flint</th></tr>
</thead>
<tbody>
<tr><td>Primary input</td><td>Mouse clicks, drag-and-drop</td><td>CLI commands, TOML files</td></tr>
<tr><td>Automation</td><td>Limited (editor scripting plugins)</td><td>Native (every operation is a command)</td></tr>
<tr><td>Version control</td><td>Binary project files</td><td>Text TOML files, clean git diffs</td></tr>
<tr><td>AI agent support</td><td>Screenshot parsing, GUI automation</td><td>Structured text I/O, query introspection</td></tr>
<tr><td>Headless operation</td><td>Usually not supported</td><td>First-class (render, validate, query)</td></tr>
<tr><td>Reproducibility</td><td>Manual steps, screenshots</td><td>Scripts, exit codes, structured output</td></tr>
</tbody>
</table>
</div>
<p>This doesn’t mean Flint is text-only. It means the text interface is <em>complete</em> — anything you can do in the viewer, you can do (and automate) from the command line.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="#ai-agent-interface">AI Agent Interface</a> — how this philosophy benefits AI coding agents</li>
<li><a href="#design-principles">Design Principles</a> — the broader design philosophy</li>
<li><a href="#cli-reference">CLI Reference</a> — full command documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ai-agent-interface"><a class="header" href="#ai-agent-interface">AI Agent Interface</a></h1>
<p>Flint is designed from the ground up to be an excellent interface for AI coding agents. Where traditional engines optimize for human spatial reasoning and visual feedback, Flint optimizes for text-based reasoning, structured data, and automated validation.</p>
<h2 id="the-problem-with-gui-engines"><a class="header" href="#the-problem-with-gui-engines">The Problem with GUI Engines</a></h2>
<p>AI agents working with traditional game engines face fundamental friction:</p>
<ul>
<li><strong>Screenshot parsing</strong> — agents must interpret rendered pixels to understand scene state, an unreliable and lossy process</li>
<li><strong>GUI automation</strong> — clicking buttons and dragging sliders through accessibility APIs or screenshot analysis is brittle</li>
<li><strong>Binary formats</strong> — proprietary project files can’t be read, diffed, or generated as text</li>
<li><strong>Implicit state</strong> — engine state lives in inspector panels, viewport selections, and undo histories that agents can’t access</li>
</ul>
<p>Flint eliminates all of these friction points.</p>
<h2 id="structured-input-and-output"><a class="header" href="#structured-input-and-output">Structured Input and Output</a></h2>
<p>Every Flint command accepts text input and produces structured text output:</p>
<pre><code class="language-bash"># JSON output for machine parsing
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml --format json

# Exit codes signal success (0) or failure (1)
flint validate levels/tavern.scene.toml --format json
echo $?  # 0 = valid, 1 = violations found
</code></pre>
<p>An agent can create entities, modify scenes, and inspect state entirely through text — no screenshots, no pixel coordinates, no GUI automation.</p>
<h2 id="query-based-introspection"><a class="header" href="#query-based-introspection">Query-Based Introspection</a></h2>
<p>The query language gives agents programmatic access to scene state. Instead of reading a screenshot to count doors, an agent can:</p>
<pre><code class="language-bash"># How many doors are in this scene?
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml --format json | jq length

# Is this door locked?
flint query "entities where door.locked == true" --scene levels/tavern.scene.toml --format json

# What components does the player entity have?
flint query "entities where archetype == 'player'" --scene levels/tavern.scene.toml --format json
</code></pre>
<p>Queries return structured data that agents can parse, reason about, and use to plan their next action.</p>
<h2 id="constraint-validation-as-feedback"><a class="header" href="#constraint-validation-as-feedback">Constraint Validation as Feedback</a></h2>
<p>Constraints provide an automated feedback loop. An agent doesn’t need a human to check its work — it can validate programmatically:</p>
<pre><code class="language-bash"># Agent creates some entities...
flint entity create --archetype door --name "secret_door" --scene levels/tavern.scene.toml

# Then checks if the scene is still valid
flint validate levels/tavern.scene.toml --format json
</code></pre>
<p>If validation fails, the JSON output tells the agent exactly what’s wrong and how to fix it. The <code>--fix --dry-run</code> mode even previews what auto-fixes would apply. This creates a tight create-validate-fix loop that agents can execute without human intervention.</p>
<h2 id="schema-introspection"><a class="header" href="#schema-introspection">Schema Introspection</a></h2>
<p>Agents can discover what components and archetypes are available without reading documentation:</p>
<pre><code class="language-bash"># What fields does the 'door' component have?
flint schema door

# What components does the 'player' archetype include?
flint schema player
</code></pre>
<p>This means an agent can learn the engine’s data model at runtime, then use that knowledge to create valid entities.</p>
<h2 id="headless-rendering"><a class="header" href="#headless-rendering">Headless Rendering</a></h2>
<p>Visual verification without a window:</p>
<pre><code class="language-bash"># Render the scene to an image file
flint render levels/tavern.scene.toml --output preview.png --width 1920 --height 1080
</code></pre>
<p>An agent (or its supervisor) can render a preview image to check that the scene looks correct, without opening a GUI. This enables visual regression testing in CI and supports workflows where an agent builds a scene, renders a preview, and a human reviews the image.</p>
<h2 id="toml-as-scene-format"><a class="header" href="#toml-as-scene-format">TOML as Scene Format</a></h2>
<p>Scenes are plain TOML text files. An agent can:</p>
<ul>
<li><strong>Read</strong> a scene file directly as text</li>
<li><strong>Write</strong> entity data by editing TOML</li>
<li><strong>Diff</strong> changes with standard tools (<code>git diff</code>)</li>
<li><strong>Generate</strong> entire scenes programmatically</li>
<li><strong>Merge</strong> changes from multiple agents without conflicts (each entity is a distinct TOML section)</li>
</ul>
<p>No proprietary binary formats, no deserialization libraries, no SDK required.</p>
<h2 id="ai-asset-generation"><a class="header" href="#ai-asset-generation">AI Asset Generation</a></h2>
<p>Phase 5 extends the agent interface to asset creation. Agents can generate textures, 3D models, and audio through CLI commands:</p>
<pre><code class="language-bash"># Generate a texture using AI
flint asset generate texture -d "rough stone wall with mortar lines" --style medieval_tavern

# Batch-generate all missing assets for a scene
flint asset resolve my_scene.scene.toml --strategy ai_generate --style medieval_tavern
</code></pre>
<p>Style guides ensure generated assets maintain visual consistency, and model validation checks results against constraints — the same automated feedback loop that works for scene structure now works for asset quality.</p>
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further Reading</a></h2>
<ul>
<li><a href="#cli-first-workflow">CLI-First Workflow</a> — the composable command interface</li>
<li><a href="#ai-agent-workflow">AI Agent Workflow</a> — step-by-step guide for agent developers</li>
<li><a href="#ai-asset-generation-1">AI Asset Generation</a> — the AI asset generation pipeline</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Flint is built from source using the Rust toolchain. There are no pre-built binaries yet.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><strong>Rust</strong> (stable, 1.75+) — install from <a href="https://rustup.rs/">rustup.rs</a></li>
<li><strong>Git</strong> — for cloning the repository</li>
<li>A GPU with <strong>Vulkan</strong>, <strong>Metal</strong>, or <strong>DX12</strong> support (for the renderer and viewer)</li>
</ul>
<h2 id="build-from-source"><a class="header" href="#build-from-source">Build from Source</a></h2>
<p>Clone the repository and build in release mode:</p>
<pre><code class="language-bash">git clone https://github.com/chaps/flint.git
cd flint
cargo build --release
</code></pre>
<p>The binary is at <code>target/release/flint</code> (or <code>target/release/flint.exe</code> on Windows).</p>
<h2 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h2>
<pre><code class="language-bash">cargo run --bin flint -- --version
</code></pre>
<p>You should see the Flint version string.</p>
<h2 id="running-without-installing"><a class="header" href="#running-without-installing">Running Without Installing</a></h2>
<p>You can run Flint directly through Cargo without installing it system-wide:</p>
<pre><code class="language-bash">cargo run --bin flint -- &lt;command&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-bash">cargo run --bin flint -- init my-game
cargo run --bin flint -- serve demo/showcase.scene.toml --watch
</code></pre>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<p>To verify everything is working:</p>
<pre><code class="language-bash">cargo test
</code></pre>
<p>This runs the full test suite across all crates.</p>
<h2 id="optional-add-to-path"><a class="header" href="#optional-add-to-path">Optional: Add to PATH</a></h2>
<p>To use <code>flint</code> directly without <code>cargo run</code>:</p>
<pre><code class="language-bash">cargo install --path crates/flint-cli
</code></pre>
<p>Or copy the release binary to a directory on your PATH.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What’s Next</a></h2>
<p>With Flint built, follow <a href="#your-first-project">Your First Project</a> to create a scene from scratch.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-project"><a class="header" href="#your-first-project">Your First Project</a></h1>
<p>This guide walks through creating a Flint project and building a simple scene using only CLI commands.</p>
<h2 id="initialize-a-project"><a class="header" href="#initialize-a-project">Initialize a Project</a></h2>
<pre><code class="language-bash">flint init my-tavern
</code></pre>
<p>This creates a project directory with the standard structure:</p>
<pre><code>my-tavern/
├── schemas/
│   ├── components/
│   │   ├── transform.toml
│   │   ├── bounds.toml
│   │   └── door.toml
│   ├── archetypes/
│   │   ├── room.toml
│   │   ├── door.toml
│   │   ├── furniture.toml
│   │   └── character.toml
│   └── constraints/
│       └── basics.toml
├── levels/
└── assets/
</code></pre>
<p>The <code>schemas/</code> directory contains default component definitions, archetype bundles, and constraint rules. You’ll modify and extend these as your project grows.</p>
<h2 id="create-a-scene"><a class="header" href="#create-a-scene">Create a Scene</a></h2>
<pre><code class="language-bash">flint scene create my-tavern/levels/tavern.scene.toml --name "The Rusty Flint Tavern"
</code></pre>
<p>This creates an empty scene file:</p>
<pre><code class="language-toml">[scene]
name = "The Rusty Flint Tavern"
version = "1.0"
</code></pre>
<h2 id="add-rooms"><a class="header" href="#add-rooms">Add Rooms</a></h2>
<p>Build out the space with room entities:</p>
<pre><code class="language-bash">flint entity create --archetype room --name "main_hall" \
    --scene my-tavern/levels/tavern.scene.toml \
    --schemas my-tavern/schemas \
    --props '{"transform":{"position":[0,0,0]},"bounds":{"min":[-7,0,-5],"max":[7,4,5]}}'
</code></pre>
<p>The <code>--archetype room</code> flag tells Flint to create an entity with the components defined in <code>schemas/archetypes/room.toml</code> (transform + bounds). The <code>--props</code> flag provides the specific values.</p>
<p>Add a kitchen connected to the main hall:</p>
<pre><code class="language-bash">flint entity create --archetype room --name "kitchen" \
    --parent "main_hall" \
    --scene my-tavern/levels/tavern.scene.toml \
    --schemas my-tavern/schemas \
    --props '{"transform":{"position":[0,0,-9]},"bounds":{"min":[-4,0,-3],"max":[4,3.5,3]}}'
</code></pre>
<p>The <code>--parent</code> flag establishes a hierarchy — the kitchen is a child of the main hall.</p>
<h2 id="add-a-door"><a class="header" href="#add-a-door">Add a Door</a></h2>
<pre><code class="language-bash">flint entity create --archetype door --name "front_entrance" \
    --parent "main_hall" \
    --scene my-tavern/levels/tavern.scene.toml \
    --schemas my-tavern/schemas \
    --props '{"transform":{"position":[0,0,5]},"door":{"style":"hinged","locked":false}}'
</code></pre>
<h2 id="query-your-scene"><a class="header" href="#query-your-scene">Query Your Scene</a></h2>
<p>See what you’ve built:</p>
<pre><code class="language-bash">flint query "entities" --scene my-tavern/levels/tavern.scene.toml
</code></pre>
<p>Filter for specific archetypes:</p>
<pre><code class="language-bash">flint query "entities where archetype == 'door'" --scene my-tavern/levels/tavern.scene.toml
</code></pre>
<h2 id="inspect-the-scene-file"><a class="header" href="#inspect-the-scene-file">Inspect the Scene File</a></h2>
<p>The scene is plain TOML. Open <code>my-tavern/levels/tavern.scene.toml</code> and you’ll see:</p>
<pre><code class="language-toml">[scene]
name = "The Rusty Flint Tavern"
version = "1.0"

[entities.main_hall]
archetype = "room"

[entities.main_hall.transform]
position = [0, 0, 0]

[entities.main_hall.bounds]
min = [-7, 0, -5]
max = [7, 4, 5]

[entities.kitchen]
archetype = "room"
parent = "main_hall"

[entities.kitchen.transform]
position = [0, 0, -9]

[entities.kitchen.bounds]
min = [-4, 0, -3]
max = [4, 3.5, 3]

[entities.front_entrance]
archetype = "door"
parent = "main_hall"

[entities.front_entrance.transform]
position = [0, 0, 5]

[entities.front_entrance.door]
style = "hinged"
locked = false
</code></pre>
<p>Everything is readable, editable, and diffable. You can modify this file directly — the CLI isn’t the only way to edit scenes.</p>
<h2 id="view-it"><a class="header" href="#view-it">View It</a></h2>
<p>Launch the hot-reload viewer:</p>
<pre><code class="language-bash">flint serve my-tavern/levels/tavern.scene.toml --watch --schemas my-tavern/schemas
</code></pre>
<p>A window opens showing your scene as colored boxes:</p>
<ul>
<li><strong>Blue</strong> wireframes for rooms</li>
<li><strong>Orange</strong> boxes for doors</li>
<li><strong>Green</strong> boxes for furniture</li>
<li><strong>Yellow</strong> boxes for characters</li>
</ul>
<p>The viewer hot-reloads — any change to the scene file (from the CLI, a text editor, or an AI agent) updates the view instantly.</p>
<p><strong>Camera controls:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>Left-drag</td><td>Orbit</td></tr>
<tr><td>Right-drag</td><td>Pan</td></tr>
<tr><td>Scroll</td><td>Zoom</td></tr>
<tr><td>Space</td><td>Reset camera</td></tr>
<tr><td>R</td><td>Force reload</td></tr>
<tr><td>Escape</td><td>Quit</td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What’s Next</a></h2>
<ul>
<li><a href="#your-first-scene">Your First Scene</a> dives deeper into scene file structure</li>
<li><a href="#querying-entities">Querying Entities</a> covers the query language</li>
<li><a href="#building-a-tavern">Building a Tavern</a> walks through a complete scene build</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-scene"><a class="header" href="#your-first-scene">Your First Scene</a></h1>
<p>A Flint scene is a TOML file describing entities, their components, and their relationships. This page explains the scene format by building one from scratch.</p>
<h2 id="scene-structure"><a class="header" href="#scene-structure">Scene Structure</a></h2>
<p>Every scene file has two sections: metadata and entities.</p>
<pre><code class="language-toml"># Metadata
[scene]
name = "My Scene"
version = "1.0"
description = "An optional description"

# Entities
[entities.my_entity]
archetype = "room"

[entities.my_entity.transform]
position = [0, 0, 0]
</code></pre>
<p>The <code>[scene]</code> table holds metadata. Everything under <code>[entities.*]</code> defines the objects in your world.</p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<p>An entity is a named thing in the scene. Its name is the key under <code>[entities]</code>:</p>
<pre><code class="language-toml">[entities.main_hall]
archetype = "room"
</code></pre>
<p>Entities can optionally have:</p>
<ul>
<li>An <strong>archetype</strong> — a schema-defined bundle of components</li>
<li>A <strong>parent</strong> — another entity this one is attached to</li>
<li><strong>Components</strong> — data tables nested under the entity</li>
</ul>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>Components are data attached to entities. They’re defined as nested TOML tables:</p>
<pre><code class="language-toml">[entities.main_hall]
archetype = "room"

[entities.main_hall.transform]
position = [0, 0, 0]

[entities.main_hall.bounds]
min = [-7, 0, -5]
max = [7, 4, 5]
</code></pre>
<p>The <code>transform</code> and <code>bounds</code> components are defined by schema files in <code>schemas/components/</code>. The schema tells Flint what fields are valid and what types they are.</p>
<h2 id="parent-child-relationships"><a class="header" href="#parent-child-relationships">Parent-Child Relationships</a></h2>
<p>Entities form hierarchies through the <code>parent</code> field:</p>
<pre><code class="language-toml">[entities.main_hall]
archetype = "room"

[entities.main_hall.transform]
position = [0, 0, 0]

[entities.kitchen]
archetype = "room"
parent = "main_hall"

[entities.kitchen.transform]
position = [0, 0, -9]
</code></pre>
<p>The kitchen is a child of the main hall. In the viewer, child transforms are relative to their parent.</p>
<h2 id="a-complete-example"><a class="header" href="#a-complete-example">A Complete Example</a></h2>
<p>Here’s a small but complete scene — a room with a door and a table:</p>
<pre><code class="language-toml">[scene]
name = "Simple Room"
version = "1.0"

[entities.room]
archetype = "room"

[entities.room.transform]
position = [0, 0, 0]

[entities.room.bounds]
min = [-5, 0, -5]
max = [5, 3, 5]

[entities.door]
archetype = "door"
parent = "room"

[entities.door.transform]
position = [0, 0, 5]

[entities.door.door]
style = "hinged"
locked = false
open_angle = 90.0

[entities.table]
archetype = "furniture"
parent = "room"

[entities.table.transform]
position = [0, 0, 0]

[entities.table.bounds]
min = [-0.6, 0, -0.6]
max = [0.6, 0.8, 0.6]
</code></pre>
<h2 id="editing-scenes"><a class="header" href="#editing-scenes">Editing Scenes</a></h2>
<p>You can edit scene files in three ways:</p>
<ol>
<li><strong>CLI commands</strong> — <code>flint entity create</code>, <code>flint entity delete</code>, etc.</li>
<li><strong>Text editor</strong> — open the TOML file directly</li>
<li><strong>Programmatically</strong> — any tool that can write TOML</li>
</ol>
<p>All three approaches produce the same result. The <code>flint serve --watch</code> viewer detects changes from any source and reloads automatically.</p>
<h2 id="validating-scenes"><a class="header" href="#validating-scenes">Validating Scenes</a></h2>
<p>Run the constraint checker to verify your scene is well-formed:</p>
<pre><code class="language-bash">flint validate levels/my-scene.scene.toml --schemas schemas
</code></pre>
<p>This checks your scene against the rules defined in <code>schemas/constraints/</code>. See <a href="#constraints">Constraints</a> for details.</p>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What’s Next</a></h2>
<ul>
<li><a href="#entities-and-ecs">Entities and ECS</a> explains the entity-component system</li>
<li><a href="#schemas">Schemas</a> covers how components and archetypes are defined</li>
<li><a href="#scenes">Scenes</a> goes deeper into the scene system internals</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="querying-entities"><a class="header" href="#querying-entities">Querying Entities</a></h1>
<p>Flint includes a SQL-inspired query language for filtering and inspecting entities. Queries let you search scenes by archetype, component values, or nested field data.</p>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h2>
<p>All queries follow the pattern:</p>
<pre><code>entities where &lt;condition&gt;
</code></pre>
<p>The simplest query returns all entities:</p>
<pre><code class="language-bash">flint query "entities" --scene levels/tavern.scene.toml
</code></pre>
<h2 id="filtering-by-archetype"><a class="header" href="#filtering-by-archetype">Filtering by Archetype</a></h2>
<p>The most common filter — find entities of a specific type:</p>
<pre><code class="language-bash"># Find all doors
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml

# Find all rooms
flint query "entities where archetype == 'room'" --scene levels/tavern.scene.toml
</code></pre>
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Meaning</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>==</code></td><td>Equal</td><td><code>archetype == 'door'</code></td></tr>
<tr><td><code>!=</code></td><td>Not equal</td><td><code>archetype != 'room'</code></td></tr>
<tr><td><code>&gt;</code></td><td>Greater than</td><td><code>transform.position.y &gt; 5.0</code></td></tr>
<tr><td><code>&lt;</code></td><td>Less than</td><td><code>door.open_angle &lt; 90</code></td></tr>
<tr><td><code>&gt;=</code></td><td>Greater or equal</td><td><code>audio_source.volume &gt;= 0.5</code></td></tr>
<tr><td><code>&lt;=</code></td><td>Less or equal</td><td><code>collider.friction &lt;= 0.3</code></td></tr>
<tr><td><code>contains</code></td><td>String contains</td><td><code>name contains 'wall'</code></td></tr>
</tbody>
</table>
</div>
<h2 id="querying-component-fields"><a class="header" href="#querying-component-fields">Querying Component Fields</a></h2>
<p>Access component fields with dot notation:</p>
<pre><code class="language-bash"># Find locked doors
flint query "entities where door.locked == true" --scene levels/tavern.scene.toml

# Find entities above a certain height
flint query "entities where transform.position.y &gt; 2.0" --scene levels/tavern.scene.toml

# Find loud audio sources
flint query "entities where audio_source.volume &gt; 0.8" --scene levels/tavern.scene.toml
</code></pre>
<h2 id="output-formats"><a class="header" href="#output-formats">Output Formats</a></h2>
<p>Query results can be formatted for different consumers:</p>
<pre><code class="language-bash"># Human-readable (default)
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml

# JSON for scripting and AI agents
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml --format json

# TOML for configuration workflows
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml --format toml
</code></pre>
<h2 id="combining-with-shell-tools"><a class="header" href="#combining-with-shell-tools">Combining with Shell Tools</a></h2>
<p>JSON output composes with standard tools:</p>
<pre><code class="language-bash"># Count doors
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml --format json | jq length

# Get just the names
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml --format json | jq '.[].name'

# Find entities with a specific parent
flint query "entities" --scene levels/tavern.scene.toml --format json | jq '.[] | select(.parent == "main_hall")'
</code></pre>
<h2 id="further-reading-2"><a class="header" href="#further-reading-2">Further Reading</a></h2>
<ul>
<li><a href="#queries">Queries</a> — full grammar reference and advanced usage</li>
<li><a href="#constraints">Constraints</a> — queries used in validation rules</li>
<li><a href="#cli-reference">CLI Reference</a> — all command options</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-scene-viewer"><a class="header" href="#the-scene-viewer">The Scene Viewer</a></h1>
<p>The Flint viewer is a real-time 3D window for validating scenes. It renders your scene with full PBR shading and shadows, and provides an egui inspector panel for browsing entities and editing component properties.</p>
<h2 id="launching-the-viewer"><a class="header" href="#launching-the-viewer">Launching the Viewer</a></h2>
<pre><code class="language-bash">flint serve levels/tavern.scene.toml --watch --schemas schemas
</code></pre>
<p>The <code>--watch</code> flag enables hot-reload: edit the scene TOML file, and the viewer re-parses and re-renders automatically. The entire file is re-parsed on each change (not incremental), which keeps the implementation simple and avoids synchronization issues.</p>
<h2 id="camera-controls"><a class="header" href="#camera-controls">Camera Controls</a></h2>
<p>The viewer uses an orbit camera that rotates around a focus point:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>Left-drag</td><td>Orbit around focus</td></tr>
<tr><td>Right-drag</td><td>Pan the view</td></tr>
<tr><td>Scroll</td><td>Zoom in/out</td></tr>
<tr><td>Space</td><td>Reset camera</td></tr>
<tr><td>R</td><td>Force reload</td></tr>
<tr><td>Escape</td><td>Quit</td></tr>
</tbody>
</table>
</div>
<h2 id="the-inspector-panel"><a class="header" href="#the-inspector-panel">The Inspector Panel</a></h2>
<p>The egui-based inspector panel (on the left side of the viewer) provides:</p>
<ul>
<li><strong>Entity tree</strong> — hierarchical list of all entities in the scene, reflecting parent-child relationships</li>
<li><strong>Component editor</strong> — select an entity to view and edit its component values</li>
<li><strong>Constraint overlay</strong> — validation results from <code>flint-constraint</code>, highlighting any rule violations</li>
</ul>
<h2 id="rendering-features"><a class="header" href="#rendering-features">Rendering Features</a></h2>
<p>The viewer renders scenes with the same PBR pipeline used by the player:</p>
<ul>
<li>Cook-Torrance physically-based shading</li>
<li>Cascaded shadow mapping from directional lights</li>
<li>glTF mesh rendering with material support</li>
<li>Debug rendering modes (cycle with <strong>F1</strong>)</li>
<li>Shadow toggle (<strong>F4</strong>)</li>
<li>Fullscreen toggle (<strong>F11</strong>)</li>
</ul>
<h2 id="playing-a-scene"><a class="header" href="#playing-a-scene">Playing a Scene</a></h2>
<p>To experience a scene in first-person with physics, use <code>play</code> instead of <code>serve</code>:</p>
<pre><code class="language-bash">flint play levels/tavern.scene.toml
</code></pre>
<p>See the <a href="#cli-reference">CLI Reference</a> for full <code>play</code> command details and controls.</p>
<h2 id="headless-rendering-1"><a class="header" href="#headless-rendering-1">Headless Rendering</a></h2>
<p>For CI pipelines and automated screenshots, render to PNG without opening a window:</p>
<pre><code class="language-bash">flint render levels/tavern.scene.toml --output preview.png --width 1920 --height 1080
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="entities-and-ecs"><a class="header" href="#entities-and-ecs">Entities and ECS</a></h1>
<p>Flint uses an Entity-Component-System (ECS) architecture, built on top of the <a href="https://crates.io/crates/hecs">hecs</a> crate. This page explains how entities, components, and IDs work in Flint.</p>
<h2 id="what-is-ecs"><a class="header" href="#what-is-ecs">What Is ECS?</a></h2>
<p>In an ECS architecture:</p>
<ul>
<li><strong>Entities</strong> are unique identifiers (not objects with methods)</li>
<li><strong>Components</strong> are pure data attached to entities</li>
<li><strong>Systems</strong> are logic that operates on entities with specific component combinations</li>
</ul>
<p>Flint’s twist: components are <strong>dynamic</strong>. Instead of being Rust structs compiled into the engine, they’re defined at runtime as TOML schema files and stored as <code>toml::Value</code>. This means you can define new component types without recompiling the engine.</p>
<h2 id="entity-ids"><a class="header" href="#entity-ids">Entity IDs</a></h2>
<p>Every entity gets a stable <code>EntityId</code> — a 64-bit integer that:</p>
<ul>
<li>Is unique within a scene</li>
<li>Never gets recycled (monotonically increasing)</li>
<li>Persists across save/load cycles</li>
<li>Is deterministic (the same scene always produces the same IDs)</li>
</ul>
<p>Internally, Flint maintains a bidirectional map (<code>BiMap</code>) between <code>EntityId</code> values and hecs <code>Entity</code> handles. This allows efficient lookup in both directions.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From flint-core
pub struct EntityId(pub u64);
<span class="boring">}</span></code></pre>
<p>When loading a saved scene, the ID counter is adjusted to be higher than any existing ID, preventing collisions when new entities are created.</p>
<h2 id="named-entities"><a class="header" href="#named-entities">Named Entities</a></h2>
<p>While entity IDs are the internal identifier, entities in Flint are also <strong>named</strong>. The name is the key in the scene file:</p>
<pre><code class="language-toml">[entities.front_door]     # "front_door" is the name
archetype = "door"
</code></pre>
<p>Names must be unique within a scene. They’re used in:</p>
<ul>
<li>CLI commands: <code>--name "front_door"</code></li>
<li>Parent references: <code>parent = "main_hall"</code></li>
<li>Query results</li>
<li>Constraint violation messages</li>
</ul>
<h2 id="components-as-dynamic-data"><a class="header" href="#components-as-dynamic-data">Components as Dynamic Data</a></h2>
<p>In most ECS implementations, components are Rust structs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOT how Flint works
struct Transform { position: Vec3, rotation: Vec3 }
<span class="boring">}</span></code></pre>
<p>In Flint, components are <code>toml::Value</code> maps, defined by schema files:</p>
<pre><code class="language-toml"># schemas/components/transform.toml
[component.transform]
description = "Position and rotation in 3D space"

[component.transform.fields]
position = { type = "vec3", default = [0, 0, 0] }
rotation = { type = "vec3", default = [0, 0, 0] }
scale = { type = "vec3", default = [1, 1, 1] }
</code></pre>
<p>This design trades some type safety and performance for flexibility — archetypes and components can be defined, modified, and extended without touching Rust code.</p>
<h2 id="parent-child-relationships-1"><a class="header" href="#parent-child-relationships-1">Parent-Child Relationships</a></h2>
<p>Entities can form hierarchies. A child entity references its parent by name:</p>
<pre><code class="language-toml">[entities.kitchen]
archetype = "room"
parent = "main_hall"
</code></pre>
<p>The ECS layer tracks these relationships, enabling:</p>
<ul>
<li>Hierarchical transforms (child positions are relative to parent)</li>
<li>Tree queries (“find all children of main_hall”)</li>
<li>Cascading operations (deleting a parent removes children)</li>
</ul>
<h2 id="archetypes"><a class="header" href="#archetypes">Archetypes</a></h2>
<p>An archetype is a named bundle of components that defines an entity “type”:</p>
<pre><code class="language-toml"># schemas/archetypes/door.toml
[archetype.door]
description = "A door entity"
components = ["transform", "door"]

[archetype.door.defaults.door]
style = "hinged"
locked = false
</code></pre>
<p>When you create an entity with <code>--archetype door</code>, Flint ensures it has the required components and fills in defaults for any missing values.</p>
<p>Archetypes are not rigid types — an entity can have components beyond what its archetype specifies. The archetype defines the <em>minimum</em> set.</p>
<h2 id="working-with-entities-via-cli"><a class="header" href="#working-with-entities-via-cli">Working with Entities via CLI</a></h2>
<pre><code class="language-bash"># Create an entity
flint entity create --archetype door --name "vault_door" \
    --scene levels/dungeon.scene.toml \
    --schemas schemas \
    --props '{"transform":{"position":[0,0,0]},"door":{"locked":true}}'

# Delete an entity
flint entity delete --name "vault_door" --scene levels/dungeon.scene.toml

# List entities in a scene
flint query "entities" --scene levels/dungeon.scene.toml

# Filter by archetype
flint query "entities where archetype == 'door'" --scene levels/dungeon.scene.toml
</code></pre>
<h2 id="further-reading-3"><a class="header" href="#further-reading-3">Further Reading</a></h2>
<ul>
<li><a href="#schemas">Schemas</a> — how components and archetypes are defined</li>
<li><a href="#scenes">Scenes</a> — how entities are serialized to TOML</li>
<li><a href="#queries">Queries</a> — how to filter and inspect entities</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="schemas"><a class="header" href="#schemas">Schemas</a></h1>
<p>Schemas define the structure of your game world. They specify what components exist, what fields they contain, and how they bundle together into archetypes. Schemas are TOML files stored in the <code>schemas/</code> directory of your project.</p>
<h2 id="component-schemas"><a class="header" href="#component-schemas">Component Schemas</a></h2>
<p>A component schema defines a reusable data type. Components live in <code>schemas/components/</code>:</p>
<pre><code class="language-toml"># schemas/components/door.toml
[component.door]
description = "A door that can connect spaces"

[component.door.fields]
style = { type = "enum", values = ["hinged", "sliding", "rotating"], default = "hinged" }
locked = { type = "bool", default = false }
open_angle = { type = "f32", default = 90.0, min = 0.0, max = 180.0 }
</code></pre>
<h3 id="field-types"><a class="header" href="#field-types">Field Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>bool</code></td><td>Boolean</td><td><code>true</code> / <code>false</code></td></tr>
<tr><td><code>i32</code></td><td>32-bit integer</td><td><code>42</code></td></tr>
<tr><td><code>f32</code></td><td>32-bit float</td><td><code>3.14</code></td></tr>
<tr><td><code>string</code></td><td>Text string</td><td><code>"hello"</code></td></tr>
<tr><td><code>vec3</code></td><td>3D vector (array of 3 floats)</td><td><code>[1.0, 2.0, 3.0]</code></td></tr>
<tr><td><code>enum</code></td><td>One of a set of string values</td><td><code>"hinged"</code></td></tr>
<tr><td><code>entity_ref</code></td><td>Reference to another entity by name</td><td><code>"main_hall"</code></td></tr>
</tbody>
</table>
</div>
<h3 id="field-constraints"><a class="header" href="#field-constraints">Field Constraints</a></h3>
<p>Fields can include validation constraints:</p>
<pre><code class="language-toml">open_angle = { type = "f32", default = 90.0, min = 0.0, max = 180.0 }
required_key = { type = "entity_ref", optional = true }
</code></pre>
<ul>
<li><code>default</code> — value used when not explicitly set</li>
<li><code>min</code> / <code>max</code> — numeric range bounds</li>
<li><code>optional</code> — whether the field can be omitted (defaults to false)</li>
<li><code>values</code> — valid options for enum types</li>
</ul>
<h2 id="built-in-components"><a class="header" href="#built-in-components">Built-in Components</a></h2>
<p>Flint ships with seven built-in component schemas:</p>
<h3 id="transform"><a class="header" href="#transform">Transform</a></h3>
<pre><code class="language-toml"># schemas/components/transform.toml
[component.transform]
description = "Position and rotation in 3D space"

[component.transform.fields]
position = { type = "vec3", default = [0, 0, 0] }
rotation = { type = "vec3", default = [0, 0, 0] }
scale = { type = "vec3", default = [1, 1, 1] }
</code></pre>
<h3 id="bounds"><a class="header" href="#bounds">Bounds</a></h3>
<pre><code class="language-toml"># schemas/components/bounds.toml
[component.bounds]
description = "Axis-aligned bounding box"

[component.bounds.fields]
min = { type = "vec3", default = [0, 0, 0] }
max = { type = "vec3", default = [10, 4, 10] }
</code></pre>
<h3 id="door"><a class="header" href="#door">Door</a></h3>
<pre><code class="language-toml"># schemas/components/door.toml
[component.door]
description = "A door that can connect spaces"

[component.door.fields]
style = { type = "enum", values = ["hinged", "sliding", "rotating"], default = "hinged" }
locked = { type = "bool", default = false }
open_angle = { type = "f32", default = 90.0, min = 0.0, max = 180.0 }
</code></pre>
<h3 id="material"><a class="header" href="#material">Material</a></h3>
<pre><code class="language-toml"># schemas/components/material.toml
[component.material]
description = "PBR material properties"

[component.material.fields]
texture = { type = "string", default = "", optional = true }
roughness = { type = "f32", default = 0.5, min = 0.0, max = 1.0 }
metallic = { type = "f32", default = 0.0, min = 0.0, max = 1.0 }
color = { type = "vec3", default = [1.0, 1.0, 1.0] }
emissive = { type = "vec3", default = [0.0, 0.0, 0.0] }
</code></pre>
<h3 id="rigidbody"><a class="header" href="#rigidbody">Rigidbody</a></h3>
<pre><code class="language-toml"># schemas/components/rigidbody.toml
[component.rigidbody]
description = "Physics rigid body"

[component.rigidbody.fields]
body_type = { type = "enum", values = ["static", "dynamic", "kinematic"], default = "static" }
mass = { type = "f32", default = 1.0, min = 0.0 }
gravity_scale = { type = "f32", default = 1.0 }
</code></pre>
<h3 id="collider"><a class="header" href="#collider">Collider</a></h3>
<pre><code class="language-toml"># schemas/components/collider.toml
[component.collider]
description = "Physics collision shape"

[component.collider.fields]
shape = { type = "enum", values = ["box", "sphere", "capsule"], default = "box" }
size = { type = "vec3", default = [1.0, 1.0, 1.0] }
friction = { type = "f32", default = 0.5, min = 0.0, max = 1.0 }
</code></pre>
<h3 id="character-controller"><a class="header" href="#character-controller">Character Controller</a></h3>
<pre><code class="language-toml"># schemas/components/character_controller.toml
[component.character_controller]
description = "First-person character controller"

[component.character_controller.fields]
move_speed = { type = "f32", default = 5.0, min = 0.0 }
jump_force = { type = "f32", default = 7.0, min = 0.0 }
height = { type = "f32", default = 1.8, min = 0.1 }
radius = { type = "f32", default = 0.4, min = 0.1 }
camera_mode = { type = "enum", values = ["first_person", "orbit"], default = "first_person" }
</code></pre>
<h2 id="archetype-schemas"><a class="header" href="#archetype-schemas">Archetype Schemas</a></h2>
<p>Archetypes bundle components together with defaults. They live in <code>schemas/archetypes/</code>:</p>
<pre><code class="language-toml"># schemas/archetypes/room.toml
[archetype.room]
description = "A room or enclosed space"
components = ["transform", "bounds"]

[archetype.room.defaults.bounds]
min = [0, 0, 0]
max = [10, 4, 10]
</code></pre>
<p>The <code>components</code> array lists which component schemas an entity of this archetype requires. The <code>defaults</code> section provides values used when a component field isn’t explicitly set.</p>
<h3 id="built-in-archetypes"><a class="header" href="#built-in-archetypes">Built-in Archetypes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Archetype</th><th>Components</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>room</code></td><td>transform, bounds</td><td>An enclosed space</td></tr>
<tr><td><code>door</code></td><td>transform, door</td><td>A door entity</td></tr>
<tr><td><code>furniture</code></td><td>transform, bounds</td><td>A piece of furniture</td></tr>
<tr><td><code>character</code></td><td>transform</td><td>A character or NPC</td></tr>
<tr><td><code>wall</code></td><td>transform, bounds, material</td><td>A wall surface</td></tr>
<tr><td><code>floor</code></td><td>transform, bounds, material</td><td>A floor surface</td></tr>
<tr><td><code>ceiling</code></td><td>transform, bounds, material</td><td>A ceiling surface</td></tr>
<tr><td><code>pillar</code></td><td>transform, bounds, material</td><td>A structural pillar</td></tr>
<tr><td><code>player</code></td><td>transform, character_controller, rigidbody, collider</td><td>Player-controlled entity</td></tr>
</tbody>
</table>
</div>
<h2 id="introspecting-schemas"><a class="header" href="#introspecting-schemas">Introspecting Schemas</a></h2>
<p>Use the CLI to inspect schema definitions:</p>
<pre><code class="language-bash"># Show a component schema
flint schema door --schemas schemas

# Show an archetype schema
flint schema room --schemas schemas
</code></pre>
<p>This outputs the component fields, types, defaults, and constraints — useful for both humans exploring the schema and AI agents discovering what fields are available.</p>
<h2 id="creating-custom-schemas"><a class="header" href="#creating-custom-schemas">Creating Custom Schemas</a></h2>
<p>To add a new component:</p>
<ol>
<li>Create a file in <code>schemas/components/</code>:</li>
</ol>
<pre><code class="language-toml"># schemas/components/health.toml
[component.health]
description = "Hit points and damage tracking"

[component.health.fields]
max_hp = { type = "i32", default = 100, min = 1 }
current_hp = { type = "i32", default = 100, min = 0 }
armor = { type = "f32", default = 0.0, min = 0.0, max = 1.0 }
</code></pre>
<ol start="2">
<li>Reference it in an archetype:</li>
</ol>
<pre><code class="language-toml"># schemas/archetypes/enemy.toml
[archetype.enemy]
description = "A hostile NPC"
components = ["transform", "health"]

[archetype.enemy.defaults.health]
max_hp = 50
current_hp = 50
</code></pre>
<ol start="3">
<li>Use it in a scene:</li>
</ol>
<pre><code class="language-toml">[entities.goblin]
archetype = "enemy"

[entities.goblin.transform]
position = [10, 0, 5]

[entities.goblin.health]
max_hp = 30
current_hp = 30
armor = 0.1
</code></pre>
<p>No engine recompilation needed — schemas are loaded at runtime from the TOML files.</p>
<h2 id="further-reading-4"><a class="header" href="#further-reading-4">Further Reading</a></h2>
<ul>
<li><a href="#entities-and-ecs">Entities and ECS</a> — how schemas connect to the entity system</li>
<li><a href="#constraints">Constraints</a> — rules that validate entities against schemas</li>
<li><a href="#scenes">Scenes</a> — how schema-defined entities are serialized</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="scenes"><a class="header" href="#scenes">Scenes</a></h1>
<p>A scene in Flint is a TOML file that describes a collection of entities and their data. Scenes are the primary unit of content — they’re what you load, save, query, validate, and render.</p>
<h2 id="file-format"><a class="header" href="#file-format">File Format</a></h2>
<p>Scene files use the <code>.scene.toml</code> extension and have two sections:</p>
<pre><code class="language-toml"># Metadata
[scene]
name = "The Rusty Flint Tavern"
version = "1.0"
description = "A showcase scene demonstrating Flint engine capabilities"

# Entity definitions
[entities.main_hall]
archetype = "room"
# ...
</code></pre>
<h3 id="the-scene-table"><a class="header" href="#the-scene-table">The <code>[scene]</code> Table</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td>yes</td><td>Human-readable scene name</td></tr>
<tr><td><code>version</code></td><td>yes</td><td>Format version (currently “1.0”)</td></tr>
<tr><td><code>description</code></td><td>no</td><td>Optional description</td></tr>
</tbody>
</table>
</div>
<h3 id="the-entities-tables"><a class="header" href="#the-entities-tables">The <code>[entities.*]</code> Tables</a></h3>
<p>Each entity is a table under <code>[entities]</code>, keyed by its unique name:</p>
<pre><code class="language-toml">[entities.front_door]
archetype = "door"
parent = "main_hall"

[entities.front_door.transform]
position = [0, 0, 5]

[entities.front_door.door]
style = "hinged"
locked = false
open_angle = 90.0
</code></pre>
<p><strong>Top-level fields:</strong></p>
<ul>
<li><code>archetype</code> — the archetype schema name (optional but recommended)</li>
<li><code>parent</code> — name of the parent entity (optional)</li>
</ul>
<p><strong>Component tables</strong> are nested under the entity. Each component name (e.g., <code>transform</code>, <code>door</code>, <code>bounds</code>) corresponds to a schema in <code>schemas/components/</code>.</p>
<h2 id="scene-operations"><a class="header" href="#scene-operations">Scene Operations</a></h2>
<h3 id="creating-a-scene"><a class="header" href="#creating-a-scene">Creating a Scene</a></h3>
<pre><code class="language-bash">flint scene create levels/tavern.scene.toml --name "The Tavern"
</code></pre>
<h3 id="listing-scenes"><a class="header" href="#listing-scenes">Listing Scenes</a></h3>
<pre><code class="language-bash">flint scene list
</code></pre>
<h3 id="getting-scene-info"><a class="header" href="#getting-scene-info">Getting Scene Info</a></h3>
<pre><code class="language-bash">flint scene info levels/tavern.scene.toml
</code></pre>
<h3 id="loading-and-saving"><a class="header" href="#loading-and-saving">Loading and Saving</a></h3>
<p>The <code>flint-scene</code> crate handles serialization. Scenes are loaded into the ECS world as entities with dynamic components, and saved back to TOML with stable ordering.</p>
<p>When a scene is loaded:</p>
<ol>
<li>The TOML is parsed into a scene structure</li>
<li>Each entity definition creates an ECS entity with a stable <code>EntityId</code></li>
<li>Parent-child relationships are established</li>
<li>The entity ID counter is adjusted to be above any existing ID (preventing collisions on subsequent creates)</li>
</ol>
<p>When a scene is saved:</p>
<ol>
<li>All entities are serialized to their TOML representation</li>
<li>Component data is written as nested tables</li>
<li>Parent references use entity names (not internal IDs)</li>
</ol>
<h2 id="reload-behavior"><a class="header" href="#reload-behavior">Reload Behavior</a></h2>
<p>Scene reload is a full re-parse. When <code>flint serve --watch</code> detects a file change:</p>
<ol>
<li>The entire scene file is re-read and re-parsed</li>
<li>The old world state is replaced with the new one</li>
<li>The renderer picks up the new state on the next frame</li>
</ol>
<p>This approach is simple and correct — there’s no incremental diffing that could get out of sync. For the scene sizes Flint targets, re-parsing is fast enough.</p>
<h2 id="scene-as-source-of-truth"><a class="header" href="#scene-as-source-of-truth">Scene as Source of Truth</a></h2>
<p>A key design decision: <strong>the scene file is the source of truth</strong>, not the in-memory state. This means:</p>
<ul>
<li>You can edit the file with any text editor</li>
<li>AI agents can write TOML directly</li>
<li>Git diffs show exactly what changed</li>
<li>No hidden state lives only in memory</li>
</ul>
<p>The CLI commands (<code>entity create</code>, <code>entity delete</code>) modify the scene file, and the in-memory world loads from that file. The viewer watches the file, not the internal state.</p>
<h2 id="example-the-showcase-scene"><a class="header" href="#example-the-showcase-scene">Example: The Showcase Scene</a></h2>
<p>The demo scene <code>demo/showcase.scene.toml</code> demonstrates the full format:</p>
<pre><code class="language-toml">[scene]
name = "The Rusty Flint Tavern"
version = "1.0"
description = "A showcase scene demonstrating Flint engine capabilities"

# Rooms - rendered as blue wireframe boxes
[entities.main_hall]
archetype = "room"

[entities.main_hall.transform]
position = [0, 0, 0]

[entities.main_hall.bounds]
min = [-7, 0, -5]
max = [7, 4, 5]

# Doors - rendered as orange boxes
[entities.front_entrance]
archetype = "door"
parent = "main_hall"

[entities.front_entrance.transform]
position = [0, 0, 5]

[entities.front_entrance.door]
style = "hinged"
locked = false
open_angle = 90.0

# Furniture - rendered as green boxes
[entities.bar_counter]
archetype = "furniture"
parent = "main_hall"

[entities.bar_counter.transform]
position = [-4, 0, 0]

[entities.bar_counter.bounds]
min = [-1.5, 0, -3]
max = [0, 1.2, 3]

# Characters - rendered as yellow boxes
[entities.bartender]
archetype = "character"
parent = "main_hall"

[entities.bartender.transform]
position = [-5, 0, 0]
</code></pre>
<p>This scene defines 4 rooms, 4 doors, 9 pieces of furniture, and 6 characters — all in readable, diffable TOML.</p>
<h2 id="further-reading-5"><a class="header" href="#further-reading-5">Further Reading</a></h2>
<ul>
<li><a href="#your-first-scene">Your First Scene</a> — hands-on guide to building a scene</li>
<li><a href="#entities-and-ecs">Entities and ECS</a> — how scene entities map to the ECS</li>
<li><a href="#schemas">Schemas</a> — how component structure is defined</li>
<li><a href="#constraints">Constraints</a> — how to validate scenes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Flint’s query system provides a SQL-inspired language for filtering and inspecting entities. Queries are parsed by a PEG grammar (pest) and executed against the ECS world.</p>
<h2 id="grammar"><a class="header" href="#grammar">Grammar</a></h2>
<p>The query language is defined in <code>crates/flint-query/src/grammar.pest</code>:</p>
<pre><code>query     = { resource ~ (where_clause)? }
resource  = { "entities" | "components" }
where_clause = { "where" ~ condition }
condition = { field ~ operator ~ value }
field     = { identifier ~ ("." ~ identifier)* }
operator  = { "==" | "!=" | "contains" | "&gt;=" | "&lt;=" | "&gt;" | "&lt;" }
value     = { string | number | boolean }
</code></pre>
<p>Whitespace is ignored between tokens. The <code>where</code> keyword is case-insensitive.</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>Two resource types can be queried:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Resource</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>entities</code></td><td>Returns entity data (name, archetype, components)</td></tr>
<tr><td><code>components</code></td><td>Returns component definitions from the schema registry</td></tr>
</tbody>
</table>
</div>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th><th>Value Types</th></tr>
</thead>
<tbody>
<tr><td><code>==</code></td><td>Exact equality</td><td>string, number, boolean</td></tr>
<tr><td><code>!=</code></td><td>Not equal</td><td>string, number, boolean</td></tr>
<tr><td><code>&gt;</code></td><td>Greater than</td><td>number</td></tr>
<tr><td><code>&lt;</code></td><td>Less than</td><td>number</td></tr>
<tr><td><code>&gt;=</code></td><td>Greater than or equal</td><td>number</td></tr>
<tr><td><code>&lt;=</code></td><td>Less than or equal</td><td>number</td></tr>
<tr><td><code>contains</code></td><td>Substring match</td><td>string</td></tr>
</tbody>
</table>
</div>
<h2 id="field-paths"><a class="header" href="#field-paths">Field Paths</a></h2>
<p>Fields use dot notation to access nested values:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Pattern</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>archetype</code></td><td>The entity’s archetype name</td></tr>
<tr><td><code>name</code></td><td>The entity’s name</td></tr>
<tr><td><code>door.locked</code></td><td>The <code>locked</code> field of the <code>door</code> component</td></tr>
<tr><td><code>transform.position</code></td><td>The <code>position</code> field of the <code>transform</code> component</td></tr>
</tbody>
</table>
</div>
<p>Examples:</p>
<pre><code class="language-bash"># Top-level entity properties
flint query "entities where archetype == 'door'"
flint query "entities where name contains 'wall'"

# Component fields
flint query "entities where door.locked == true"
flint query "entities where audio_source.volume &gt; 0.5"
flint query "entities where material.roughness &gt;= 0.8"
flint query "entities where collider.shape == 'box'"
</code></pre>
<h2 id="value-types"><a class="header" href="#value-types">Value Types</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Syntax</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td>String</td><td>Single or double quotes</td><td><code>'door'</code>, <code>"wall"</code></td></tr>
<tr><td>Number</td><td>Integers or decimals, optional negative</td><td><code>42</code>, <code>3.14</code>, <code>-1.5</code></td></tr>
<tr><td>Boolean</td><td>Unquoted keywords</td><td><code>true</code>, <code>false</code></td></tr>
</tbody>
</table>
</div>
<h2 id="use-in-constraints"><a class="header" href="#use-in-constraints">Use in Constraints</a></h2>
<p>Queries power the constraint system. Each constraint rule includes a <code>query</code> field that selects which entities the constraint applies to:</p>
<pre><code class="language-toml">[[constraint]]
name = "doors_have_transform"
query = "entities where archetype == 'door'"
severity = "error"
message = "Door '{name}' is missing a transform component"

[constraint.kind]
type = "required_component"
archetype = "door"
component = "transform"
</code></pre>
<p>The query selects all door entities, and the constraint checks that each one has a transform component. See <a href="#constraints">Constraints</a> for details.</p>
<h2 id="cli-usage"><a class="header" href="#cli-usage">CLI Usage</a></h2>
<pre><code class="language-bash"># Basic query
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml

# JSON output for machine consumption
flint query "entities" --scene levels/tavern.scene.toml --format json

# TOML output
flint query "entities where door.locked == true" --scene levels/tavern.scene.toml --format toml

# Specify schemas directory
flint query "entities" --scene levels/tavern.scene.toml --schemas schemas
</code></pre>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Conditions are currently single-clause (one field-operator-value comparison per query at the parser level)</li>
<li>Boolean combinators (<code>and</code>, <code>or</code>, <code>not</code>) are part of the grammar design but not yet implemented in the parser</li>
<li>Queries operate on in-memory ECS state, not directly on TOML files</li>
<li>Performance is linear in entity count (queries scan all entities matching the resource type)</li>
</ul>
<h2 id="further-reading-6"><a class="header" href="#further-reading-6">Further Reading</a></h2>
<ul>
<li><a href="#querying-entities">Querying Entities</a> — getting started tutorial</li>
<li><a href="#constraints">Constraints</a> — using queries in validation rules</li>
<li><a href="#cli-reference">CLI Reference</a> — command-line options</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="constraints"><a class="header" href="#constraints">Constraints</a></h1>
<p>Constraints are declarative validation rules that define what a correct scene looks like. They live in TOML files under <code>schemas/constraints/</code> and are checked by <code>flint validate</code>.</p>
<h2 id="constraint-file-format"><a class="header" href="#constraint-file-format">Constraint File Format</a></h2>
<p>Each constraint file can contain multiple <code>[[constraint]]</code> entries:</p>
<pre><code class="language-toml">[[constraint]]
name = "doors_have_transform"
description = "Every door must have a transform component"
query = "entities where archetype == 'door'"
severity = "error"
message = "Door '{name}' is missing a transform component"

[constraint.kind]
type = "required_component"
archetype = "door"
component = "transform"
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td>Unique identifier for the constraint</td></tr>
<tr><td><code>description</code></td><td>Human-readable explanation of what the rule checks</td></tr>
<tr><td><code>query</code></td><td>Flint query that selects which entities this constraint applies to</td></tr>
<tr><td><code>severity</code></td><td><code>"error"</code> (blocks) or <code>"warning"</code> (advisory)</td></tr>
<tr><td><code>message</code></td><td>Violation message. <code>{name}</code> is replaced with the entity name</td></tr>
</tbody>
</table>
</div>
<h2 id="constraint-kinds"><a class="header" href="#constraint-kinds">Constraint Kinds</a></h2>
<h3 id="required_component"><a class="header" href="#required_component"><code>required_component</code></a></h3>
<p>Ensures that entities matching the query have a specific component:</p>
<pre><code class="language-toml">[constraint.kind]
type = "required_component"
archetype = "door"
component = "transform"
</code></pre>
<p>Use case: every door must have a position in the world.</p>
<h3 id="required_child"><a class="header" href="#required_child"><code>required_child</code></a></h3>
<p>Ensures that entities have a child entity of a specific archetype:</p>
<pre><code class="language-toml">[constraint.kind]
type = "required_child"
archetype = "room"
child_archetype = "door"
</code></pre>
<p>Use case: every room must have at least one door.</p>
<h3 id="value_range"><a class="header" href="#value_range"><code>value_range</code></a></h3>
<p>Checks that a numeric field falls within a valid range:</p>
<pre><code class="language-toml">[constraint.kind]
type = "value_range"
field = "door.open_angle"
min = 0.0
max = 180.0
</code></pre>
<p>Use case: door angles must be physically possible.</p>
<h3 id="reference_valid"><a class="header" href="#reference_valid"><code>reference_valid</code></a></h3>
<p>Checks that an entity reference field points to an existing entity:</p>
<pre><code class="language-toml">[constraint.kind]
type = "reference_valid"
field = "door.target_room"
</code></pre>
<p>Use case: a door’s target room must actually exist in the scene.</p>
<h3 id="query_rule"><a class="header" href="#query_rule"><code>query_rule</code></a></h3>
<p>The most flexible kind — validates that a query returns the expected number of results:</p>
<pre><code class="language-toml">[constraint.kind]
type = "query_rule"
rule_query = "entities where archetype == 'player'"
expected = "exactly_one"
</code></pre>
<p>Use case: a playable scene must have exactly one player entity.</p>
<h2 id="auto-fix-strategies"><a class="header" href="#auto-fix-strategies">Auto-Fix Strategies</a></h2>
<p>Some constraint violations can be fixed automatically. The <code>fix</code> section defines how:</p>
<ul>
<li><strong>set_default</strong> — set a missing field to its schema default</li>
<li><strong>add_child</strong> — create a child entity with the required archetype</li>
<li><strong>remove_invalid</strong> — remove entities that violate the constraint</li>
<li><strong>assign_from_parent</strong> — copy a field value from the parent entity</li>
</ul>
<p>Auto-fix runs in a loop: fix violations, re-validate, fix new violations. Cycle detection prevents infinite loops.</p>
<h2 id="cli-usage-1"><a class="header" href="#cli-usage-1">CLI Usage</a></h2>
<pre><code class="language-bash"># Check a scene for violations
flint validate levels/tavern.scene.toml

# JSON output for parsing
flint validate levels/tavern.scene.toml --format json

# Preview what auto-fix would change
flint validate levels/tavern.scene.toml --fix --dry-run

# Apply auto-fixes
flint validate levels/tavern.scene.toml --fix

# Specify a schemas directory
flint validate levels/tavern.scene.toml --schemas schemas
</code></pre>
<p>The exit code is 0 if all constraints pass, 1 if any errors are found. Warnings do not affect the exit code.</p>
<h2 id="real-example"><a class="header" href="#real-example">Real Example</a></h2>
<p>From <code>schemas/constraints/basics.toml</code>:</p>
<pre><code class="language-toml">[[constraint]]
name = "doors_have_transform"
description = "Every door must have a transform component"
query = "entities where archetype == 'door'"
severity = "error"
message = "Door '{name}' is missing a transform component"

[constraint.kind]
type = "required_component"
archetype = "door"
component = "transform"

[[constraint]]
name = "rooms_have_bounds"
description = "Every room must have a bounds component"
query = "entities where archetype == 'room'"
severity = "error"
message = "Room '{name}' is missing a bounds component"

[constraint.kind]
type = "required_component"
archetype = "room"
component = "bounds"

[[constraint]]
name = "door_angle_range"
description = "Door open angle must be between 0 and 180 degrees"
query = "entities where archetype == 'door'"
severity = "warning"
message = "Door '{name}' has an open_angle outside the valid range"

[constraint.kind]
type = "value_range"
field = "door.open_angle"
min = 0.0
max = 180.0
</code></pre>
<h2 id="further-reading-7"><a class="header" href="#further-reading-7">Further Reading</a></h2>
<ul>
<li><a href="#writing-constraints">Writing Constraints</a> — practical guide to authoring rules</li>
<li><a href="#queries">Queries</a> — the query language used in constraint selectors</li>
<li><a href="#file-formats">File Formats</a> — constraint file format reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="assets"><a class="header" href="#assets">Assets</a></h1>
<p>Flint uses a content-addressed asset system with SHA-256 hashing. Every imported file is identified by its content hash, which means identical files are automatically deduplicated and any change to a file produces a new, distinct hash.</p>
<h2 id="content-addressing"><a class="header" href="#content-addressing">Content Addressing</a></h2>
<p>When you import a file, Flint computes its SHA-256 hash and stores it under a content-addressed path:</p>
<pre><code>.flint/assets/&lt;first-2-hex&gt;/&lt;full-hash&gt;.&lt;ext&gt;
</code></pre>
<p>This means:</p>
<ul>
<li><strong>Deduplication</strong> — importing the same file twice stores it only once</li>
<li><strong>Change detection</strong> — if a source file changes, its hash changes, and the new version is stored separately</li>
<li><strong>Integrity</strong> — the hash verifies the file hasn’t been corrupted</li>
</ul>
<h2 id="asset-catalog"><a class="header" href="#asset-catalog">Asset Catalog</a></h2>
<p>The asset catalog is a searchable index of all imported assets. Each entry tracks:</p>
<ul>
<li><strong>Name</strong> — a human-friendly identifier (e.g., <code>tavern_chair</code>)</li>
<li><strong>Hash</strong> — the SHA-256 content hash</li>
<li><strong>Type</strong> — asset type (<code>mesh</code>, <code>texture</code>, <code>material</code>, etc.)</li>
<li><strong>Tags</strong> — arbitrary labels for organization and filtering</li>
<li><strong>Source path</strong> — where the file was originally imported from</li>
</ul>
<h2 id="importing-assets"><a class="header" href="#importing-assets">Importing Assets</a></h2>
<p>Use the CLI to import files into the asset store:</p>
<pre><code class="language-bash"># Import a glTF model with name and tags
flint asset import models/chair.glb --name tavern_chair --tags furniture,medieval

# Browse the catalog
flint asset list --type mesh

# Check asset references in a scene
flint asset resolve levels/tavern.scene.toml --strategy strict
</code></pre>
<h2 id="gltfglb-import"><a class="header" href="#gltfglb-import">glTF/GLB Import</a></h2>
<p>The <code>flint-import</code> crate provides full glTF/GLB support, extracting:</p>
<ul>
<li><strong>Meshes</strong> — vertex positions, normals, texture coordinates, and indices</li>
<li><strong>Materials</strong> — PBR properties (base color, roughness, metallic, emissive)</li>
<li><strong>Textures</strong> — embedded or referenced image files</li>
</ul>
<p>Imported meshes are rendered by <code>flint-render</code> with full PBR shading.</p>
<h2 id="resolution-strategies"><a class="header" href="#resolution-strategies">Resolution Strategies</a></h2>
<p>When a scene references assets, Flint can resolve them using different strategies:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Strategy</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>strict</code></td><td>All referenced assets must exist in the catalog. Missing assets are errors.</td></tr>
<tr><td><code>placeholder</code></td><td>Missing assets are replaced with placeholder geometry. Useful during development.</td></tr>
<tr><td><code>ai_generate</code></td><td>Missing assets are generated via AI providers (Flux, Meshy, ElevenLabs) and stored.</td></tr>
<tr><td><code>human_task</code></td><td>Missing assets produce task files for manual creation by an artist.</td></tr>
<tr><td><code>ai_then_human</code></td><td>Generate with AI first, then produce review tasks for human approval.</td></tr>
</tbody>
</table>
</div>
<p>The <code>ai_generate</code>, <code>human_task</code>, and <code>ai_then_human</code> strategies are part of the <a href="#ai-asset-generation-1">AI Asset Generation</a> pipeline.</p>
<h2 id="asset-sidecar-files"><a class="header" href="#asset-sidecar-files">Asset Sidecar Files</a></h2>
<p>Each asset in the catalog has a <code>.asset.toml</code> sidecar file storing metadata:</p>
<pre><code class="language-toml">[asset]
name = "tavern_chair"
type = "mesh"
hash = "sha256:a1b2c3..."
source_path = "models/chair.glb"
tags = ["furniture", "medieval"]
</code></pre>
<h2 id="runtime-catalog-resolution"><a class="header" href="#runtime-catalog-resolution">Runtime Catalog Resolution</a></h2>
<p>The player can load the asset catalog at startup for name-based asset resolution. When an entity references an asset by name, the resolution chain is:</p>
<ol>
<li>Look up the name in the <code>AssetCatalog</code></li>
<li>If found, resolve the content hash</li>
<li>Load from the <code>ContentStore</code> path (<code>.flint/assets/&lt;hash&gt;</code>)</li>
<li>Fall back to file-based loading if not in the catalog</li>
</ol>
<p>This allows scenes to reference both pre-imported and AI-generated assets by name without hardcoding file paths.</p>
<h2 id="further-reading-8"><a class="header" href="#further-reading-8">Further Reading</a></h2>
<ul>
<li><a href="#importing-assets-1">Importing Assets</a> — step-by-step import guide</li>
<li><a href="#ai-asset-generation-1">AI Asset Generation</a> — AI-powered asset creation pipeline</li>
<li><a href="#schemas">Schemas</a> — the <code>material</code> component schema for PBR properties</li>
<li><a href="#file-formats">File Formats</a> — asset sidecar TOML format reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rendering"><a class="header" href="#rendering">Rendering</a></h1>
<p>Flint uses wgpu 23 for cross-platform GPU rendering, providing physically-based rendering (PBR) with a Cook-Torrance BRDF, cascaded shadow mapping, and full glTF mesh support.</p>
<h2 id="pbr-shading"><a class="header" href="#pbr-shading">PBR Shading</a></h2>
<p>The renderer implements a metallic-roughness PBR workflow based on the Cook-Torrance specular BRDF:</p>
<ul>
<li><strong>Base color</strong> — the surface albedo, optionally sampled from a texture</li>
<li><strong>Roughness</strong> — controls specular highlight spread (0.0 = mirror, 1.0 = diffuse)</li>
<li><strong>Metallic</strong> — interpolates between dielectric and metallic response</li>
<li><strong>Emissive</strong> — self-illumination for light sources and glowing objects</li>
</ul>
<p>Materials are defined in scene TOML via the <code>material</code> component, matching the fields in <code>schemas/components/material.toml</code>.</p>
<h2 id="shadow-mapping"><a class="header" href="#shadow-mapping">Shadow Mapping</a></h2>
<p>Directional lights cast shadows via cascaded shadow maps. Multiple shadow cascades cover different distance ranges from the camera, giving high-resolution shadows close up and broader coverage at distance.</p>
<p>Toggle shadows at runtime with <strong>F4</strong>.</p>
<h2 id="camera-modes"><a class="header" href="#camera-modes">Camera Modes</a></h2>
<p>The renderer supports two camera modes that share the same view/projection math:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Usage</th><th>Controls</th></tr>
</thead>
<tbody>
<tr><td><strong>Orbit</strong></td><td>Scene viewer (<code>serve</code>)</td><td>Left-drag to orbit, right-drag to pan, scroll to zoom</td></tr>
<tr><td><strong>First-person</strong></td><td>Player (<code>play</code>)</td><td>WASD to move, mouse to look, Space to jump, Shift to sprint</td></tr>
</tbody>
</table>
</div>
<p>The camera mode is determined by the entry point: <code>serve</code> uses orbit, <code>play</code> uses first-person. Both produce the same view and projection matrices.</p>
<h2 id="gltf-mesh-rendering"><a class="header" href="#gltf-mesh-rendering">glTF Mesh Rendering</a></h2>
<p>Imported glTF models are rendered with their full mesh geometry and materials. The <code>flint-import</code> crate extracts meshes, materials, and textures from <code>.glb</code>/<code>.gltf</code> files, which the renderer draws with PBR shading.</p>
<h2 id="skinned-mesh-pipeline"><a class="header" href="#skinned-mesh-pipeline">Skinned Mesh Pipeline</a></h2>
<p>For skeletal animation, the renderer provides a separate GPU pipeline that applies bone matrix skinning in the vertex shader. This avoids the 32-byte overhead of bone data on static geometry.</p>
<p><strong>How it works:</strong></p>
<ol>
<li><code>flint-import</code> extracts joint indices and weights from glTF skins alongside the mesh data</li>
<li><code>flint-animation</code> evaluates keyframes and computes bone matrices each frame (local pose -&gt; global hierarchy -&gt; inverse bind matrix)</li>
<li>The renderer uploads bone matrices to a storage buffer and applies them in the vertex shader</li>
</ol>
<p><strong>Key types:</strong></p>
<ul>
<li><code>SkinnedVertex</code> — extends the standard vertex with <code>joint_indices: [u32; 4]</code> and <code>joint_weights: [f32; 4]</code> (6 attributes total vs. 4 for static geometry)</li>
<li><code>GpuSkinnedMesh</code> — holds the vertex/index buffers, material, and a bone matrix storage buffer with its bind group</li>
<li>Skinned pipeline uses bind groups 0–3: transform, material, lights, and bones (storage buffer, read-only, vertex-visible)</li>
</ul>
<p>Skinned meshes also cast shadows through a dedicated <code>vs_skinned_shadow</code> shader entry point that applies bone transforms before depth rendering.</p>
<h2 id="viewer-vs-headless"><a class="header" href="#viewer-vs-headless">Viewer vs Headless</a></h2>
<p>The renderer operates in two modes:</p>
<p><strong>Viewer mode</strong> (<code>flint serve --watch</code>) opens an interactive window with:</p>
<ul>
<li>Real-time PBR rendering</li>
<li>egui inspector panel (entity tree, component editor, constraint overlay)</li>
<li>Hot-reload: edit the scene TOML and the viewer updates automatically</li>
<li>Debug rendering modes (cycle with <strong>F1</strong>)</li>
</ul>
<p><strong>Headless mode</strong> (<code>flint render</code>) renders to a PNG file without opening a window — useful for CI pipelines and automated screenshots:</p>
<pre><code class="language-bash">flint render levels/tavern.scene.toml --output preview.png --width 1920 --height 1080
</code></pre>
<h2 id="technology"><a class="header" href="#technology">Technology</a></h2>
<p>The rendering stack uses winit 0.30’s <code>ApplicationHandler</code> trait pattern (not the older event-loop closure style). wgpu 23 provides the GPU abstraction, selecting the best available backend (Vulkan, Metal, or DX12) at runtime.</p>
<h2 id="further-reading-9"><a class="header" href="#further-reading-9">Further Reading</a></h2>
<ul>
<li><a href="#the-scene-viewer">The Scene Viewer</a> — getting started with the viewer</li>
<li><a href="#animation">Animation</a> — the animation system that drives skinned meshes</li>
<li><a href="#physics-and-runtime">Physics and Runtime</a> — the game loop and first-person gameplay</li>
<li><a href="#headless-rendering-2">Headless Rendering</a> — CI integration guide</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="audio"><a class="header" href="#audio">Audio</a></h1>
<p>Flint’s audio system provides spatial 3D sound via the <code>flint-audio</code> crate, built on <a href="https://github.com/tesselode/kira">Kira</a> 0.11. Sounds can be positioned in 3D space with distance attenuation, played as ambient loops, or triggered by game events like collisions.</p>
<h2 id="spatial-audio"><a class="header" href="#spatial-audio">Spatial Audio</a></h2>
<p>Spatial sounds are attached to entities via the <code>audio_source</code> component. The sound’s volume attenuates with distance from the listener (the player camera):</p>
<ul>
<li><strong>min_distance</strong> — full volume within this radius</li>
<li><strong>max_distance</strong> — silence beyond this radius</li>
<li>Volume falls off smoothly between the two</li>
</ul>
<p>The listener position and orientation are updated each frame to match the first-person camera, so sounds pan and attenuate as you move through the scene.</p>
<h2 id="ambient-loops"><a class="header" href="#ambient-loops">Ambient Loops</a></h2>
<p>Non-spatial sounds play on the main audio track at constant volume regardless of listener position. Set <code>spatial = false</code> on an <code>audio_source</code> to use this mode — useful for background music, ambient atmosphere, and UI sounds.</p>
<h2 id="audio-schemas"><a class="header" href="#audio-schemas">Audio Schemas</a></h2>
<p>Three component schemas define audio behavior:</p>
<p><strong>audio_source</strong> (<code>audio_source.toml</code>) — a sound attached to an entity:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>file</code></td><td>string</td><td></td><td>Path to audio file (relative to scene directory)</td></tr>
<tr><td><code>volume</code></td><td>f32</td><td>1.0</td><td>Playback volume (0.0–2.0)</td></tr>
<tr><td><code>pitch</code></td><td>f32</td><td>1.0</td><td>Playback speed/pitch (0.1–4.0)</td></tr>
<tr><td><code>loop</code></td><td>bool</td><td>false</td><td>Loop the sound continuously</td></tr>
<tr><td><code>spatial</code></td><td>bool</td><td>true</td><td>3D positioned (uses entity transform)</td></tr>
<tr><td><code>min_distance</code></td><td>f32</td><td>1.0</td><td>Distance at full volume</td></tr>
<tr><td><code>max_distance</code></td><td>f32</td><td>25.0</td><td>Distance at silence</td></tr>
<tr><td><code>autoplay</code></td><td>bool</td><td>true</td><td>Start playing on scene load</td></tr>
</tbody>
</table>
</div>
<p><strong>audio_listener</strong> (<code>audio_listener.toml</code>) — marks which entity receives audio:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>active</code></td><td>bool</td><td>true</td><td>Whether this listener is active</td></tr>
</tbody>
</table>
</div>
<p><strong>audio_trigger</strong> (<code>audio_trigger.toml</code>) — event-driven sounds:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>on_collision</code></td><td>string</td><td></td><td>Sound to play on collision start</td></tr>
<tr><td><code>on_interact</code></td><td>string</td><td></td><td>Sound to play on player interaction</td></tr>
<tr><td><code>on_enter</code></td><td>string</td><td></td><td>Sound when entering a trigger volume</td></tr>
<tr><td><code>on_exit</code></td><td>string</td><td></td><td>Sound when exiting a trigger volume</td></tr>
</tbody>
</table>
</div>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The audio system has three main components:</p>
<ul>
<li><strong>AudioEngine</strong> — wraps Kira’s <code>AudioManager</code>, handles sound file loading, listener positioning, and spatial track creation. Sounds route through spatial tracks for 3D positioning or the main track for ambient playback.</li>
<li><strong>AudioSync</strong> — bridges TOML <code>audio_source</code> components to Kira spatial tracks. Discovers new audio entities each frame and updates spatial positions from entity transforms.</li>
<li><strong>AudioTrigger</strong> — maps game events (collisions, interactions) to <code>AudioCommand</code>s that play sounds at specific positions.</li>
</ul>
<p>The system implements the <code>RuntimeSystem</code> trait, ticking in the <code>update()</code> phase of the game loop (not <code>fixed_update()</code>, since audio doesn’t need fixed-timestep processing).</p>
<h2 id="graceful-degradation"><a class="header" href="#graceful-degradation">Graceful Degradation</a></h2>
<p><code>AudioManager::new()</code> can fail on headless machines or CI environments without an audio device. The engine wraps the manager in <code>Option</code> and silently skips audio operations when unavailable. This means scenes with audio components work correctly in all environments — you just won’t hear anything.</p>
<h2 id="adding-audio-to-a-scene"><a class="header" href="#adding-audio-to-a-scene">Adding Audio to a Scene</a></h2>
<pre><code class="language-toml"># A crackling fire with spatial falloff
[entities.fireplace]
archetype = "furniture"

[entities.fireplace.transform]
position = [5.0, 0.5, 3.0]

[entities.fireplace.audio_source]
file = "audio/fire_crackle.ogg"
volume = 0.8
loop = true
spatial = true
min_distance = 1.0
max_distance = 15.0

# Background tavern ambience (non-spatial)
[entities.ambience]

[entities.ambience.audio_source]
file = "audio/tavern_ambient.ogg"
volume = 0.3
loop = true
spatial = false
</code></pre>
<p>Supported audio formats: OGG, WAV, MP3, FLAC (via Kira’s symphonia backend).</p>
<h2 id="scripting-integration"><a class="header" href="#scripting-integration">Scripting Integration</a></h2>
<p>Audio can be controlled from <a href="#scripting">Rhai scripts</a> using deferred commands. The script API produces <code>ScriptCommand</code> values that the player processes after the script update phase:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>play_sound(name)</code></td><td>Play a non-spatial sound by filename (without extension)</td></tr>
<tr><td><code>play_sound_at(name, x, y, z, volume)</code></td><td>Play a spatial sound at a 3D position</td></tr>
<tr><td><code>stop_sound(name)</code></td><td>Stop a playing sound</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In a Rhai script:
fn on_interact() {
    play_sound("door_open");                          // Non-spatial
    play_sound_at("glass_clink", 5.0, 1.0, 3.0, 0.8); // Spatial at position
}
<span class="boring">}</span></code></pre>
<p>Sound names match files in the <code>audio/</code> directory. All <code>.ogg</code>, <code>.wav</code>, <code>.mp3</code>, and <code>.flac</code> files are automatically loaded at startup.</p>
<h2 id="further-reading-10"><a class="header" href="#further-reading-10">Further Reading</a></h2>
<ul>
<li><a href="#scripting">Scripting</a> — full scripting API including audio functions</li>
<li><a href="#animation">Animation</a> — animation system that can trigger audio events</li>
<li><a href="#physics-and-runtime">Physics and Runtime</a> — the game loop and event bus that drives audio triggers</li>
<li><a href="#schemas">Schemas</a> — component and archetype definitions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="animation"><a class="header" href="#animation">Animation</a></h1>
<p>Flint’s animation system provides two tiers of animation through the <code>flint-animation</code> crate: <strong>property tweens</strong> for simple transform animations defined in TOML, and <strong>skeletal animation</strong> for character rigs imported from glTF files with GPU vertex skinning.</p>
<h2 id="tier-1-property-animation"><a class="header" href="#tier-1-property-animation">Tier 1: Property Animation</a></h2>
<p>Property animations are the simplest form — animate any transform property (position, rotation, scale) or custom float field over time using keyframes. No 3D modeling tool required; clips are defined entirely in TOML.</p>
<h3 id="animation-clips"><a class="header" href="#animation-clips">Animation Clips</a></h3>
<p>Clips are <code>.anim.toml</code> files stored in the <code>demo/animations/</code> directory:</p>
<pre><code class="language-toml"># animations/door_swing.anim.toml
name = "door_swing"
duration = 0.8

[[tracks]]
interpolation = "Linear"

[tracks.target]
type = "Rotation"

[[tracks.keyframes]]
time = 0.0
value = [0.0, 0.0, 0.0]

[[tracks.keyframes]]
time = 0.8
value = [0.0, 90.0, 0.0]

[[events]]
time = 0.0
event_name = "door_creak"
</code></pre>
<h3 id="interpolation-modes"><a class="header" href="#interpolation-modes">Interpolation Modes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><strong>Step</strong></td><td>Jumps instantly to the next keyframe value</td></tr>
<tr><td><strong>Linear</strong></td><td>Linearly interpolates between keyframes</td></tr>
<tr><td><strong>CubicSpline</strong></td><td>Smooth interpolation with in/out tangents (matches glTF spec)</td></tr>
</tbody>
</table>
</div>
<h3 id="track-targets"><a class="header" href="#track-targets">Track Targets</a></h3>
<p>Each track animates a specific property:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Position</code></td><td>Entity position <code>[x, y, z]</code></td></tr>
<tr><td><code>Rotation</code></td><td>Entity rotation in euler degrees <code>[x, y, z]</code></td></tr>
<tr><td><code>Scale</code></td><td>Entity scale <code>[x, y, z]</code></td></tr>
<tr><td><code>CustomFloat</code></td><td>Any numeric component field (specify <code>component</code> and <code>field</code>)</td></tr>
</tbody>
</table>
</div>
<h3 id="animation-events"><a class="header" href="#animation-events">Animation Events</a></h3>
<p>Clips can fire game events at specific times — useful for triggering sounds (footstep at a specific frame), spawning particles, or notifying scripts. Events fire once per loop cycle.</p>
<h3 id="attaching-an-animation"><a class="header" href="#attaching-an-animation">Attaching an Animation</a></h3>
<p>Add an <code>animator</code> component to any entity in your scene:</p>
<pre><code class="language-toml">[entities.platform]
archetype = "furniture"

[entities.platform.transform]
position = [2.0, 0.5, 3.0]

[entities.platform.animator]
clip = "platform_bob"
autoplay = true
loop = true
speed = 1.0
</code></pre>
<p>The animation system scans for <code>.anim.toml</code> files at startup and matches clip names to <code>animator</code> components.</p>
<h2 id="tier-2-skeletal-animation"><a class="header" href="#tier-2-skeletal-animation">Tier 2: Skeletal Animation</a></h2>
<p>For characters and complex articulated meshes, skeletal animation imports bone hierarchies from glTF files and drives them with GPU vertex skinning.</p>
<h3 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h3>
<pre><code>glTF file (.glb)
  ├── Skin: joint hierarchy + inverse bind matrices
  ├── Mesh: positions, normals, UVs, joint_indices, joint_weights
  └── Animations: per-joint translation/rotation/scale channels
         │
         ▼
  ┌──────────────────────┐
  │   flint-import        │  Extract skeleton, clips, skinned vertices
  └──────────┬───────────┘
             │
  ┌──────────▼───────────┐
  │   flint-animation     │  Evaluate keyframes → bone matrices each frame
  └──────────┬───────────┘
             │
  ┌──────────▼───────────┐
  │   flint-render        │  Upload bone matrices → vertex shader skinning
  └──────────────────────┘
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Import</strong> — <code>flint-import</code> extracts the skeleton (joint hierarchy, inverse bind matrices) and animation clips (per-joint keyframe channels) from glTF files</li>
<li><strong>Evaluate</strong> — each frame, <code>flint-animation</code> samples the current clip time to produce local joint poses, walks the bone hierarchy to compute global transforms, and multiplies by inverse bind matrices to get final bone matrices</li>
<li><strong>Render</strong> — bone matrices are uploaded to a GPU storage buffer. The skinned vertex shader transforms each vertex by its weighted bone influences</li>
</ol>
<h3 id="skinned-vertices"><a class="header" href="#skinned-vertices">Skinned Vertices</a></h3>
<p>Skeletal meshes use a separate <code>SkinnedVertex</code> type with 6 attributes (vs. 4 for static geometry), avoiding 32 bytes of wasted bone data on every static vertex in the scene:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>position</code></td><td>vec3</td><td>Vertex position</td></tr>
<tr><td><code>normal</code></td><td>vec3</td><td>Vertex normal</td></tr>
<tr><td><code>color</code></td><td>vec4</td><td>Vertex color</td></tr>
<tr><td><code>uv</code></td><td>vec2</td><td>Texture coordinates</td></tr>
<tr><td><code>joint_indices</code></td><td>uvec4</td><td>Indices of 4 influencing bones</td></tr>
<tr><td><code>joint_weights</code></td><td>vec4</td><td>Weights for each bone (sum to 1.0)</td></tr>
</tbody>
</table>
</div>
<h3 id="crossfade-blending"><a class="header" href="#crossfade-blending">Crossfade Blending</a></h3>
<p>Smooth transitions between skeletal clips (e.g., idle to walk) use crossfade blending controlled by the <code>animator</code> component:</p>
<pre><code class="language-toml">[entities.character.animator]
clip = "idle"
playing = true
loop = true
blend_target = "walk"      # Crossfade into this clip
blend_duration = 0.3       # Over 0.3 seconds
</code></pre>
<p>Blending uses slerp for rotation quaternions and lerp for translation/scale, producing smooth pose interpolation.</p>
<h3 id="skeleton-schema"><a class="header" href="#skeleton-schema">Skeleton Schema</a></h3>
<p>The <code>skeleton</code> component references a glTF skin:</p>
<pre><code class="language-toml">[entities.character.skeleton]
skin = "Armature"           # Name of the glTF skin
</code></pre>
<p>Entities with both <code>animator</code> and <code>skeleton</code> components use the skeletal animation path. Entities with only <code>animator</code> use property tweens.</p>
<h2 id="animator-schema"><a class="header" href="#animator-schema">Animator Schema</a></h2>
<p>The <code>animator</code> component controls playback for both tiers:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>clip</code></td><td>string</td><td>“”</td><td>Current animation clip name</td></tr>
<tr><td><code>playing</code></td><td>bool</td><td>false</td><td>Whether the animation is playing</td></tr>
<tr><td><code>autoplay</code></td><td>bool</td><td>false</td><td>Start playing on scene load</td></tr>
<tr><td><code>loop</code></td><td>bool</td><td>true</td><td>Loop when the clip ends</td></tr>
<tr><td><code>speed</code></td><td>f32</td><td>1.0</td><td>Playback speed (-10.0 to 10.0)</td></tr>
<tr><td><code>blend_target</code></td><td>string</td><td>“”</td><td>Clip to crossfade into</td></tr>
<tr><td><code>blend_duration</code></td><td>f32</td><td>0.3</td><td>Crossfade duration in seconds</td></tr>
</tbody>
</table>
</div>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<ul>
<li><strong>AnimationPlayer</strong> — clip registry and per-entity playback state for property tweens</li>
<li><strong>AnimationSync</strong> — bridges ECS <code>animator</code> components to property animation playback, auto-discovers new entities each frame</li>
<li><strong>SkeletalSync</strong> — bridges ECS to skeletal animation, manages per-entity skeleton state and bone matrix computation</li>
<li><strong>AnimationSystem</strong> — top-level <code>RuntimeSystem</code> implementation that ticks both tiers</li>
</ul>
<p>Animation runs in <code>update()</code> (variable-rate), not <code>fixed_update()</code>, because smooth interpolation benefits from matching the rendering frame rate rather than the physics tick rate.</p>
<h2 id="scripting-integration-1"><a class="header" href="#scripting-integration-1">Scripting Integration</a></h2>
<p>Animations can be controlled from <a href="#scripting">Rhai scripts</a> by writing directly to the <code>animator</code> component. The <code>AnimationSync</code> system picks up changes on the next frame:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>play_clip(entity_id, clip_name)</code></td><td>Start playing a named animation clip</td></tr>
<tr><td><code>stop_clip(entity_id)</code></td><td>Stop the current animation</td></tr>
<tr><td><code>blend_to(entity_id, clip, duration)</code></td><td>Crossfade to another clip over the given duration</td></tr>
<tr><td><code>set_anim_speed(entity_id, speed)</code></td><td>Set animation playback speed</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In a Rhai script:
fn on_interact() {
    let me = self_entity();
    play_clip(me, "door_swing");
}

fn on_init() {
    let me = self_entity();
    blend_to(me, "idle", 0.3);  // Smooth transition to idle
}
<span class="boring">}</span></code></pre>
<h2 id="further-reading-11"><a class="header" href="#further-reading-11">Further Reading</a></h2>
<ul>
<li><a href="#scripting">Scripting</a> — full scripting API including animation functions</li>
<li><a href="#audio">Audio</a> — audio system that responds to animation events</li>
<li><a href="#rendering">Rendering</a> — the skinned mesh GPU pipeline</li>
<li><a href="#physics-and-runtime">Physics and Runtime</a> — the game loop that drives animation</li>
<li><a href="#file-formats">File Formats</a> — <code>.anim.toml</code> format reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="physics-and-runtime"><a class="header" href="#physics-and-runtime">Physics and Runtime</a></h1>
<p>Flint’s runtime layer transforms static scenes into interactive, playable experiences. The <code>flint-runtime</code> crate provides the game loop infrastructure, and <code>flint-physics</code> integrates the Rapier 3D physics engine for collision detection and character movement.</p>
<h2 id="the-game-loop"><a class="header" href="#the-game-loop">The Game Loop</a></h2>
<p>The game loop uses a <strong>fixed-timestep accumulator</strong> pattern. Physics simulation steps at a constant rate (1/60s by default) regardless of how fast or slow the rendering runs. This ensures deterministic behavior across different hardware.</p>
<p>The loop structure:</p>
<ol>
<li><strong>Tick the clock</strong> — advance time, accumulate delta into the physics budget</li>
<li><strong>Process input</strong> — read keyboard and mouse state into <code>InputState</code></li>
<li><strong>Fixed-step physics</strong> — while enough time has accumulated, step the physics simulation</li>
<li><strong>Character controller</strong> — apply player movement based on input and physics state</li>
<li><strong>Update audio</strong> — sync listener position to camera, process trigger events, update spatial tracks</li>
<li><strong>Advance animation</strong> — tick property tweens and skeletal playback, write updated transforms to ECS, upload bone matrices to GPU</li>
<li><strong>Run scripts</strong> — execute Rhai scripts (<code>on_update</code>, event callbacks), process deferred commands (audio, events)</li>
<li><strong>Render</strong> — draw the frame with the current entity positions, HUD overlay (crosshair, interaction prompts)</li>
</ol>
<p>The <code>RuntimeSystem</code> trait provides a standard interface for systems that plug into this loop. Physics, audio, animation, and scripting each implement <code>RuntimeSystem</code> with <code>initialize()</code>, <code>fixed_update()</code>, <code>update()</code>, and <code>shutdown()</code> methods.</p>
<h2 id="physics-with-rapier-3d"><a class="header" href="#physics-with-rapier-3d">Physics with Rapier 3D</a></h2>
<p>The <code>flint-physics</code> crate wraps Rapier 3D and bridges it to Flint’s TOML-based component system:</p>
<ul>
<li><strong>PhysicsWorld</strong> — manages Rapier’s rigid body set, collider set, and simulation pipeline</li>
<li><strong>PhysicsSync</strong> — reads <code>rigidbody</code> and <code>collider</code> components from entities and creates corresponding Rapier bodies. Static bodies for world geometry (walls, floors, furniture), kinematic bodies for the player.</li>
<li><strong>CharacterController</strong> — kinematic first-person movement with gravity, jumping, ground detection, and sprint</li>
</ul>
<h2 id="physics-schemas"><a class="header" href="#physics-schemas">Physics Schemas</a></h2>
<p>Three component schemas define physics properties:</p>
<p><strong>Rigidbody</strong> (<code>rigidbody.toml</code>) — determines how an entity participates in physics:</p>
<ul>
<li><code>body_type</code>: <code>"static"</code> (immovable world geometry), <code>"dynamic"</code> (simulated), or <code>"kinematic"</code> (script-controlled)</li>
<li><code>mass</code>, <code>gravity_scale</code></li>
</ul>
<p><strong>Collider</strong> (<code>collider.toml</code>) — defines the collision shape:</p>
<ul>
<li><code>shape</code>: <code>"box"</code>, <code>"sphere"</code>, or <code>"capsule"</code></li>
<li><code>size</code>: dimensions of the collision volume</li>
<li><code>friction</code>: surface friction coefficient</li>
</ul>
<p><strong>Character Controller</strong> (<code>character_controller.toml</code>) — first-person movement parameters:</p>
<ul>
<li><code>move_speed</code>, <code>jump_force</code>, <code>height</code>, <code>radius</code>, <code>camera_mode</code></li>
</ul>
<p>The <strong>player</strong> archetype (<code>player.toml</code>) bundles these together with a <code>transform</code> for a ready-to-use player entity.</p>
<h2 id="adding-physics-to-a-scene"><a class="header" href="#adding-physics-to-a-scene">Adding Physics to a Scene</a></h2>
<p>To make a scene playable, add physics components to entities:</p>
<pre><code class="language-toml"># The player entity
[entities.player]
archetype = "player"

[entities.player.transform]
position = [0, 1, 0]

[entities.player.character_controller]
move_speed = 6.0
jump_force = 7.0

# A wall with a static collider
[entities.north_wall]
archetype = "wall"

[entities.north_wall.transform]
position = [0, 2, -10]

[entities.north_wall.collider]
shape = "box"
size = [20, 4, 0.5]

[entities.north_wall.rigidbody]
body_type = "static"
</code></pre>
<p>Then play the scene:</p>
<pre><code class="language-bash">flint play my_scene.scene.toml
</code></pre>
<h2 id="input-system"><a class="header" href="#input-system">Input System</a></h2>
<p>The <code>InputState</code> struct tracks keyboard and mouse state each frame:</p>
<ul>
<li>Keyboard keys are tracked as pressed/released</li>
<li>Mouse provides raw delta movement (via <code>DeviceEvent::MouseMotion</code>) for smooth camera look</li>
<li>Action bindings map keys to game actions (move forward, jump, sprint, etc.)</li>
</ul>
<h2 id="further-reading-12"><a class="header" href="#further-reading-12">Further Reading</a></h2>
<ul>
<li><a href="#scripting">Scripting</a> — Rhai scripting system for game logic</li>
<li><a href="#audio">Audio</a> — spatial audio with Kira</li>
<li><a href="#animation">Animation</a> — property tweens and skeletal animation</li>
<li><a href="#rendering">Rendering</a> — the PBR rendering pipeline</li>
<li><a href="#schemas">Schemas</a> — component and archetype definitions including physics schemas</li>
<li><a href="#cli-reference">CLI Reference</a> — the <code>play</code> command and player binary</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="scripting"><a class="header" href="#scripting">Scripting</a></h1>
<p>Flint’s scripting system provides runtime game logic through <a href="https://rhai.rs/">Rhai</a>, a lightweight embedded scripting language. Scripts can read and write entity data, respond to game events, control animation and audio, and hot-reload while the game is running.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The <code>flint-script</code> crate integrates Rhai into the game loop:</p>
<ul>
<li><strong>ScriptEngine</strong> — compiles and runs <code>.rhai</code> scripts, manages per-entity state (scope, AST, callbacks)</li>
<li><strong>ScriptSync</strong> — discovers entities with <code>script</code> components, handles hot-reload by watching file timestamps</li>
<li><strong>ScriptSystem</strong> — implements <code>RuntimeSystem</code> for game loop integration, running in <code>update()</code> (variable-rate)</li>
</ul>
<p>Scripts run each frame during the <code>update()</code> phase, after physics and before rendering. This gives them access to the latest physics state while allowing their output to affect the current frame’s visuals.</p>
<h2 id="script-component"><a class="header" href="#script-component">Script Component</a></h2>
<p>Attach a script to any entity with the <code>script</code> component:</p>
<pre><code class="language-toml">[entities.my_door]
archetype = "door"

[entities.my_door.script]
source = "door_interact.rhai"
enabled = true
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>source</code></td><td>string</td><td><code>""</code></td><td>Path to <code>.rhai</code> file (relative to the <code>scripts/</code> directory)</td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td><code>true</code></td><td>Whether the script is active</td></tr>
</tbody>
</table>
</div>
<p>Script files live in the <code>scripts/</code> directory next to your scene file.</p>
<h2 id="event-callbacks"><a class="header" href="#event-callbacks">Event Callbacks</a></h2>
<p>Scripts define behavior through callback functions. The engine detects which callbacks are defined in each script’s AST and only calls those that exist:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Callback</th><th>Signature</th><th>When It Fires</th></tr>
</thead>
<tbody>
<tr><td><code>on_init</code></td><td><code>fn on_init()</code></td><td>Once when the script is first loaded</td></tr>
<tr><td><code>on_update</code></td><td><code>fn on_update(dt)</code></td><td>Every frame, with delta time in seconds</td></tr>
<tr><td><code>on_collision</code></td><td><code>fn on_collision(other_id)</code></td><td>When this entity collides with another</td></tr>
<tr><td><code>on_trigger_enter</code></td><td><code>fn on_trigger_enter(other_id)</code></td><td>When another entity enters a trigger volume</td></tr>
<tr><td><code>on_trigger_exit</code></td><td><code>fn on_trigger_exit(other_id)</code></td><td>When another entity exits a trigger volume</td></tr>
<tr><td><code>on_action</code></td><td><code>fn on_action(action_name)</code></td><td>When an input action fires (e.g., <code>"jump"</code>, <code>"interact"</code>)</td></tr>
<tr><td><code>on_interact</code></td><td><code>fn on_interact()</code></td><td>When the player presses Interact near this entity</td></tr>
</tbody>
</table>
</div>
<p>The <code>on_interact</code> callback is sugar for the common pattern of proximity-based interaction. It automatically checks the entity’s <code>interactable</code> component for <code>range</code> (default 3.0) and <code>enabled</code> (default true) before firing.</p>
<h2 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h2>
<p>All functions are available globally in every script. Entity IDs are passed as <code>i64</code> (Rhai’s native integer type).</p>
<h3 id="entity-api"><a class="header" href="#entity-api">Entity API</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Returns</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>self_entity()</code></td><td><code>i64</code></td><td>The entity ID of the entity this script is attached to</td></tr>
<tr><td><code>get_entity(name)</code></td><td><code>i64</code></td><td>Look up an entity by name. Returns <code>-1</code> if not found</td></tr>
<tr><td><code>entity_exists(id)</code></td><td><code>bool</code></td><td>Check whether an entity ID is valid</td></tr>
<tr><td><code>entity_name(id)</code></td><td><code>String</code></td><td>Get the name of an entity</td></tr>
<tr><td><code>has_component(id, component)</code></td><td><code>bool</code></td><td>Check if an entity has a specific component</td></tr>
<tr><td><code>get_field(id, component, field)</code></td><td><code>Dynamic</code></td><td>Read a component field value</td></tr>
<tr><td><code>set_field(id, component, field, value)</code></td><td>—</td><td>Write a component field value</td></tr>
<tr><td><code>get_position(id)</code></td><td><code>Map</code></td><td>Get entity position as <code>#{x, y, z}</code></td></tr>
<tr><td><code>set_position(id, x, y, z)</code></td><td>—</td><td>Set entity position</td></tr>
<tr><td><code>get_rotation(id)</code></td><td><code>Map</code></td><td>Get entity rotation (euler degrees) as <code>#{x, y, z}</code></td></tr>
<tr><td><code>set_rotation(id, x, y, z)</code></td><td>—</td><td>Set entity rotation (euler degrees)</td></tr>
<tr><td><code>distance(a, b)</code></td><td><code>f64</code></td><td>Euclidean distance between two entities</td></tr>
<tr><td><code>spawn_entity(name)</code></td><td><code>i64</code></td><td>Create a new entity. Returns its ID or <code>-1</code> on failure</td></tr>
<tr><td><code>despawn_entity(id)</code></td><td>—</td><td>Remove an entity from the world</td></tr>
</tbody>
</table>
</div>
<h3 id="input-api"><a class="header" href="#input-api">Input API</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Returns</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>is_action_pressed(action)</code></td><td><code>bool</code></td><td>Whether an action is currently held</td></tr>
<tr><td><code>is_action_just_pressed(action)</code></td><td><code>bool</code></td><td>Whether an action was pressed this frame</td></tr>
<tr><td><code>mouse_delta_x()</code></td><td><code>f64</code></td><td>Horizontal mouse movement this frame</td></tr>
<tr><td><code>mouse_delta_y()</code></td><td><code>f64</code></td><td>Vertical mouse movement this frame</td></tr>
</tbody>
</table>
</div>
<p>Available action names: <code>move_forward</code>, <code>move_backward</code>, <code>move_left</code>, <code>move_right</code>, <code>jump</code>, <code>interact</code>, <code>sprint</code>.</p>
<h3 id="time-api"><a class="header" href="#time-api">Time API</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Returns</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>delta_time()</code></td><td><code>f64</code></td><td>Seconds since last frame</td></tr>
<tr><td><code>total_time()</code></td><td><code>f64</code></td><td>Total elapsed time since scene start</td></tr>
</tbody>
</table>
</div>
<h3 id="audio-api"><a class="header" href="#audio-api">Audio API</a></h3>
<p>Audio functions produce deferred commands that the player processes after the script update phase:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>play_sound(name)</code></td><td>Play a non-spatial sound by filename</td></tr>
<tr><td><code>play_sound_at(name, x, y, z, volume)</code></td><td>Play a spatial sound at a 3D position</td></tr>
<tr><td><code>stop_sound(name)</code></td><td>Stop a playing sound</td></tr>
</tbody>
</table>
</div>
<p>Sound names match the audio files loaded from the <code>audio/</code> directory (without extension).</p>
<h3 id="animation-api"><a class="header" href="#animation-api">Animation API</a></h3>
<p>Animation functions write directly to the <code>animator</code> component on the target entity. The <code>AnimationSync</code> system picks up changes on the next frame:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>play_clip(entity_id, clip_name)</code></td><td>Start playing a named animation clip</td></tr>
<tr><td><code>stop_clip(entity_id)</code></td><td>Stop the current animation</td></tr>
<tr><td><code>blend_to(entity_id, clip, duration)</code></td><td>Crossfade to another clip over the given duration</td></tr>
<tr><td><code>set_anim_speed(entity_id, speed)</code></td><td>Set animation playback speed</td></tr>
</tbody>
</table>
</div>
<h3 id="math-api"><a class="header" href="#math-api">Math API</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Returns</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>clamp(val, min, max)</code></td><td><code>f64</code></td><td>Clamp a value to a range</td></tr>
<tr><td><code>lerp(a, b, t)</code></td><td><code>f64</code></td><td>Linear interpolation between <code>a</code> and <code>b</code></td></tr>
<tr><td><code>random()</code></td><td><code>f64</code></td><td>Random value in <code>[0, 1)</code></td></tr>
<tr><td><code>random_range(min, max)</code></td><td><code>f64</code></td><td>Random value in <code>[min, max)</code></td></tr>
<tr><td><code>sin(x)</code></td><td><code>f64</code></td><td>Sine</td></tr>
<tr><td><code>cos(x)</code></td><td><code>f64</code></td><td>Cosine</td></tr>
<tr><td><code>abs(x)</code></td><td><code>f64</code></td><td>Absolute value</td></tr>
<tr><td><code>sqrt(x)</code></td><td><code>f64</code></td><td>Square root</td></tr>
<tr><td><code>floor(x)</code></td><td><code>f64</code></td><td>Floor</td></tr>
<tr><td><code>ceil(x)</code></td><td><code>f64</code></td><td>Ceiling</td></tr>
<tr><td><code>min(a, b)</code></td><td><code>f64</code></td><td>Minimum of two values</td></tr>
<tr><td><code>max(a, b)</code></td><td><code>f64</code></td><td>Maximum of two values</td></tr>
<tr><td><code>atan2(y, x)</code></td><td><code>f64</code></td><td>Two-argument arctangent</td></tr>
</tbody>
</table>
</div>
<h3 id="event-api"><a class="header" href="#event-api">Event API</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>fire_event(name)</code></td><td>Fire a named game event</td></tr>
<tr><td><code>fire_event_data(name, data)</code></td><td>Fire an event with a data map payload</td></tr>
</tbody>
</table>
</div>
<h3 id="log-api"><a class="header" href="#log-api">Log API</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>log(msg)</code></td><td>Log an info-level message</td></tr>
<tr><td><code>log_warn(msg)</code></td><td>Log a warning</td></tr>
<tr><td><code>log_error(msg)</code></td><td>Log an error</td></tr>
</tbody>
</table>
</div>
<h2 id="hot-reload"><a class="header" href="#hot-reload">Hot-Reload</a></h2>
<p>The script system checks file modification timestamps each frame. When a <code>.rhai</code> file changes on disk:</p>
<ol>
<li>The file is recompiled to a new AST</li>
<li>If compilation succeeds, the old AST is replaced and the new version takes effect immediately</li>
<li>If compilation fails, the old AST is kept and an error is logged — the game never crashes from a script typo</li>
</ol>
<p>This enables a fast iteration workflow: edit a script in your text editor, save, and see the result in the running game without restarting.</p>
<h2 id="interactable-system"><a class="header" href="#interactable-system">Interactable System</a></h2>
<p>The <code>interactable</code> component marks entities that the player can interact with at close range. It works together with scripting to create interactive objects:</p>
<pre><code class="language-toml">[entities.tavern_door]
archetype = "door"

[entities.tavern_door.interactable]
prompt_text = "Open Door"
range = 3.0
interaction_type = "use"
enabled = true

[entities.tavern_door.script]
source = "door_interact.rhai"
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>prompt_text</code></td><td>string</td><td><code>"Interact"</code></td><td>Text shown on the HUD when in range</td></tr>
<tr><td><code>range</code></td><td>f32</td><td><code>3.0</code></td><td>Maximum interaction distance from the player</td></tr>
<tr><td><code>interaction_type</code></td><td>string</td><td><code>"use"</code></td><td>Type of interaction: <code>use</code>, <code>talk</code>, <code>examine</code></td></tr>
<tr><td><code>enabled</code></td><td>bool</td><td><code>true</code></td><td>Whether this interactable is currently active</td></tr>
</tbody>
</table>
</div>
<p>When the player is within <code>range</code> of an enabled interactable entity, the HUD displays a crosshair and the <code>prompt_text</code>. Pressing the Interact key (<code>E</code>) fires the <code>on_interact</code> callback on the entity’s script.</p>
<p>The <code>find_nearest_interactable()</code> function scans all interactable entities each frame to determine which (if any) to highlight. The HUD prompt fades in and out based on proximity.</p>
<h2 id="example-interactive-door"><a class="header" href="#example-interactive-door">Example: Interactive Door</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// scripts/door_interact.rhai

let door_open = false;

fn on_interact() {
    let me = self_entity();
    door_open = !door_open;

    if door_open {
        play_clip(me, "door_swing");
        play_sound("door_open");
        log("Door opened");
    } else {
        play_clip(me, "door_close");
        play_sound("door_close");
        log("Door closed");
    }
}
<span class="boring">}</span></code></pre>
<h2 id="example-flickering-torch"><a class="header" href="#example-flickering-torch">Example: Flickering Torch</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// scripts/torch_flicker.rhai

fn on_update(dt) {
    let me = self_entity();
    let t = total_time();

    // Flicker the emissive intensity with layered sine waves
    let flicker = 0.8 + 0.2 * sin(t * 8.0) * sin(t * 13.0 + 0.7);
    set_field(me, "material", "emissive_strength", clamp(flicker, 0.3, 1.0));
}
<span class="boring">}</span></code></pre>
<h2 id="example-npc-bartender"><a class="header" href="#example-npc-bartender">Example: NPC Bartender</a></h2>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// scripts/bartender.rhai

fn on_init() {
    let me = self_entity();
    play_clip(me, "idle");
    log("Bartender ready to serve");
}

fn on_interact() {
    let me = self_entity();
    let player = get_entity("player");
    let dist = distance(me, player);

    // Face the player
    let my_pos = get_position(me);
    let player_pos = get_position(player);
    let angle = atan2(player_pos.x - my_pos.x, player_pos.z - my_pos.z);
    set_rotation(me, 0.0, angle * 57.2958, 0.0);

    // React
    play_sound("glass_clink");
    blend_to(me, "wave", 0.3);
    log("Bartender waves at you");
}
<span class="boring">}</span></code></pre>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<pre><code>on_init ──► ScriptEngine.call_inits()
                │
                ▼
            per-entity Scope + AST
                │
                ▼
on_update ──► ScriptEngine.call_updates(dt)
                │
                ▼
events ────► ScriptEngine.process_events()
                │                    │
                ▼                    ▼
        ECS reads/writes      ScriptCommands
        (via ScriptCallContext)  (PlaySound, FireEvent, Log)
                                     │
                                     ▼
                              PlayerApp processes
                              deferred commands
</code></pre>
<p>Each entity gets its own Rhai <code>Scope</code>, preserving persistent variables between frames. The <code>Engine</code> is shared across all entities. World access happens through a <code>ScriptCallContext</code> that holds a raw pointer to the <code>FlintWorld</code> — valid only during the call batch, cleared immediately after.</p>
<h2 id="further-reading-13"><a class="header" href="#further-reading-13">Further Reading</a></h2>
<ul>
<li><a href="#audio">Audio</a> — sound system that scripts can control</li>
<li><a href="#animation">Animation</a> — animation system driven by script commands</li>
<li><a href="#physics-and-runtime">Physics and Runtime</a> — the game loop that calls scripts</li>
<li><a href="#building-a-tavern">Building a Tavern</a> — tutorial using scripts for interactive entities</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ai-asset-generation-1"><a class="header" href="#ai-asset-generation-1">AI Asset Generation</a></h1>
<p>Flint includes an integrated AI asset generation pipeline through the <code>flint-asset-gen</code> crate. The system connects to external AI services to produce textures, 3D models, and audio from text descriptions, while maintaining visual consistency through style guides and validating results against constraints.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The pipeline follows a request-enrich-generate-validate-catalog flow:</p>
<pre><code>Description + Style Guide
        │
        ▼
  Prompt Enrichment (palette, materials, constraints)
        │
        ▼
  GenerationProvider (Flux / Meshy / ElevenLabs / Mock)
        │
        ▼
  Post-generation Validation (geometry, materials)
        │
        ▼
  Content-Addressed Storage + Asset Catalog
</code></pre>
<h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<p>Flint uses a pluggable <code>GenerationProvider</code> trait. Each provider handles one or more asset types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Provider</th><th>Asset Types</th><th>Service</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>Flux</strong></td><td>Textures</td><td>Flux API</td><td>AI image generation for PBR textures</td></tr>
<tr><td><strong>Meshy</strong></td><td>3D Models</td><td>Meshy API</td><td>Text-to-3D model generation (GLB output)</td></tr>
<tr><td><strong>ElevenLabs</strong></td><td>Audio</td><td>ElevenLabs API</td><td>AI sound effect and voice generation</td></tr>
<tr><td><strong>Mock</strong></td><td>All</td><td>Local</td><td>Generates minimal valid files for testing without network access</td></tr>
</tbody>
</table>
</div>
<p>The <code>GenerationProvider</code> trait defines the interface:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait GenerationProvider: Send {
    fn name(&amp;self) -&gt; &amp;str;
    fn supported_kinds(&amp;self) -&gt; Vec&lt;AssetKind&gt;;
    fn health_check(&amp;self) -&gt; Result&lt;ProviderStatus&gt;;
    fn generate(&amp;self, request: &amp;GenerateRequest, style: Option&lt;&amp;StyleGuide&gt;, output_dir: &amp;Path) -&gt; Result&lt;GenerateResult&gt;;
    fn submit_job(&amp;self, request: &amp;GenerateRequest, style: Option&lt;&amp;StyleGuide&gt;) -&gt; Result&lt;GenerationJob&gt;;
    fn poll_job(&amp;self, job: &amp;GenerationJob) -&gt; Result&lt;JobPollResult&gt;;
    fn download_result(&amp;self, job: &amp;GenerationJob, output_dir: &amp;Path) -&gt; Result&lt;GenerateResult&gt;;
    fn build_prompt(&amp;self, request: &amp;GenerateRequest, style: Option&lt;&amp;StyleGuide&gt;) -&gt; String;
}
<span class="boring">}</span></code></pre>
<p>The Mock provider generates solid-color PNGs, minimal valid GLB files, and silence WAV files — useful for testing workflows and CI pipelines without API keys or network access.</p>
<h2 id="style-guides"><a class="header" href="#style-guides">Style Guides</a></h2>
<p>Style guides enforce visual consistency across generated assets. They are TOML files that define a palette, material constraints, geometry constraints, and prompt modifiers:</p>
<pre><code class="language-toml"># styles/medieval_tavern.style.toml
[style]
name = "medieval_tavern"
description = "Weathered medieval fantasy tavern"
prompt_prefix = "Medieval fantasy tavern style, low-fantasy realism"
prompt_suffix = "Photorealistic textures, warm candlelight tones"
negative_prompt = "modern, sci-fi, neon, plastic, chrome"
palette = ["#8B4513", "#A0522D", "#D4A574", "#4A4A4A", "#2F1B0E"]

[style.materials]
roughness_range = [0.6, 0.95]
metallic_range = [0.0, 0.15]
preferred_materials = ["aged oak wood", "rough-hewn stone", "hammered wrought iron"]

[style.geometry]
max_triangles = 5000
require_uvs = true
require_normals = true
</code></pre>
<p>When a style guide is active, the provider enriches the generation prompt by prepending the <code>prompt_prefix</code>, appending palette colors and material descriptors, and adding the <code>prompt_suffix</code>. The <code>negative_prompt</code> tells AI services what to avoid.</p>
<p>Style guides are searched in <code>styles/</code> then <code>.flint/styles/</code> by name (e.g., <code>medieval_tavern</code> finds <code>styles/medieval_tavern.style.toml</code>).</p>
<h2 id="semantic-asset-definitions"><a class="header" href="#semantic-asset-definitions">Semantic Asset Definitions</a></h2>
<p>The <code>asset_def</code> component describes what an entity <em>needs</em> in terms of assets, expressed as intent rather than file paths:</p>
<pre><code class="language-toml">[entities.tavern_wall]
archetype = "wall"

[entities.tavern_wall.asset_def]
name = "tavern_wall_texture"
description = "Rough stone wall with mortar lines, medieval tavern interior"
type = "texture"
material_intent = "rough stone"
wear_level = 0.7
tags = ["wall", "interior", "medieval"]
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td>string</td><td>Asset name identifier</td></tr>
<tr><td><code>description</code></td><td>string</td><td>What this asset is for (used as the generation prompt)</td></tr>
<tr><td><code>type</code></td><td>string</td><td>Asset type: <code>texture</code>, <code>model</code>, or <code>audio</code></td></tr>
<tr><td><code>material_intent</code></td><td>string</td><td>Material intent (e.g., “aged wood”, “rough stone”)</td></tr>
<tr><td><code>wear_level</code></td><td>f32</td><td>How worn/damaged (0.0 = pristine, 1.0 = heavily worn)</td></tr>
<tr><td><code>size_class</code></td><td>string</td><td>Size class: <code>small</code>, <code>medium</code>, <code>large</code>, <code>huge</code></td></tr>
<tr><td><code>tags</code></td><td>array</td><td>Tags for categorization</td></tr>
</tbody>
</table>
</div>
<p>These definitions let the batch resolver automatically generate all assets a scene needs.</p>
<h2 id="batch-resolution"><a class="header" href="#batch-resolution">Batch Resolution</a></h2>
<p>The <code>flint asset resolve</code> command can resolve an entire scene’s asset needs at once using different strategies:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Strategy</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>strict</code></td><td>All assets must already exist in the catalog. Missing assets are errors.</td></tr>
<tr><td><code>placeholder</code></td><td>Missing assets get placeholder geometry.</td></tr>
<tr><td><code>ai_generate</code></td><td>Missing assets are generated via AI providers and stored in the catalog.</td></tr>
<tr><td><code>human_task</code></td><td>Missing assets produce task files for manual creation.</td></tr>
<tr><td><code>ai_then_human</code></td><td>Generate with AI first, then produce review tasks for human approval.</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-bash"># Generate all missing assets for a scene using AI
flint asset resolve my_scene.scene.toml --strategy ai_generate --style medieval_tavern

# Create task files for a human artist
flint asset resolve my_scene.scene.toml --strategy human_task --output-dir tasks/
</code></pre>
<h2 id="model-validation"><a class="header" href="#model-validation">Model Validation</a></h2>
<p>After generating a 3D model, Flint can validate it against a style guide’s constraints. The validator imports the GLB file through the same <code>import_gltf()</code> pipeline used by the player, then checks:</p>
<ul>
<li><strong>Triangle count</strong> against <code>geometry.max_triangles</code></li>
<li><strong>UV coordinates</strong> present if <code>geometry.require_uvs</code> is set</li>
<li><strong>Normals</strong> present if <code>geometry.require_normals</code> is set</li>
<li><strong>Material properties</strong> against <code>materials.roughness_range</code> and <code>materials.metallic_range</code></li>
</ul>
<pre><code class="language-bash">flint asset validate model.glb --style medieval_tavern
</code></pre>
<p>Each check reports Pass, Warn, or Fail status.</p>
<h2 id="build-manifests"><a class="header" href="#build-manifests">Build Manifests</a></h2>
<p>Build manifests track the provenance of all generated assets in a project. They record which provider generated each asset, what prompt was used, and the content hash:</p>
<pre><code class="language-bash">flint asset manifest --assets-dir assets --output build/manifest.toml
</code></pre>
<p>The manifest scans <code>.asset.toml</code> sidecar files for <code>provider</code> properties to identify which assets were AI-generated vs. manually created. This is useful for auditing, reproducing builds, and tracking which assets need regeneration when style guides change.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Flint uses a layered configuration system for API keys and provider settings:</p>
<p><strong>Global config</strong> (<code>~/.flint/config.toml</code>):</p>
<pre><code class="language-toml">[providers.flux]
api_key = "your-flux-key"
enabled = true

[providers.meshy]
api_key = "your-meshy-key"
enabled = true

[providers.elevenlabs]
api_key = "your-elevenlabs-key"
enabled = true

[generation]
default_style = "medieval_tavern"
</code></pre>
<p><strong>Project config</strong> (<code>.flint/config.toml</code>): overrides global settings for this project.</p>
<p><strong>Environment variables</strong>: override both config files:</p>
<ul>
<li><code>FLINT_FLUX_API_KEY</code></li>
<li><code>FLINT_MESHY_API_KEY</code></li>
<li><code>FLINT_ELEVENLABS_API_KEY</code></li>
</ul>
<p>The layering order is: global config &lt; project config &lt; environment variables.</p>
<h2 id="cli-commands"><a class="header" href="#cli-commands">CLI Commands</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>flint asset generate &lt;type&gt; -d "&lt;prompt&gt;"</code></td><td>Generate a single asset</td></tr>
<tr><td><code>flint asset generate texture -d "stone wall" --style medieval_tavern</code></td><td>Generate with style guide</td></tr>
<tr><td><code>flint asset generate model -d "wooden chair" --provider meshy</code></td><td>Generate with specific provider</td></tr>
<tr><td><code>flint asset resolve &lt;scene&gt; --strategy ai_generate</code></td><td>Batch-generate all missing scene assets</td></tr>
<tr><td><code>flint asset validate &lt;file&gt; --style &lt;name&gt;</code></td><td>Validate a model against style constraints</td></tr>
<tr><td><code>flint asset manifest</code></td><td>Generate a build manifest of all generated assets</td></tr>
<tr><td><code>flint asset regenerate &lt;name&gt; --seed 42</code></td><td>Regenerate an existing asset with a new seed</td></tr>
<tr><td><code>flint asset job status &lt;id&gt;</code></td><td>Check status of an async generation job</td></tr>
<tr><td><code>flint asset job list</code></td><td>List all generation jobs</td></tr>
</tbody>
</table>
</div>
<h2 id="runtime-catalog-integration"><a class="header" href="#runtime-catalog-integration">Runtime Catalog Integration</a></h2>
<p>The player can optionally load the asset catalog at startup for runtime asset resolution. When an entity references an asset by name, the resolution chain is:</p>
<ol>
<li>Look up the name in the <code>AssetCatalog</code></li>
<li>If found, resolve the content hash</li>
<li>Load from the <code>ContentStore</code> path (<code>.flint/assets/&lt;hash&gt;</code>)</li>
<li>Fall back to file-based loading if not in the catalog</li>
</ol>
<p>This means scenes can seamlessly reference both pre-imported and AI-generated assets by name, without hardcoding file paths.</p>
<h2 id="further-reading-14"><a class="header" href="#further-reading-14">Further Reading</a></h2>
<ul>
<li><a href="#assets">Assets</a> — content-addressed storage and catalog system</li>
<li><a href="#file-formats">File Formats</a> — <code>.style.toml</code> and <code>asset_def.toml</code> format reference</li>
<li><a href="#cli-reference">CLI Reference</a> — full command documentation</li>
<li><a href="#ai-agent-workflow">AI Agent Workflow</a> — using AI generation in automated workflows</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="building-a-tavern"><a class="header" href="#building-a-tavern">Building a Tavern</a></h1>
<p>This tutorial walks through building a complete tavern scene from scratch using Flint’s CLI. By the end, you’ll have a walkable tavern with physics, audio, animation, scripted NPCs, and interactive objects.</p>
<h2 id="1-initialize-the-project"><a class="header" href="#1-initialize-the-project">1. Initialize the Project</a></h2>
<pre><code class="language-bash">flint init tavern-game
cd tavern-game
</code></pre>
<p>This creates a project directory with <code>schemas/</code> containing default component and archetype definitions.</p>
<h2 id="2-create-the-scene"><a class="header" href="#2-create-the-scene">2. Create the Scene</a></h2>
<pre><code class="language-bash">flint scene create levels/tavern.scene.toml --name "The Rusty Flagon"
</code></pre>
<h2 id="3-build-the-rooms"><a class="header" href="#3-build-the-rooms">3. Build the Rooms</a></h2>
<p>Create the tavern’s three rooms using parent-child hierarchy:</p>
<pre><code class="language-bash">SCENE="levels/tavern.scene.toml"

# Main hall
flint entity create --archetype room --name "main_hall" --scene $SCENE
flint entity create --archetype room --name "kitchen" --scene $SCENE
flint entity create --archetype room --name "storage" --scene $SCENE
</code></pre>
<p>Now edit the TOML directly to set positions and dimensions. Each room needs a transform and bounds:</p>
<pre><code class="language-toml">[entities.main_hall]
archetype = "room"

[entities.main_hall.transform]
position = [0.0, 0.0, 0.0]

[entities.main_hall.bounds]
size = [15.0, 4.0, 12.0]
</code></pre>
<h2 id="4-add-physics-colliders"><a class="header" href="#4-add-physics-colliders">4. Add Physics Colliders</a></h2>
<p>For the scene to be walkable, surfaces need physics colliders. Add walls, floor, and ceiling:</p>
<pre><code class="language-toml">[entities.floor]
archetype = "wall"

[entities.floor.transform]
position = [0.0, -0.25, 0.0]

[entities.floor.collider]
shape = "box"
size = [20.0, 0.5, 20.0]

[entities.floor.rigidbody]
body_type = "static"

[entities.north_wall]
archetype = "wall"

[entities.north_wall.transform]
position = [0.0, 2.0, -10.0]

[entities.north_wall.collider]
shape = "box"
size = [20.0, 4.0, 0.5]

[entities.north_wall.rigidbody]
body_type = "static"
</code></pre>
<p>Repeat for all walls. Static rigidbodies are immovable world geometry that the player collides with.</p>
<h2 id="5-create-the-player"><a class="header" href="#5-create-the-player">5. Create the Player</a></h2>
<p>The player entity bundles a character controller, transform, and audio listener:</p>
<pre><code class="language-toml">[entities.player]
archetype = "player"

[entities.player.transform]
position = [0.0, 1.0, 5.0]

[entities.player.character_controller]
move_speed = 6.0
jump_force = 7.0
height = 1.8
radius = 0.3
</code></pre>
<h2 id="6-add-furniture"><a class="header" href="#6-add-furniture">6. Add Furniture</a></h2>
<p>Place objects throughout the tavern:</p>
<pre><code class="language-toml">[entities.bar_counter]
archetype = "furniture"

[entities.bar_counter.transform]
position = [-3.0, 0.5, -2.0]
scale = [3.0, 1.0, 0.8]

[entities.bar_counter.collider]
shape = "box"
size = [3.0, 1.0, 0.8]

[entities.bar_counter.rigidbody]
body_type = "static"

[entities.fireplace]
archetype = "furniture"

[entities.fireplace.transform]
position = [5.0, 0.5, -8.0]

[entities.fireplace.material]
emissive = [1.0, 0.4, 0.1]
emissive_strength = 2.0
</code></pre>
<h2 id="7-add-audio"><a class="header" href="#7-add-audio">7. Add Audio</a></h2>
<p>Attach spatial sounds to entities:</p>
<pre><code class="language-toml">[entities.fireplace.audio_source]
file = "audio/fire_crackle.ogg"
volume = 0.8
loop = true
spatial = true
min_distance = 1.0
max_distance = 15.0

[entities.ambience]

[entities.ambience.audio_source]
file = "audio/tavern_ambient.ogg"
volume = 0.3
loop = true
spatial = false
</code></pre>
<p>Place audio files (OGG, WAV, MP3, or FLAC) in the <code>audio/</code> directory next to the scene.</p>
<h2 id="8-add-animations"><a class="header" href="#8-add-animations">8. Add Animations</a></h2>
<p>Create animation clips in <code>animations/</code>:</p>
<pre><code class="language-toml"># animations/platform_bob.anim.toml
name = "platform_bob"
duration = 4.0

[[tracks]]
interpolation = "CubicSpline"

[tracks.target]
type = "Position"

[[tracks.keyframes]]
time = 0.0
value = [2.0, 0.5, 3.0]

[[tracks.keyframes]]
time = 2.0
value = [2.0, 1.5, 3.0]

[[tracks.keyframes]]
time = 4.0
value = [2.0, 0.5, 3.0]
</code></pre>
<p>Attach an animator to the entity:</p>
<pre><code class="language-toml">[entities.platform.animator]
clip = "platform_bob"
autoplay = true
loop = true
speed = 1.0
</code></pre>
<h2 id="9-add-interactable-objects"><a class="header" href="#9-add-interactable-objects">9. Add Interactable Objects</a></h2>
<p>Make the door interactive with a script:</p>
<pre><code class="language-toml">[entities.front_door]
archetype = "door"

[entities.front_door.transform]
position = [0.0, 1.0, -5.0]

[entities.front_door.interactable]
prompt_text = "Open Door"
range = 3.0
interaction_type = "use"

[entities.front_door.script]
source = "door_interact.rhai"
</code></pre>
<p>Create the script in <code>scripts/door_interact.rhai</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let door_open = false;

fn on_interact() {
    let me = self_entity();
    door_open = !door_open;

    if door_open {
        play_clip(me, "door_swing");
        play_sound("door_open");
    } else {
        play_clip(me, "door_close");
        play_sound("door_close");
    }
}
<span class="boring">}</span></code></pre>
<h2 id="10-add-npcs"><a class="header" href="#10-add-npcs">10. Add NPCs</a></h2>
<p>Create NPC entities with scripts for behavior:</p>
<pre><code class="language-toml">[entities.bartender]
archetype = "npc"

[entities.bartender.transform]
position = [-3.0, 0.0, -3.0]

[entities.bartender.interactable]
prompt_text = "Talk to Bartender"
range = 3.0
interaction_type = "talk"

[entities.bartender.script]
source = "bartender.rhai"
</code></pre>
<h2 id="11-validate-and-test"><a class="header" href="#11-validate-and-test">11. Validate and Test</a></h2>
<pre><code class="language-bash"># Check the scene against constraints
flint validate levels/tavern.scene.toml

# View in the scene viewer with hot-reload
flint serve levels/tavern.scene.toml --watch

# Walk through the tavern in first person
flint play levels/tavern.scene.toml
</code></pre>
<h2 id="12-the-finished-result"><a class="header" href="#12-the-finished-result">12. The Finished Result</a></h2>
<p>The <code>demo/phase4_runtime.scene.toml</code> in the Flint repository is a complete implementation of this tavern, with:</p>
<ul>
<li>Three rooms (main hall, kitchen, storage) with physics colliders on all surfaces</li>
<li>A bar counter, tables, fireplace, and barrels</li>
<li>Four NPCs: bartender, two patrons, and a mysterious stranger with scripted behaviors</li>
<li>Spatial audio: fire crackle, ambient tavern noise, door sounds, glass clinks</li>
<li>Property animations: bobbing platform, door swings</li>
<li>Interactable doors and NPCs with HUD prompts</li>
<li>Footstep sounds synced to player movement</li>
</ul>
<pre><code class="language-bash"># Try the finished demo
cargo run --bin flint -- play demo/phase4_runtime.scene.toml
</code></pre>
<h2 id="further-reading-15"><a class="header" href="#further-reading-15">Further Reading</a></h2>
<ul>
<li><a href="#scripting">Scripting</a> — full Rhai API reference</li>
<li><a href="#audio">Audio</a> — spatial audio system</li>
<li><a href="#animation">Animation</a> — property tweens and skeletal animation</li>
<li><a href="#physics-and-runtime">Physics and Runtime</a> — game loop and character controller</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="writing-constraints"><a class="header" href="#writing-constraints">Writing Constraints</a></h1>
<p>This guide walks through authoring constraint rules for your Flint project. Constraints are declarative TOML rules that define what a valid scene looks like, checked by <code>flint validate</code>.</p>
<h2 id="anatomy-of-a-constraint-file"><a class="header" href="#anatomy-of-a-constraint-file">Anatomy of a Constraint File</a></h2>
<p>Constraint files live in <code>schemas/constraints/</code> and contain one or more <code>[[constraint]]</code> entries:</p>
<pre><code class="language-toml">[[constraint]]
name = "unique_identifier"
description = "Human-readable explanation"
query = "entities where &lt;condition&gt;"
severity = "error"
message = "Violation message for '{name}'"

[constraint.kind]
type = "&lt;kind&gt;"
# kind-specific fields...
</code></pre>
<ul>
<li><strong>name</strong> — unique identifier, used in logs and JSON output</li>
<li><strong>description</strong> — what the rule checks (for documentation)</li>
<li><strong>query</strong> — which entities this constraint applies to</li>
<li><strong>severity</strong> — <code>"error"</code> fails validation, <code>"warning"</code> is advisory</li>
<li><strong>message</strong> — shown when violated. <code>{name}</code> is replaced with the entity name</li>
</ul>
<h2 id="choosing-the-right-kind"><a class="header" href="#choosing-the-right-kind">Choosing the Right Kind</a></h2>
<h3 id="required_component--entity-x-must-have-component-y"><a class="header" href="#required_component--entity-x-must-have-component-y"><code>required_component</code> — “Entity X must have component Y”</a></h3>
<p>The most common kind. Use when an archetype needs a specific component:</p>
<pre><code class="language-toml">[[constraint]]
name = "doors_have_transform"
description = "Every door must have a transform"
query = "entities where archetype == 'door'"
severity = "error"
message = "Door '{name}' is missing a transform component"

[constraint.kind]
type = "required_component"
archetype = "door"
component = "transform"
</code></pre>
<h3 id="value_range--field-x-must-be-between-a-and-b"><a class="header" href="#value_range--field-x-must-be-between-a-and-b"><code>value_range</code> — “Field X must be between A and B”</a></h3>
<p>Validates that a numeric field is within bounds:</p>
<pre><code class="language-toml">[[constraint]]
name = "door_angle_range"
description = "Door open angle must be between 0 and 180"
query = "entities where archetype == 'door'"
severity = "warning"
message = "Door '{name}' has an invalid open_angle"

[constraint.kind]
type = "value_range"
field = "door.open_angle"
min = 0.0
max = 180.0
</code></pre>
<h3 id="required_child--entity-x-must-have-a-child-of-archetype-y"><a class="header" href="#required_child--entity-x-must-have-a-child-of-archetype-y"><code>required_child</code> — “Entity X must have a child of archetype Y”</a></h3>
<p>Enforces parent-child relationships:</p>
<pre><code class="language-toml">[[constraint]]
name = "rooms_have_door"
description = "Every room needs at least one exit"
query = "entities where archetype == 'room'"
severity = "error"
message = "Room '{name}' has no door"

[constraint.kind]
type = "required_child"
archetype = "room"
child_archetype = "door"
</code></pre>
<h3 id="reference_valid--this-reference-field-must-point-to-an-existing-entity"><a class="header" href="#reference_valid--this-reference-field-must-point-to-an-existing-entity"><code>reference_valid</code> — “This reference field must point to an existing entity”</a></h3>
<p>Checks referential integrity:</p>
<pre><code class="language-toml">[[constraint]]
name = "door_target_exists"
description = "Door target room must exist"
query = "entities where archetype == 'door'"
severity = "error"
message = "Door '{name}' references a non-existent target"

[constraint.kind]
type = "reference_valid"
field = "door.target_room"
</code></pre>
<h3 id="query_rule--this-query-must-return-the-expected-count"><a class="header" href="#query_rule--this-query-must-return-the-expected-count"><code>query_rule</code> — “This query must return the expected count”</a></h3>
<p>The most flexible kind, for arbitrary rules:</p>
<pre><code class="language-toml">[[constraint]]
name = "one_player"
description = "Playable scenes need exactly one player"
query = "entities where archetype == 'player'"
severity = "error"
message = "Scene must have exactly one player entity"

[constraint.kind]
type = "query_rule"
rule_query = "entities where archetype == 'player'"
expected = "exactly_one"
</code></pre>
<h2 id="auto-fix-strategies-1"><a class="header" href="#auto-fix-strategies-1">Auto-Fix Strategies</a></h2>
<p>Add a <code>[constraint.fix]</code> section to enable automatic repair:</p>
<pre><code class="language-toml">[[constraint]]
name = "rooms_have_bounds"
query = "entities where archetype == 'room'"
severity = "error"
message = "Room '{name}' needs bounds"

[constraint.kind]
type = "required_component"
archetype = "room"
component = "bounds"

[constraint.fix]
strategy = "set_default"
</code></pre>
<p>Available strategies:</p>
<ul>
<li><strong>set_default</strong> — add the missing component with schema defaults</li>
<li><strong>add_child</strong> — create a child entity of the required archetype</li>
<li><strong>remove_invalid</strong> — remove entities that violate the rule</li>
<li><strong>assign_from_parent</strong> — copy a value from the parent entity</li>
</ul>
<h2 id="testing-constraints"><a class="header" href="#testing-constraints">Testing Constraints</a></h2>
<p>Always test with <code>--dry-run</code> first to preview changes:</p>
<pre><code class="language-bash"># See what violations exist
flint validate levels/tavern.scene.toml --schemas schemas

# Preview auto-fix changes without applying
flint validate levels/tavern.scene.toml --fix --dry-run

# Apply fixes
flint validate levels/tavern.scene.toml --fix
</code></pre>
<p>JSON output gives machine-readable results for CI:</p>
<pre><code class="language-bash">flint validate levels/tavern.scene.toml --format json
</code></pre>
<h2 id="organizing-constraint-files"><a class="header" href="#organizing-constraint-files">Organizing Constraint Files</a></h2>
<p>Group related constraints into files by topic:</p>
<pre><code>schemas/constraints/
├── basics.toml          # Fundamental rules (transform required, etc.)
├── physics.toml         # Physics constraints (collider sizes, mass ranges)
├── audio.toml           # Audio constraints (volume ranges, spatial settings)
└── gameplay.toml        # Game-specific rules (one player, door connectivity)
</code></pre>
<p>All <code>.toml</code> files in <code>schemas/constraints/</code> are loaded automatically.</p>
<h2 id="cascade-detection"><a class="header" href="#cascade-detection">Cascade Detection</a></h2>
<p>When auto-fix modifies one entity, it might cause a different constraint to fail. Flint handles this by running fix-validate cycles. If a cycle is detected (the same violation keeps appearing), the fixer stops and reports the issue.</p>
<h2 id="further-reading-16"><a class="header" href="#further-reading-16">Further Reading</a></h2>
<ul>
<li><a href="#constraints">Constraints</a> — constraint system reference</li>
<li><a href="#queries">Queries</a> — query syntax used in constraint selectors</li>
<li><a href="#file-formats">File Formats</a> — constraint TOML format</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="importing-assets-1"><a class="header" href="#importing-assets-1">Importing Assets</a></h1>
<p>This guide walks through importing external files into Flint’s content-addressed asset store.</p>
<h2 id="basic-import"><a class="header" href="#basic-import">Basic Import</a></h2>
<p>Import a glTF model with the <code>flint asset import</code> command:</p>
<pre><code class="language-bash">flint asset import models/chair.glb --name tavern_chair --tags furniture,medieval
</code></pre>
<p>This does three things:</p>
<ol>
<li><strong>Hashes</strong> the file (SHA-256) and stores it under <code>.flint/assets/&lt;hash&gt;/</code></li>
<li><strong>Extracts</strong> mesh, material, and texture data (for glTF/GLB files)</li>
<li><strong>Writes</strong> a <code>.asset.toml</code> sidecar with metadata</li>
</ol>
<h2 id="content-addressed-storage"><a class="header" href="#content-addressed-storage">Content-Addressed Storage</a></h2>
<p>Every imported file is stored by its content hash:</p>
<pre><code>.flint/
└── assets/
    ├── a1/
    │   └── a1b2c3d4e5f6...  (the actual file)
    └── f7/
        └── f7a8b9c0d1e2...  (another file)
</code></pre>
<p>The first two hex characters of the hash form a subdirectory, preventing any single directory from having too many entries. Identical files are automatically deduplicated — importing the same model twice stores it only once.</p>
<h2 id="gltfglb-import-1"><a class="header" href="#gltfglb-import-1">glTF/GLB Import</a></h2>
<p>For 3D models, the importer extracts structured data:</p>
<pre><code class="language-bash">$ flint asset import models/tavern_door.glb --name tavern_door
Imported: 3 mesh(es), 2 texture(s), 2 material(s)
Asset 'tavern_door' registered.
  Hash: sha256:a1b2c3...
  Type: Mesh
  Sidecar: assets/meshes/tavern_door.asset.toml
</code></pre>
<p>Extracted data includes:</p>
<ul>
<li><strong>Meshes</strong> — vertex positions, normals, texture coordinates, indices, and optionally joint indices/weights for skeletal meshes</li>
<li><strong>Materials</strong> — PBR properties (base color, roughness, metallic, emissive)</li>
<li><strong>Textures</strong> — embedded or referenced image files</li>
<li><strong>Skeletons</strong> — joint hierarchy and inverse bind matrices (if the model has skins)</li>
<li><strong>Animations</strong> — per-joint keyframe channels (translation, rotation, scale)</li>
</ul>
<h2 id="sidecar-metadata"><a class="header" href="#sidecar-metadata">Sidecar Metadata</a></h2>
<p>Each imported asset gets an <code>.asset.toml</code> file in the <code>assets/</code> directory:</p>
<pre><code class="language-toml">[asset]
name = "tavern_chair"
type = "mesh"
hash = "sha256:a1b2c3d4e5f6..."
source_path = "models/chair.glb"
format = "glb"
tags = ["furniture", "medieval"]
</code></pre>
<p>For AI-generated assets, the sidecar also records provenance:</p>
<pre><code class="language-toml">[asset.properties]
prompt = "weathered wooden tavern chair"
provider = "meshy"
</code></pre>
<h2 id="tagging-and-organization"><a class="header" href="#tagging-and-organization">Tagging and Organization</a></h2>
<p>Tags help organize and filter assets:</p>
<pre><code class="language-bash"># Import with tags
flint asset import models/barrel.glb --name barrel --tags furniture,storage,medieval

# Filter by tag
flint asset list --tag medieval

# Filter by type
flint asset list --type mesh

# Get details on a specific asset
flint asset info tavern_chair
</code></pre>
<h2 id="asset-catalog-1"><a class="header" href="#asset-catalog-1">Asset Catalog</a></h2>
<p>The catalog is built by scanning all <code>.asset.toml</code> files in the <code>assets/</code> directory. It provides indexed lookup by name, type, and tag:</p>
<pre><code class="language-bash"># List all assets
flint asset list

# JSON output for scripting
flint asset list --format json
</code></pre>
<h2 id="resolving-references"><a class="header" href="#resolving-references">Resolving References</a></h2>
<p>Check that a scene’s asset references are satisfied:</p>
<pre><code class="language-bash"># Strict mode --- all references must exist
flint asset resolve levels/tavern.scene.toml --strategy strict

# Placeholder mode --- missing assets replaced with fallback geometry
flint asset resolve levels/tavern.scene.toml --strategy placeholder

# AI generation --- missing assets created by AI providers
flint asset resolve levels/tavern.scene.toml --strategy ai_generate --style medieval_tavern
</code></pre>
<h2 id="supported-formats"><a class="header" href="#supported-formats">Supported Formats</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Type</th><th>Import Support</th></tr>
</thead>
<tbody>
<tr><td><code>.glb</code>, <code>.gltf</code></td><td>3D Model</td><td>Full (mesh, material, texture, skeleton, animation)</td></tr>
<tr><td><code>.png</code>, <code>.jpg</code>, <code>.bmp</code>, <code>.tga</code>, <code>.hdr</code></td><td>Texture</td><td>Hash and catalog</td></tr>
<tr><td><code>.wav</code>, <code>.ogg</code>, <code>.mp3</code>, <code>.flac</code></td><td>Audio</td><td>Hash and catalog</td></tr>
<tr><td>Other</td><td>Generic</td><td>Hash and catalog (type guessed from extension)</td></tr>
</tbody>
</table>
</div>
<h2 id="further-reading-17"><a class="header" href="#further-reading-17">Further Reading</a></h2>
<ul>
<li><a href="#assets">Assets</a> — content-addressed storage concept</li>
<li><a href="#ai-asset-generation-1">AI Asset Generation</a> — generating assets with AI providers</li>
<li><a href="#file-formats">File Formats</a> — <code>.asset.toml</code> sidecar format</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="headless-rendering-2"><a class="header" href="#headless-rendering-2">Headless Rendering</a></h1>
<p>Flint can render scenes to PNG images without opening a window. This enables automated screenshots, visual regression testing, and CI pipeline integration.</p>
<h2 id="the-flint-render-command"><a class="header" href="#the-flint-render-command">The <code>flint render</code> Command</a></h2>
<pre><code class="language-bash">flint render levels/tavern.scene.toml --output preview.png
</code></pre>
<p>This loads the scene, renders a single frame with PBR shading and shadows, and writes the result to a PNG file.</p>
<h2 id="camera-options"><a class="header" href="#camera-options">Camera Options</a></h2>
<p>Control the camera position with orbit-style parameters:</p>
<pre><code class="language-bash">flint render levels/tavern.scene.toml \
    --output preview.png \
    --width 1920 --height 1080 \
    --distance 30 \
    --yaw 45 \
    --pitch 30
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>--output &lt;path&gt;</code></td><td><code>render.png</code></td><td>Output file path</td></tr>
<tr><td><code>--width &lt;px&gt;</code></td><td>800</td><td>Image width in pixels</td></tr>
<tr><td><code>--height &lt;px&gt;</code></td><td>600</td><td>Image height in pixels</td></tr>
<tr><td><code>--distance &lt;units&gt;</code></td><td>20.0</td><td>Camera distance from origin</td></tr>
<tr><td><code>--yaw &lt;degrees&gt;</code></td><td>0.0</td><td>Horizontal camera angle</td></tr>
<tr><td><code>--pitch &lt;degrees&gt;</code></td><td>30.0</td><td>Vertical camera angle</td></tr>
<tr><td><code>--schemas &lt;path&gt;</code></td><td><code>schemas</code></td><td>Path to schemas directory</td></tr>
</tbody>
</table>
</div>
<h2 id="ci-pipeline-integration"><a class="header" href="#ci-pipeline-integration">CI Pipeline Integration</a></h2>
<p>Headless rendering works on machines without a display. Use it in CI to catch visual regressions:</p>
<pre><code class="language-yaml"># Example GitHub Actions step
- name: Render preview
  run: |
    cargo run --bin flint -- render levels/tavern.scene.toml \
      --output screenshots/tavern.png \
      --width 1920 --height 1080

- name: Upload screenshot
  uses: actions/upload-artifact@v4
  with:
    name: screenshots
    path: screenshots/
</code></pre>
<h2 id="visual-regression-testing"><a class="header" href="#visual-regression-testing">Visual Regression Testing</a></h2>
<p>A basic visual regression workflow:</p>
<ol>
<li>
<p><strong>Baseline</strong> — render a reference image and commit it:</p>
<pre><code class="language-bash">flint render levels/tavern.scene.toml --output tests/baseline/tavern.png
</code></pre>
</li>
<li>
<p><strong>Test</strong> — after changes, render again and compare:</p>
<pre><code class="language-bash">flint render levels/tavern.scene.toml --output tests/current/tavern.png
# Compare with your preferred tool (ImageMagick, pixelmatch, etc.)
</code></pre>
</li>
<li>
<p><strong>Update</strong> — if the change is intentional, update the baseline:</p>
<pre><code class="language-bash">cp tests/current/tavern.png tests/baseline/tavern.png
</code></pre>
</li>
</ol>
<p>Since Flint’s renderer is deterministic for a given scene file and camera position, identical inputs produce identical outputs.</p>
<h2 id="rendering-multiple-views"><a class="header" href="#rendering-multiple-views">Rendering Multiple Views</a></h2>
<p>Script multiple renders for different angles:</p>
<pre><code class="language-bash">#!/bin/bash
SCENE="levels/tavern.scene.toml"

for angle in 0 90 180 270; do
    flint render "$SCENE" \
        --output "screenshots/view_${angle}.png" \
        --yaw $angle --pitch 25 --distance 25 \
        --width 1920 --height 1080
done
</code></pre>
<h2 id="rendering-pipeline-details"><a class="header" href="#rendering-pipeline-details">Rendering Pipeline Details</a></h2>
<p>Headless rendering uses the same wgpu PBR pipeline as the interactive viewer:</p>
<ul>
<li><strong>Cook-Torrance BRDF</strong> with roughness/metallic workflow</li>
<li><strong>Cascaded shadow mapping</strong> for directional light shadows</li>
<li><strong>glTF mesh rendering</strong> with full material support</li>
<li><strong>Skinned mesh rendering</strong> with bone matrix upload (for skeletal meshes)</li>
</ul>
<p>The only difference from interactive rendering is that the output goes to a texture-to-buffer copy instead of a swapchain surface.</p>
<h2 id="further-reading-18"><a class="header" href="#further-reading-18">Further Reading</a></h2>
<ul>
<li><a href="#rendering">Rendering</a> — the PBR rendering pipeline</li>
<li><a href="#ai-agent-workflow">AI Agent Workflow</a> — using headless renders for agent verification</li>
<li><a href="#cli-reference">CLI Reference</a> — full command options</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ai-agent-workflow"><a class="header" href="#ai-agent-workflow">AI Agent Workflow</a></h1>
<p>This guide covers how AI coding agents interact with Flint to build game scenes programmatically. It describes the agent interaction loop, error handling patterns, and best practices.</p>
<h2 id="the-agent-interaction-loop"><a class="header" href="#the-agent-interaction-loop">The Agent Interaction Loop</a></h2>
<p>An agent building a scene follows a create-validate-query-render cycle:</p>
<pre><code>┌──────────────────────────────────────────────────┐
│                                                  │
│   1. Discover ──► 2. Create ──► 3. Validate ─┐   │
│        ▲                                     │   │
│        │          4. Query ◄─── 5. Fix ◄─────┘   │
│        │              │                          │
│        └──────────────┤                          │
│                       ▼                          │
│                  6. Render ──► Human Review       │
│                                                  │
└──────────────────────────────────────────────────┘
</code></pre>
<h3 id="step-1-discover-available-schemas"><a class="header" href="#step-1-discover-available-schemas">Step 1: Discover Available Schemas</a></h3>
<p>Before creating entities, the agent learns what’s available:</p>
<pre><code class="language-bash"># List available archetypes
flint schema --list-archetypes --schemas schemas

# Inspect a specific archetype
flint schema player --schemas schemas

# Inspect a component
flint schema collider --schemas schemas
</code></pre>
<p>This tells the agent what fields exist, their types, and their defaults.</p>
<h3 id="step-2-create-scene-and-entities"><a class="header" href="#step-2-create-scene-and-entities">Step 2: Create Scene and Entities</a></h3>
<pre><code class="language-bash"># Create the scene file
flint scene create levels/dungeon.scene.toml --name "Dungeon Level 1"

# Create entities
flint entity create --archetype room --name "entrance" \
    --scene levels/dungeon.scene.toml

flint entity create --archetype door --name "iron_gate" \
    --parent "entrance" \
    --scene levels/dungeon.scene.toml
</code></pre>
<p>Or the agent can write TOML directly — often faster for complex scenes:</p>
<pre><code class="language-toml">[scene]
name = "Dungeon Level 1"

[entities.entrance]
archetype = "room"

[entities.entrance.transform]
position = [0.0, 0.0, 0.0]

[entities.entrance.bounds]
size = [10.0, 4.0, 10.0]

[entities.iron_gate]
archetype = "door"
parent = "entrance"

[entities.iron_gate.transform]
position = [0.0, 1.5, -5.0]
</code></pre>
<h3 id="step-3-validate"><a class="header" href="#step-3-validate">Step 3: Validate</a></h3>
<p>Check the scene against constraints:</p>
<pre><code class="language-bash">flint validate levels/dungeon.scene.toml --format json --schemas schemas
</code></pre>
<p>JSON output example:</p>
<pre><code class="language-json">{
  "valid": false,
  "violations": [
    {
      "constraint": "doors_have_transform",
      "entity": "iron_gate",
      "severity": "error",
      "message": "Door 'iron_gate' is missing a transform component"
    }
  ]
}
</code></pre>
<p>The agent parses this JSON, understands what’s wrong, and proceeds to fix it.</p>
<h3 id="step-4-query-to-verify"><a class="header" href="#step-4-query-to-verify">Step 4: Query to Verify</a></h3>
<p>After fixing violations, the agent can query to confirm the scene state:</p>
<pre><code class="language-bash"># Verify the door now has a transform
flint query "entities where archetype == 'door'" \
    --scene levels/dungeon.scene.toml --format json

# Count entities
flint query "entities" \
    --scene levels/dungeon.scene.toml --format json | jq length
</code></pre>
<h3 id="step-5-fix-and-iterate"><a class="header" href="#step-5-fix-and-iterate">Step 5: Fix and Iterate</a></h3>
<p>If validation fails, the agent can either:</p>
<ul>
<li>
<p><strong>Auto-fix</strong> — let Flint handle it:</p>
<pre><code class="language-bash">flint validate levels/dungeon.scene.toml --fix --dry-run --format json
flint validate levels/dungeon.scene.toml --fix
</code></pre>
</li>
<li>
<p><strong>Manual fix</strong> — edit the TOML to add missing data</p>
</li>
</ul>
<h3 id="step-6-render-for-review"><a class="header" href="#step-6-render-for-review">Step 6: Render for Review</a></h3>
<p>Generate a preview image for human (or vision-model) review:</p>
<pre><code class="language-bash">flint render levels/dungeon.scene.toml --output preview.png \
    --width 1920 --height 1080 --distance 25 --yaw 45
</code></pre>
<h2 id="ai-asset-generation-2"><a class="header" href="#ai-asset-generation-2">AI Asset Generation</a></h2>
<p>Agents can generate assets alongside scene construction:</p>
<pre><code class="language-bash"># Generate textures for the scene
flint asset generate texture \
    -d "rough dungeon stone wall, torch-lit" \
    --style medieval_tavern \
    --name dungeon_wall_texture

# Generate a 3D model
flint asset generate model \
    -d "iron-bound wooden door, medieval dungeon" \
    --provider meshy \
    --name iron_door_model

# Batch-generate all missing assets for the entire scene
flint asset resolve levels/dungeon.scene.toml \
    --strategy ai_generate \
    --style medieval_tavern
</code></pre>
<p>Semantic asset definitions in the scene file guide batch generation:</p>
<pre><code class="language-toml">[entities.wall_section.asset_def]
name = "dungeon_wall_texture"
description = "Rough stone dungeon wall with moss and cracks"
type = "texture"
material_intent = "rough stone"
wear_level = 0.8
</code></pre>
<h2 id="error-handling-patterns"><a class="header" href="#error-handling-patterns">Error Handling Patterns</a></h2>
<h3 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h3>
<p>All Flint commands use standard exit codes:</p>
<ul>
<li><strong>0</strong> — success</li>
<li><strong>1</strong> — error (validation failure, missing file, etc.)</li>
</ul>
<pre><code class="language-bash">flint validate levels/dungeon.scene.toml --format json
if [ $? -ne 0 ]; then
    echo "Validation failed, fixing..."
    flint validate levels/dungeon.scene.toml --fix
fi
</code></pre>
<h3 id="json-error-output"><a class="header" href="#json-error-output">JSON Error Output</a></h3>
<p>Error details are always available in JSON:</p>
<pre><code class="language-bash">flint validate levels/dungeon.scene.toml --format json 2&gt;/dev/null
</code></pre>
<h3 id="idempotent-operations"><a class="header" href="#idempotent-operations">Idempotent Operations</a></h3>
<p>Most Flint operations are idempotent — running them twice produces the same result. This is important for agents that may retry failed operations.</p>
<h2 id="example-agent-building-a-complete-scene"><a class="header" href="#example-agent-building-a-complete-scene">Example: Agent Building a Complete Scene</a></h2>
<p>Here’s a complete agent workflow script:</p>
<pre><code class="language-bash">#!/bin/bash
set -e
SCENE="levels/generated.scene.toml"
SCHEMAS="schemas"

# 1. Create scene
flint scene create "$SCENE" --name "Agent-Generated Level"

# 2. Build structure
flint entity create --archetype room --name "main_room" --scene "$SCENE"
flint entity create --archetype room --name "side_room" --scene "$SCENE"
flint entity create --archetype door --name "connecting_door" \
    --parent "main_room" --scene "$SCENE"

# 3. Add player
flint entity create --archetype player --name "player" --scene "$SCENE"

# 4. Validate (will likely fail --- no transforms yet)
flint validate "$SCENE" --schemas "$SCHEMAS" --format json || true

# 5. Auto-fix what we can
flint validate "$SCENE" --schemas "$SCHEMAS" --fix

# 6. Verify
ENTITY_COUNT=$(flint query "entities" --scene "$SCENE" --format json | jq length)
echo "Scene has $ENTITY_COUNT entities"

# 7. Render preview
flint render "$SCENE" --output preview.png --schemas "$SCHEMAS" \
    --width 1920 --height 1080

echo "Scene built successfully. Preview: preview.png"
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ul>
<li><strong>Always validate after creating entities</strong> — catch problems early</li>
<li><strong>Use JSON output</strong> — easier to parse than text</li>
<li><strong>Use <code>--dry-run</code> before <code>--fix</code></strong> — preview changes before applying</li>
<li><strong>Write TOML directly for complex scenes</strong> — faster than many CLI commands</li>
<li><strong>Use semantic asset definitions</strong> — let batch resolution handle asset generation</li>
<li><strong>Render previews</strong> — visual verification catches issues that validation can’t</li>
</ul>
<h2 id="further-reading-19"><a class="header" href="#further-reading-19">Further Reading</a></h2>
<ul>
<li><a href="#ai-agent-interface">AI Agent Interface</a> — the design philosophy</li>
<li><a href="#cli-first-workflow">CLI-First Workflow</a> — composable commands</li>
<li><a href="#ai-asset-generation-1">AI Asset Generation</a> — the AI asset pipeline</li>
<li><a href="#cli-reference">CLI Reference</a> — full command documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-reference"><a class="header" href="#cli-reference">CLI Reference</a></h1>
<p>Flint’s CLI is the primary interface for all engine operations. Below is a reference of available commands.</p>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>flint init &lt;name&gt;</code></td><td>Initialize a new project</td></tr>
<tr><td><code>flint entity create</code></td><td>Create an entity in a scene</td></tr>
<tr><td><code>flint entity delete</code></td><td>Delete an entity from a scene</td></tr>
<tr><td><code>flint scene create</code></td><td>Create a new scene file</td></tr>
<tr><td><code>flint scene list</code></td><td>List scene files</td></tr>
<tr><td><code>flint scene info</code></td><td>Show scene metadata and entity count</td></tr>
<tr><td><code>flint query "&lt;query&gt;"</code></td><td>Query entities with the Flint query language</td></tr>
<tr><td><code>flint schema &lt;name&gt;</code></td><td>Inspect a component or archetype schema</td></tr>
<tr><td><code>flint validate &lt;scene&gt;</code></td><td>Validate a scene against constraints</td></tr>
<tr><td><code>flint asset import</code></td><td>Import a file into the asset store</td></tr>
<tr><td><code>flint asset list</code></td><td>List assets in the catalog</td></tr>
<tr><td><code>flint asset info</code></td><td>Show details for a specific asset</td></tr>
<tr><td><code>flint asset resolve</code></td><td>Check asset references in a scene</td></tr>
<tr><td><code>flint asset generate</code></td><td>Generate an asset using AI providers</td></tr>
<tr><td><code>flint asset validate</code></td><td>Validate a generated model against style constraints</td></tr>
<tr><td><code>flint asset manifest</code></td><td>Generate a build manifest of all generated assets</td></tr>
<tr><td><code>flint asset regenerate</code></td><td>Regenerate an existing asset with new parameters</td></tr>
<tr><td><code>flint asset job status</code></td><td>Check status of an async generation job</td></tr>
<tr><td><code>flint asset job list</code></td><td>List all generation jobs</td></tr>
<tr><td><code>flint serve &lt;scene&gt;</code></td><td>Launch the hot-reload PBR viewer with egui inspector</td></tr>
<tr><td><code>flint play &lt;scene&gt;</code></td><td>Play a scene with first-person controls and physics</td></tr>
<tr><td><code>flint render &lt;scene&gt;</code></td><td>Render a scene to PNG (headless)</td></tr>
</tbody>
</table>
</div>
<h2 id="the-play-command"><a class="header" href="#the-play-command">The <code>play</code> Command</a></h2>
<p>Launch a scene as an interactive first-person experience with physics:</p>
<pre><code class="language-bash">flint play demo/phase4_runtime.scene.toml
flint play levels/tavern.scene.toml --schemas schemas --fullscreen
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>--schemas &lt;path&gt;</code></td><td>Path to schemas directory (default: <code>schemas</code>)</td></tr>
<tr><td><code>--fullscreen</code></td><td>Launch in fullscreen mode</td></tr>
</tbody>
</table>
</div>
<h3 id="player-controls"><a class="header" href="#player-controls">Player Controls</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>WASD</td><td>Move</td></tr>
<tr><td>Mouse</td><td>Look around</td></tr>
<tr><td>Space</td><td>Jump</td></tr>
<tr><td>Shift</td><td>Sprint</td></tr>
<tr><td>E</td><td>Interact with nearby object</td></tr>
<tr><td>Escape</td><td>Release cursor / Exit</td></tr>
<tr><td>F1</td><td>Cycle debug rendering mode</td></tr>
<tr><td>F4</td><td>Toggle shadows</td></tr>
<tr><td>F11</td><td>Toggle fullscreen</td></tr>
</tbody>
</table>
</div>
<p>The <code>play</code> command requires the scene to have a <code>player</code> archetype entity with a <code>character_controller</code> component. Physics colliders on other entities define the walkable geometry.</p>
<h3 id="standalone-player-binary"><a class="header" href="#standalone-player-binary">Standalone Player Binary</a></h3>
<p>The player is also available as a standalone binary for distribution:</p>
<pre><code class="language-bash">cargo run --bin flint-player -- demo/phase4_runtime.scene.toml --schemas schemas
</code></pre>
<h2 id="the-asset-generate-command"><a class="header" href="#the-asset-generate-command">The <code>asset generate</code> Command</a></h2>
<p>Generate assets using AI providers:</p>
<pre><code class="language-bash">flint asset generate texture -d "rough stone wall" --style medieval_tavern
flint asset generate model -d "wooden chair" --provider meshy --seed 42
flint asset generate audio -d "tavern ambient noise" --duration 10.0
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>-d</code>, <code>--description</code></td><td>Generation prompt (required)</td></tr>
<tr><td><code>--name</code></td><td>Asset name (derived from description if omitted)</td></tr>
<tr><td><code>--provider</code></td><td>Provider to use: <code>flux</code>, <code>meshy</code>, <code>elevenlabs</code>, <code>mock</code></td></tr>
<tr><td><code>--style</code></td><td>Style guide name (e.g., <code>medieval_tavern</code>)</td></tr>
<tr><td><code>--width</code>, <code>--height</code></td><td>Image dimensions for textures (default: 1024x1024)</td></tr>
<tr><td><code>--seed</code></td><td>Random seed for reproducibility</td></tr>
<tr><td><code>--tags</code></td><td>Comma-separated tags</td></tr>
<tr><td><code>--output</code></td><td>Output directory (default: <code>.flint/generated</code>)</td></tr>
<tr><td><code>--duration</code></td><td>Audio duration in seconds (default: 3.0)</td></tr>
</tbody>
</table>
</div>
<p>Generated assets are automatically stored in content-addressed storage and registered in the asset catalog with a <code>.asset.toml</code> sidecar. Models are validated against style constraints after generation.</p>
<h2 id="common-flags"><a class="header" href="#common-flags">Common Flags</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>--scene &lt;path&gt;</code></td><td>Path to scene file</td></tr>
<tr><td><code>--schemas &lt;path&gt;</code></td><td>Path to schemas directory (default: <code>schemas</code>)</td></tr>
<tr><td><code>--format &lt;fmt&gt;</code></td><td>Output format: <code>json</code>, <code>toml</code>, or <code>text</code></td></tr>
<tr><td><code>--watch</code></td><td>Watch for file changes (with <code>serve</code>)</td></tr>
<tr><td><code>--fix</code></td><td>Apply auto-fixes (with <code>validate</code>)</td></tr>
<tr><td><code>--dry-run</code></td><td>Preview changes without applying</td></tr>
</tbody>
</table>
</div>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-bash"># Get help
flint --help
flint &lt;command&gt; --help

# Examples
flint init my-game
flint serve levels/tavern.scene.toml --watch --schemas schemas
flint play levels/tavern.scene.toml
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="file-formats"><a class="header" href="#file-formats">File Formats</a></h1>
<p>All Flint data formats use TOML. This page provides a complete reference for every file type.</p>
<h2 id="scene-files-scenetoml"><a class="header" href="#scene-files-scenetoml">Scene Files (<code>.scene.toml</code>)</a></h2>
<p>The primary data format. Each scene file contains metadata and a collection of named entities with their component data.</p>
<pre><code class="language-toml">[scene]
name = "Scene Name"
version = "1.0"

[entities.&lt;name&gt;]
archetype = "&lt;archetype&gt;"
parent = "&lt;parent_name&gt;"          # Optional parent entity

[entities.&lt;name&gt;.&lt;component&gt;]
field = value
</code></pre>
<p>Scenes are loaded by <code>flint-scene</code> and can be edited with <code>flint entity create</code>, <code>flint entity delete</code>, or by hand. The <code>serve --watch</code> viewer reloads automatically when the file changes.</p>
<h2 id="component-schemas-schemascomponentstoml"><a class="header" href="#component-schemas-schemascomponentstoml">Component Schemas (<code>schemas/components/*.toml</code>)</a></h2>
<p>Define the fields, types, and defaults for each component kind. Components are dynamic — they exist as schema TOML, not compiled Rust types.</p>
<pre><code class="language-toml">[component.&lt;name&gt;]
description = "Human-readable description"

[component.&lt;name&gt;.fields]
field_name = { type = "&lt;type&gt;", default = &lt;value&gt;, description = "..." }
</code></pre>
<p>Supported field types: <code>bool</code>, <code>i32</code>, <code>f32</code>, <code>string</code>, <code>vec3</code>, <code>enum</code>, <code>entity_ref</code>, <code>array</code>.</p>
<p>Key component schemas: <code>transform</code>, <code>material</code>, <code>door</code>, <code>bounds</code>, <code>rigidbody</code>, <code>collider</code>, <code>character_controller</code>, <code>audio_source</code>, <code>audio_listener</code>, <code>audio_trigger</code>, <code>animator</code>, <code>skeleton</code>, <code>script</code>, <code>interactable</code>, <code>asset_def</code>.</p>
<h2 id="archetype-schemas-schemasarchetypestoml"><a class="header" href="#archetype-schemas-schemasarchetypestoml">Archetype Schemas (<code>schemas/archetypes/*.toml</code>)</a></h2>
<p>Bundle components together with sensible defaults for common entity types.</p>
<pre><code class="language-toml">[archetype.&lt;name&gt;]
description = "..."
components = ["comp1", "comp2"]

[archetype.&lt;name&gt;.defaults.&lt;component&gt;]
field = value
</code></pre>
<h2 id="constraint-files-schemasconstraintstoml"><a class="header" href="#constraint-files-schemasconstraintstoml">Constraint Files (<code>schemas/constraints/*.toml</code>)</a></h2>
<p>Declarative validation rules checked by <code>flint validate</code>. Each file can contain multiple <code>[[constraint]]</code> entries.</p>
<pre><code class="language-toml">[[constraint]]
name = "rule_name"
description = "What this constraint checks"
query = "entities where archetype == 'door'"
severity = "error"                 # "error" or "warning"
message = "Door '{name}' is missing a transform component"

[constraint.kind]
type = "required_component"        # Constraint type
archetype = "door"
component = "transform"
</code></pre>
<p>Constraint kinds: <code>required_component</code>, <code>required_child</code>, <code>value_range</code>, <code>reference_valid</code>, <code>query_rule</code>.</p>
<h2 id="animation-clips-animationsanimtoml"><a class="header" href="#animation-clips-animationsanimtoml">Animation Clips (<code>animations/*.anim.toml</code>)</a></h2>
<p>TOML-defined keyframe animation clips for property tweens. Loaded by scanning the animations directory at startup.</p>
<pre><code class="language-toml">name = "clip_name"
duration = 0.8

[[tracks]]
interpolation = "Linear"           # "Step", "Linear", or "CubicSpline"

[tracks.target]
type = "Rotation"                  # "Position", "Rotation", "Scale", or "CustomFloat"
# component = "material"           # Required for CustomFloat
# field = "emissive_strength"      # Required for CustomFloat

[[tracks.keyframes]]
time = 0.0
value = [0.0, 0.0, 0.0]           # [x, y, z] (euler degrees for rotation)

[[tracks.keyframes]]
time = 0.8
value = [0.0, 90.0, 0.0]
# in_tangent = [...]               # Optional, for CubicSpline
# out_tangent = [...]

[[events]]                         # Optional timed events
time = 0.0
event_name = "door_start"
</code></pre>
<h2 id="asset-sidecars-assetsassettoml"><a class="header" href="#asset-sidecars-assetsassettoml">Asset Sidecars (<code>assets/**/*.asset.toml</code>)</a></h2>
<p>Metadata files stored alongside imported assets in the catalog.</p>
<pre><code class="language-toml">[asset]
name = "asset_name"
type = "mesh"                      # mesh, texture, material, audio, script
hash = "sha256:a1b2c3..."
source_path = "models/chair.glb"
format = "glb"
tags = ["furniture", "medieval"]

[asset.properties]                 # Optional provider-specific metadata
prompt = "wooden tavern chair"
provider = "meshy"
</code></pre>
<h2 id="style-guides-stylesstyletoml"><a class="header" href="#style-guides-stylesstyletoml">Style Guides (<code>styles/*.style.toml</code>)</a></h2>
<p>Define visual vocabulary for consistent AI asset generation. Searched in <code>styles/</code> then <code>.flint/styles/</code>.</p>
<pre><code class="language-toml">[style]
name = "medieval_tavern"
description = "Weathered medieval fantasy tavern"
prompt_prefix = "Medieval fantasy tavern style, low-fantasy realism"
prompt_suffix = "Photorealistic textures, warm candlelight tones"
negative_prompt = "modern, sci-fi, neon, plastic"
palette = ["#8B4513", "#A0522D", "#D4A574", "#4A4A4A"]

[style.materials]
roughness_range = [0.6, 0.95]
metallic_range = [0.0, 0.15]
preferred_materials = ["aged oak wood", "rough-hewn stone", "hammered wrought iron"]

[style.geometry]
max_triangles = 5000
require_uvs = true
require_normals = true
</code></pre>
<h2 id="semantic-asset-definitions-schemascomponentsasset_deftoml"><a class="header" href="#semantic-asset-definitions-schemascomponentsasset_deftoml">Semantic Asset Definitions (<code>schemas/components/asset_def.toml</code>)</a></h2>
<p>The <code>asset_def</code> component schema describes what an entity needs in terms of assets, expressed as intent. Used by the batch resolver to auto-generate missing assets.</p>
<pre><code class="language-toml">[entities.tavern_wall.asset_def]
name = "tavern_wall_texture"
description = "Rough stone wall with mortar lines"
type = "texture"
material_intent = "rough stone"
wear_level = 0.7
size_class = "large"
tags = ["wall", "interior"]
</code></pre>
<h2 id="rhai-scripts-scriptsrhai"><a class="header" href="#rhai-scripts-scriptsrhai">Rhai Scripts (<code>scripts/*.rhai</code>)</a></h2>
<p>Game logic scripts written in <a href="https://rhai.rs/">Rhai</a>. Attached to entities via the <code>script</code> component. See <a href="#scripting">Scripting</a> for the full API reference.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_init() {
    log("Entity initialized");
}

fn on_update(dt) {
    // Called every frame with delta time
}

fn on_interact() {
    // Called when the player interacts with this entity
    play_sound("door_open");
}
<span class="boring">}</span></code></pre>
<h2 id="configuration-flintconfigtoml-flintconfigtoml"><a class="header" href="#configuration-flintconfigtoml-flintconfigtoml">Configuration (<code>~/.flint/config.toml</code>, <code>.flint/config.toml</code>)</a></h2>
<p>Layered configuration for API keys and generation settings. Global config is merged with project-level config; environment variables override both.</p>
<pre><code class="language-toml">[providers.flux]
api_key = "your-api-key"
enabled = true

[providers.meshy]
api_key = "your-api-key"
enabled = true

[providers.elevenlabs]
api_key = "your-api-key"
enabled = true

[generation]
default_style = "medieval_tavern"
</code></pre>
<p>Environment variable overrides: <code>FLINT_FLUX_API_KEY</code>, <code>FLINT_MESHY_API_KEY</code>, <code>FLINT_ELEVENLABS_API_KEY</code>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>Flint is structured as an eighteen-crate Cargo workspace with clear dependency layering. Each crate has a focused responsibility, and dependencies flow in one direction — from the binaries down to core types.</p>
<h2 id="workspace-structure"><a class="header" href="#workspace-structure">Workspace Structure</a></h2>
<pre><code>flint/
├── crates/
│   ├── flint-cli/          # CLI binary (clap). Entry point for all commands.
│   ├── flint-asset-gen/    # AI asset generation: providers, style guides, batch resolution
│   ├── flint-player/       # Standalone player binary with game loop, physics, audio, animation, scripting
│   ├── flint-script/       # Rhai scripting: ScriptEngine, ScriptSync, hot-reload
│   ├── flint-viewer/       # egui-based GUI inspector with hot-reload
│   ├── flint-animation/    # Two-tier animation: property tweens + skeletal/glTF
│   ├── flint-audio/        # Kira spatial audio: 3D sounds, ambient loops, triggers
│   ├── flint-runtime/      # Game loop infrastructure (GameClock, InputState, EventBus)
│   ├── flint-physics/      # Rapier 3D integration (PhysicsWorld, CharacterController)
│   ├── flint-render/       # wgpu PBR renderer with Cook-Torrance shading + skinned mesh pipeline
│   ├── flint-import/       # File importers (glTF/GLB with skeleton/skin extraction)
│   ├── flint-asset/        # Content-addressed asset storage and catalog
│   ├── flint-constraint/   # Constraint definitions and validation engine
│   ├── flint-query/        # PEG query language (pest parser)
│   ├── flint-scene/        # TOML scene serialization/deserialization
│   ├── flint-ecs/          # hecs wrapper with stable IDs, names, hierarchy
│   ├── flint-schema/       # Component/archetype schema loading and validation
│   └── flint-core/         # Fundamental types: EntityId, Transform, Vec3, etc.
├── schemas/                # Default component, archetype, and constraint definitions
├── demo/                   # Showcase scenes and build scripts
└── docs/                   # This documentation (mdBook)
</code></pre>
<h2 id="design-decisions"><a class="header" href="#design-decisions">Design Decisions</a></h2>
<h3 id="dynamic-components"><a class="header" href="#dynamic-components">Dynamic Components</a></h3>
<p>The most significant architectural choice: components are stored as <code>toml::Value</code> rather than Rust types. This means:</p>
<ul>
<li><strong>Archetypes are runtime data</strong>, not compiled types</li>
<li>New components can be defined in TOML without recompiling</li>
<li>The schema system validates component data against definitions</li>
<li>Trade-off: less compile-time safety, more flexibility</li>
</ul>
<h3 id="stable-entity-ids"><a class="header" href="#stable-entity-ids">Stable Entity IDs</a></h3>
<p>Entity IDs are monotonically increasing 64-bit integers that never recycle. A <code>BiMap</code> maintains the mapping between <code>EntityId</code> and hecs <code>Entity</code> handles. On scene load, the ID counter adjusts to be above the maximum existing ID.</p>
<h3 id="scene-as-source-of-truth-1"><a class="header" href="#scene-as-source-of-truth-1">Scene as Source of Truth</a></h3>
<p>The TOML file on disk is canonical. In-memory state is derived from it. The <code>serve --watch</code> viewer re-parses the entire file on change rather than attempting incremental updates. This is simpler and avoids synchronization bugs.</p>
<h3 id="fixed-timestep-physics"><a class="header" href="#fixed-timestep-physics">Fixed-Timestep Physics</a></h3>
<p>The game loop uses a fixed-timestep accumulator pattern (1/60s default). Physics simulation steps at a constant rate regardless of frame rate, ensuring deterministic behavior. Rendering interpolates between physics states for smooth visuals.</p>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>All crates use <code>thiserror</code> for error types. Each crate defines its own error enum and a <code>Result&lt;T&gt;</code> type alias. Errors propagate upward through the crate hierarchy.</p>
<h2 id="technology-choices"><a class="header" href="#technology-choices">Technology Choices</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Technology</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>Language</td><td>Rust</td><td>Performance, safety, game ecosystem</td></tr>
<tr><td>ECS</td><td>hecs</td><td>Lightweight, standalone, well-tested</td></tr>
<tr><td>Rendering</td><td>wgpu 23</td><td>Cross-platform, modern GPU API</td></tr>
<tr><td>Windowing</td><td>winit 0.30</td><td><code>ApplicationHandler</code> trait pattern</td></tr>
<tr><td>Physics</td><td>Rapier 3D 0.22</td><td>Mature Rust physics, character controller</td></tr>
<tr><td>Audio</td><td>Kira 0.11</td><td>Rust-native, game-focused, spatial audio</td></tr>
<tr><td>GUI</td><td>egui 0.30</td><td>Immediate-mode, easy integration with wgpu</td></tr>
<tr><td>Scene format</td><td>TOML</td><td>Human-readable, diffable, good Rust support</td></tr>
<tr><td>Query parser</td><td>pest</td><td>PEG grammar, good error messages</td></tr>
<tr><td>Scripting</td><td>Rhai 1.24</td><td>Sandboxed, embeddable, Rust-native</td></tr>
<tr><td>AI generation</td><td>ureq</td><td>Lightweight HTTP client for provider APIs</td></tr>
<tr><td>CLI framework</td><td>clap (derive)</td><td>Ergonomic, well-documented</td></tr>
<tr><td>Error handling</td><td>thiserror + anyhow</td><td>Typed errors in libraries, flexible in binary</td></tr>
</tbody>
</table>
</div>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<p>Flint has two entry points: the CLI for scene authoring and validation, and the player for interactive gameplay. Both flow through the same crate hierarchy:</p>
<pre><code>User / AI Agent
      │
      ├──────────────────────────────────┐
      ▼                                  ▼
  flint-cli                        flint-player
  (scene authoring)                (interactive gameplay)
      │                                  │
      ├──► flint-viewer    (GUI)         ├──► flint-runtime   (game loop, input)
      ├──► flint-query     (queries)     ├──► flint-physics   (Rapier 3D)
      ├──► flint-scene     (load/save)   ├──► flint-audio     (Kira spatial audio)
      ├──► flint-render    (renderer)    ├──► flint-animation (tweens + skeletal)
      ├──► flint-constraint(validation)  ├──► flint-script    (Rhai scripting)
      ├──► flint-asset     (catalog)     └──► flint-render    (PBR + skinned mesh)
      ├──► flint-asset-gen (AI gen)              │
      └──► flint-import    (glTF import)         ▼
              │                              flint-import  (glTF meshes + skins)
              ▼                                  │
          flint-ecs                              ▼
          flint-schema                       flint-ecs
          flint-core                         flint-schema
                                             flint-core
</code></pre>
<h2 id="crate-details"><a class="header" href="#crate-details">Crate Details</a></h2>
<h3 id="flint-core"><a class="header" href="#flint-core">flint-core</a></h3>
<p>Fundamental types shared by all crates. Minimal external dependencies (<code>thiserror</code>, <code>serde</code>, <code>sha2</code>).</p>
<ul>
<li><code>EntityId</code> — stable 64-bit entity identifier</li>
<li><code>ContentHash</code> — SHA-256 based content addressing</li>
<li><code>Transform</code>, <code>Vec3</code>, <code>Color</code> — geometric primitives</li>
<li><code>FlintError</code> — base error type</li>
</ul>
<h3 id="flint-schema"><a class="header" href="#flint-schema">flint-schema</a></h3>
<p>Loads component and archetype definitions from TOML files. Provides a registry for introspection. Supports field types (<code>bool</code>, <code>i32</code>, <code>f32</code>, <code>string</code>, <code>vec3</code>, <code>enum</code>, <code>entity_ref</code>) with validation constraints.</p>
<h3 id="flint-ecs"><a class="header" href="#flint-ecs">flint-ecs</a></h3>
<p>Wraps hecs with:</p>
<ul>
<li><code>BiMap&lt;EntityId, hecs::Entity&gt;</code> for stable ID mapping</li>
<li>Named entity lookup</li>
<li>Parent-child relationship tracking</li>
<li>Atomic ID counter for deterministic allocation</li>
</ul>
<h3 id="flint-scene"><a class="header" href="#flint-scene">flint-scene</a></h3>
<p>TOML serialization and deserialization for scenes. Handles the mapping between on-disk format and in-memory ECS world.</p>
<h3 id="flint-query"><a class="header" href="#flint-query">flint-query</a></h3>
<p>PEG parser (pest) for the query language. Parses queries like <code>entities where archetype == 'door'</code> and executes them against the ECS world.</p>
<p>Supported operators: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>contains</code></p>
<h3 id="flint-constraint"><a class="header" href="#flint-constraint">flint-constraint</a></h3>
<p>Constraint engine that validates scenes against declarative TOML rules. Supports required components, value ranges, reference validity, and custom query rules. Includes an auto-fix system with cascade detection.</p>
<h3 id="flint-asset"><a class="header" href="#flint-asset">flint-asset</a></h3>
<p>Content-addressed asset storage with SHA-256 hashing. Manages an asset catalog with name/hash/type/tag indexing. Supports resolution strategies (strict, placeholder).</p>
<h3 id="flint-import"><a class="header" href="#flint-import">flint-import</a></h3>
<p>File importers for bringing external assets into the content-addressed store. Supports glTF/GLB with mesh, material, and texture extraction.</p>
<h3 id="flint-render"><a class="header" href="#flint-render">flint-render</a></h3>
<p>wgpu 23 PBR renderer with:</p>
<ul>
<li><strong>Cook-Torrance shading</strong> — physically-based BRDF with roughness/metallic workflow</li>
<li><strong>Cascaded shadow mapping</strong> — directional light shadows across multiple distance ranges</li>
<li><strong>glTF mesh rendering</strong> — imported models rendered with full material support</li>
<li><strong>Camera modes</strong> — orbit (scene viewer) and first-person (player), sharing view/projection math</li>
<li><strong>Headless mode</strong> — render to PNG for CI and automated screenshots</li>
</ul>
<h3 id="flint-viewer"><a class="header" href="#flint-viewer">flint-viewer</a></h3>
<p>egui-based GUI inspector built on top of <code>flint-render</code>:</p>
<ul>
<li>Entity tree with selection</li>
<li>Component property editor</li>
<li>Constraint violation overlay</li>
<li>Hot-reload via file watching (<code>serve --watch</code>)</li>
</ul>
<h3 id="flint-runtime"><a class="header" href="#flint-runtime">flint-runtime</a></h3>
<p>Game loop infrastructure for interactive scenes:</p>
<ul>
<li><code>GameClock</code> — fixed-timestep accumulator (1/60s default)</li>
<li><code>InputState</code> — keyboard and mouse tracking with action bindings</li>
<li><code>EventBus</code> — decoupled event dispatch between systems</li>
<li><code>RuntimeSystem</code> trait — standard interface for update/render systems</li>
</ul>
<h3 id="flint-physics"><a class="header" href="#flint-physics">flint-physics</a></h3>
<p>Rapier 3D integration:</p>
<ul>
<li><code>PhysicsWorld</code> — manages Rapier rigid body and collider sets</li>
<li><code>PhysicsSync</code> — bridges TOML component data to Rapier bodies</li>
<li><code>CharacterController</code> — kinematic first-person movement with gravity, jumping, and ground detection</li>
<li>Uses kinematic bodies for player control, static bodies for world geometry</li>
</ul>
<h3 id="flint-audio"><a class="header" href="#flint-audio">flint-audio</a></h3>
<p>Kira 0.11 integration for game audio:</p>
<ul>
<li><code>AudioEngine</code> — wraps Kira AudioManager, handles sound loading and listener positioning</li>
<li><code>AudioSync</code> — bridges TOML <code>audio_source</code> components to Kira spatial tracks</li>
<li><code>AudioTrigger</code> — maps game events (collision, interaction) to sound playback</li>
<li>Spatial 3D audio with distance attenuation, non-spatial ambient loops</li>
<li>Graceful degradation when no audio device is available (headless/CI)</li>
</ul>
<h3 id="flint-animation"><a class="header" href="#flint-animation">flint-animation</a></h3>
<p>Two-tier animation system:</p>
<ul>
<li><strong>Tier 1: Property tweens</strong> — <code>AnimationClip</code> with keyframe tracks targeting transform properties (position, rotation, scale) or custom fields. Step, Linear, and CubicSpline interpolation. Clips defined in <code>.anim.toml</code> files.</li>
<li><strong>Tier 2: Skeletal animation</strong> — <code>Skeleton</code> and <code>SkeletalClip</code> types for glTF skin/joint hierarchies. GPU vertex skinning via bone matrix storage buffer. Crossfade blending between clips.</li>
<li><code>AnimationSync</code> bridges ECS <code>animator</code> components to property playback</li>
<li><code>SkeletalSync</code> bridges ECS to skeletal playback with bone matrix computation</li>
</ul>
<h3 id="flint-script"><a class="header" href="#flint-script">flint-script</a></h3>
<p>Rhai scripting engine for runtime game logic:</p>
<ul>
<li><code>ScriptEngine</code> — compiles <code>.rhai</code> files, manages per-entity <code>Scope</code> and <code>AST</code>, dispatches callbacks</li>
<li><code>ScriptSync</code> — discovers entities with <code>script</code> components, monitors file timestamps for hot-reload</li>
<li><code>ScriptSystem</code> — <code>RuntimeSystem</code> implementation running in <code>update()</code> (variable-rate)</li>
<li>Full API: entity CRUD, input, time, audio, animation, math, events, logging</li>
<li><code>ScriptCommand</code> pattern — deferred audio/event effects processed by PlayerApp after script batch</li>
<li><code>ScriptCallContext</code> with raw <code>*mut FlintWorld</code> pointer for world access during call batches</li>
</ul>
<h3 id="flint-asset-gen"><a class="header" href="#flint-asset-gen">flint-asset-gen</a></h3>
<p>AI asset generation pipeline:</p>
<ul>
<li><code>GenerationProvider</code> trait with pluggable implementations (Flux, Meshy, ElevenLabs, Mock)</li>
<li><code>StyleGuide</code> — TOML-defined visual vocabulary (palette, materials, geometry constraints) for prompt enrichment</li>
<li><code>SemanticAssetDef</code> — maps intent (description, material, wear level) to generation requests</li>
<li>Batch scene resolution with strategies: <code>AiGenerate</code>, <code>HumanTask</code>, <code>AiThenHuman</code></li>
<li><code>validate_model()</code> — checks GLB geometry and materials against style constraints</li>
<li><code>BuildManifest</code> — provenance tracking (provider, prompt, content hash) for all generated assets</li>
<li><code>FlintConfig</code> — layered configuration for API keys and provider settings</li>
<li><code>JobStore</code> — persistent tracking of async generation jobs (for long-running 3D model generation)</li>
</ul>
<h3 id="flint-player"><a class="header" href="#flint-player">flint-player</a></h3>
<p>Standalone player binary that wires together runtime, physics, audio, animation, scripting, and rendering:</p>
<ul>
<li>Full game loop: clock tick, fixed-step physics, audio sync, animation advance, script update, first-person rendering</li>
<li>Scene loading with physics body creation from TOML collider/rigidbody components</li>
<li>Audio source loading and spatial listener tracking</li>
<li>Skeletal animation with bone matrix upload to GPU each frame</li>
<li>Rhai script system with event dispatch (collisions, triggers, actions, interactions)</li>
<li>Interactable entity system with HUD prompt overlay (egui crosshair + proximity text)</li>
<li>First-person controls (WASD, mouse look, jump, sprint, interact)</li>
<li>Optional asset catalog integration for runtime name-based asset resolution</li>
</ul>
<h3 id="flint-cli"><a class="header" href="#flint-cli">flint-cli</a></h3>
<p>Binary crate with clap-derived command definitions. Routes commands to the appropriate subsystem crate. Commands: <code>init</code>, <code>entity</code>, <code>scene</code>, <code>query</code>, <code>schema</code>, <code>serve</code>, <code>play</code>, <code>validate</code>, <code>asset</code>, <code>render</code>.</p>
<h2 id="further-reading-20"><a class="header" href="#further-reading-20">Further Reading</a></h2>
<ul>
<li><a href="#crate-dependency-graph">Crate Dependency Graph</a> — visual dependency diagram</li>
<li><a href="#design-principles">Design Principles</a> — the principles behind these decisions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crate-dependency-graph"><a class="header" href="#crate-dependency-graph">Crate Dependency Graph</a></h1>
<p>This page shows how Flint’s eighteen crates depend on each other. Dependencies flow downward — higher crates depend on lower ones, never the reverse.</p>
<h2 id="dependency-diagram"><a class="header" href="#dependency-diagram">Dependency Diagram</a></h2>
<pre><code>          ┌─────────────┐                ┌──────────────┐
          │  flint-cli  │                │ flint-player │
          │  (binary)   │                │   (binary)   │
          └──────┬──────┘                └──────┬───────┘
                 │                              │
    ┌────┬───┬──┴──┬────┬────┬─────┐   ┌───┬───┴───┬───┬───┬───┬───┐
    │    │   │     │    │    │     │   │   │       │   │   │   │   │
    ▼    │   ▼     ▼    ▼    ▼     ▼   ▼   ▼       ▼   │   │   │   │
 ┌──────┐│┌─────┐┌────┐│ ┌─────┐┌────────┐┌────────┐┌────────┐│   │
 │viewer│││scene││qry ││ │const││asset-gen││runtime ││physics ││   │
 └──┬───┘│└──┬──┘└─┬──┘│ └──┬──┘└───┬────┘└───┬────┘└───┬────┘│   │
    │    │   │     │   │    │       │          │         │     │   │
    │    ▼   │     │   │    │       │          │         │     ▼   │
    │ ┌──────────┐ │   │    │       │          │         │  ┌─────────┐
    ├►│  render  │◄┘   │    │       │          │         │  │ script  │
    │ └────┬─────┘     │    │       │          │         │  └────┬────┘
    │      │           │    │       │          │         │       │
    │      │           │    │       │          │         ▼       ▼
    │      │           │    │       │          │      ┌─────────────┐
    │      │           │    │       │          │      │audio  anim  │
    │      ▼           │    │       │          │      └──────┬──────┘
    │ ┌──────────┐     │   ┌┘      │          │             │
    │ │  import  │     │   │       │          │             │
    │ └────┬─────┘     │   │       │          │             │
    │      │           ▼   ▼       ▼          ▼             ▼
    │      │    ┌──────────────────────────────────────────────────┐
    │      │    │              flint-ecs                            │
    │      │    │  (hecs wrapper, stable IDs, hierarchy)           │
    │      │    └────────────────┬─────────────────────────────────┘
    │      │                    │
    │      │                    ▼
    │      │             ┌──────────────┐
    │      │             │ flint-schema │
    │      │             └──────┬───────┘
    │      │                    │
    │      ▼                    ▼
    │ ┌──────────┐  ┌─────────────────────────────────────┐
    │ │  asset   │  │            flint-core                │
    │ └────┬─────┘  │ (EntityId, Vec3, Transform, Hash)   │
    │      │        └─────────────────────────────────────┘
    │      │                    ▲
    └──────┴────────────────────┘
</code></pre>
<h2 id="dependency-details"><a class="header" href="#dependency-details">Dependency Details</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Depends On</th><th>Depended On By</th></tr>
</thead>
<tbody>
<tr><td><code>flint-core</code></td><td><em>(none)</em></td><td>all other crates</td></tr>
<tr><td><code>flint-schema</code></td><td>core</td><td>ecs, constraint</td></tr>
<tr><td><code>flint-ecs</code></td><td>core, schema</td><td>scene, query, render, constraint, runtime, physics, audio, animation, viewer, player, cli</td></tr>
<tr><td><code>flint-asset</code></td><td>core</td><td>import, cli</td></tr>
<tr><td><code>flint-import</code></td><td>core, asset</td><td>render, animation, viewer, cli, player</td></tr>
<tr><td><code>flint-query</code></td><td>core, ecs</td><td>constraint, cli</td></tr>
<tr><td><code>flint-scene</code></td><td>core, ecs, schema</td><td>viewer, player, cli</td></tr>
<tr><td><code>flint-constraint</code></td><td>core, ecs, schema, query</td><td>viewer, cli</td></tr>
<tr><td><code>flint-render</code></td><td>core, ecs, import</td><td>viewer, player, cli</td></tr>
<tr><td><code>flint-runtime</code></td><td>core, ecs</td><td>physics, audio, animation, player</td></tr>
<tr><td><code>flint-physics</code></td><td>core, ecs, runtime</td><td>player</td></tr>
<tr><td><code>flint-audio</code></td><td>core, ecs, runtime</td><td>player</td></tr>
<tr><td><code>flint-animation</code></td><td>core, ecs, import, runtime</td><td>player</td></tr>
<tr><td><code>flint-script</code></td><td>core, ecs, runtime</td><td>player</td></tr>
<tr><td><code>flint-asset-gen</code></td><td>core, asset, import</td><td>cli</td></tr>
<tr><td><code>flint-viewer</code></td><td>core, ecs, scene, schema, render, import, constraint</td><td>cli</td></tr>
<tr><td><code>flint-player</code></td><td>core, schema, ecs, scene, render, runtime, physics, audio, animation, script, import, asset</td><td><em>(binary entry point)</em></td></tr>
<tr><td><code>flint-cli</code></td><td>all crates</td><td><em>(binary entry point)</em></td></tr>
</tbody>
</table>
</div>
<h2 id="key-properties"><a class="header" href="#key-properties">Key Properties</a></h2>
<p><strong>Acyclic.</strong> The dependency graph has no cycles. This is enforced by Cargo and ensures clean compilation ordering.</p>
<p><strong>Layered.</strong> Crates form clear layers:</p>
<ol>
<li><strong>Core</strong> — fundamental types (<code>flint-core</code>)</li>
<li><strong>Schema</strong> — data definitions (<code>flint-schema</code>)</li>
<li><strong>Storage</strong> — entity and asset management (<code>flint-ecs</code>, <code>flint-asset</code>)</li>
<li><strong>Logic</strong> — query, scene, constraint, import, asset-gen</li>
<li><strong>Systems</strong> — render, runtime, physics, audio, animation, script</li>
<li><strong>Applications</strong> — viewer, player</li>
<li><strong>Interface</strong> — CLI binary (<code>flint-cli</code>), player binary (<code>flint-player</code>)</li>
</ol>
<p><strong>Two entry points.</strong> The CLI binary (<code>flint-cli</code>) serves scene authoring and validation workflows. The player binary (<code>flint-player</code>) serves interactive gameplay. Both share the same underlying crate hierarchy.</p>
<p><strong>Independent subsystems.</strong> The constraint system, asset system, physics system, audio system, animation system, script system, asset generation system, and render system don’t depend on each other. This means you can build and test each subsystem in isolation.</p>
<h2 id="external-dependencies"><a class="header" href="#external-dependencies">External Dependencies</a></h2>
<p>Key third-party crates used across the workspace:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Used By</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>hecs</code></td><td>flint-ecs</td><td>Underlying ECS implementation</td></tr>
<tr><td><code>toml</code></td><td>most crates</td><td>TOML parsing and serialization</td></tr>
<tr><td><code>serde</code></td><td>all crates</td><td>Serialization framework</td></tr>
<tr><td><code>pest</code></td><td>flint-query</td><td>PEG parser generator</td></tr>
<tr><td><code>wgpu</code></td><td>flint-render, flint-viewer, flint-player</td><td>GPU abstraction layer</td></tr>
<tr><td><code>winit</code></td><td>flint-render, flint-viewer, flint-runtime, flint-player</td><td>Window and input management</td></tr>
<tr><td><code>rapier3d</code></td><td>flint-physics</td><td>3D physics simulation</td></tr>
<tr><td><code>kira</code></td><td>flint-audio</td><td>Spatial audio engine</td></tr>
<tr><td><code>glam</code></td><td>flint-audio</td><td>Vec3/Quat types for Kira spatial positioning (via mint interop)</td></tr>
<tr><td><code>egui</code></td><td>flint-viewer</td><td>Immediate-mode GUI framework</td></tr>
<tr><td><code>clap</code></td><td>flint-cli, flint-player</td><td>Command-line argument parsing</td></tr>
<tr><td><code>thiserror</code></td><td>all library crates</td><td>Error derive macros</td></tr>
<tr><td><code>sha2</code></td><td>flint-core, flint-asset</td><td>SHA-256 hashing</td></tr>
<tr><td><code>gltf</code></td><td>flint-import</td><td>glTF file parsing (meshes, materials, skins, animations)</td></tr>
<tr><td><code>crossbeam</code></td><td>flint-physics</td><td>Channel-based event collection (Rapier)</td></tr>
<tr><td><code>rhai</code></td><td>flint-script</td><td>Embedded scripting language</td></tr>
<tr><td><code>ureq</code></td><td>flint-asset-gen</td><td>HTTP client for AI provider APIs</td></tr>
<tr><td><code>uuid</code></td><td>flint-asset-gen</td><td>Unique job identifiers</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<p>Flint’s development is organized into five phases. Each phase delivers a usable milestone that builds on the previous one.</p>
<h2 id="phase-1-foundation--cli--query--schema"><a class="header" href="#phase-1-foundation--cli--query--schema">Phase 1: Foundation — CLI + Query + Schema</a></h2>
<p><strong>Status: Complete</strong></p>
<p>The foundation phase established the core data model and CLI interface. An agent (or human) can create, query, and modify scenes entirely through commands.</p>
<p><strong>Delivered:</strong></p>
<ul>
<li><code>flint-core</code> — Entity IDs, content hashing, fundamental types</li>
<li><code>flint-schema</code> — Component registry, archetype definitions, TOML-based introspection</li>
<li><code>flint-ecs</code> — hecs integration with stable IDs, named entities, parent-child hierarchy</li>
<li><code>flint-scene</code> — TOML scene serialization and deserialization</li>
<li><code>flint-query</code> — PEG query language with pest parser</li>
<li><code>flint-cli</code> — CRUD operations for entities and scenes</li>
</ul>
<p><strong>Milestone:</strong> <code>flint entity create --archetype door</code> works. <code>flint query "entities"</code> returns results.</p>
<h2 id="phase-2-constraints--assets"><a class="header" href="#phase-2-constraints--assets">Phase 2: Constraints + Assets</a></h2>
<p><strong>Status: Complete</strong></p>
<p>The validation and asset management phase. Scenes can now be checked against declarative rules, and external files can be imported into a content-addressed store.</p>
<p><strong>Delivered:</strong></p>
<ul>
<li><code>flint-constraint</code> — Constraint definitions, validation engine, auto-fix with cascade detection</li>
<li><code>flint-asset</code> — Content-addressed storage (SHA-256), asset catalog with name/hash/type/tag indexing</li>
<li><code>flint-import</code> — glTF/GLB importer with mesh, material, and texture extraction</li>
</ul>
<p><strong>Milestone:</strong> <code>flint validate --fix</code> automatically fixes constraint violations. <code>flint asset import model.glb</code> stores and catalogs assets.</p>
<h2 id="phase-3-rendering--visual-validation"><a class="header" href="#phase-3-rendering--visual-validation">Phase 3: Rendering + Visual Validation</a></h2>
<p><strong>Status: Complete</strong></p>
<p>The visual validation phase. Physically-based rendering with a full-featured scene viewer.</p>
<p><strong>Delivered:</strong></p>
<ul>
<li><code>flint-render</code> — wgpu 23 PBR renderer with Cook-Torrance shading, cascaded shadow mapping, and glTF mesh rendering</li>
<li><code>flint-viewer</code> — egui-based GUI inspector with entity tree, component editing, and constraint overlay</li>
<li>Scene viewer with orbit camera, hot-reload via <code>serve --watch</code></li>
<li>Headless rendering for CI (<code>flint render --headless</code>)</li>
<li>Material system with roughness, metallic, emissive, and texture support</li>
</ul>
<p><strong>Milestone:</strong> <code>flint serve --watch</code> shows a live PBR scene with shadows that updates when files change.</p>
<h2 id="phase-4-interactive-runtime"><a class="header" href="#phase-4-interactive-runtime">Phase 4: Interactive Runtime</a></h2>
<p><strong>Status: Complete</strong></p>
<p>The game runtime phase. A playable game loop with physics, audio, animation, scripting, and interactive entities.</p>
<p><strong>Stage 1 — Game Loop + Physics: Complete</strong></p>
<ul>
<li><code>flint-runtime</code> — GameClock (fixed-timestep accumulator), InputState (keyboard/mouse with action bindings), EventBus, RuntimeSystem trait</li>
<li><code>flint-physics</code> — Rapier 3D integration: PhysicsWorld, PhysicsSync (TOML-to-Rapier bridge), CharacterController (kinematic first-person movement with gravity and jumping)</li>
<li><code>flint-player</code> — Standalone player binary with full game loop</li>
<li>First-person camera mode (backward-compatible with orbit)</li>
<li>CLI <code>play</code> command — <code>flint play &lt;scene&gt; [--schemas] [--fullscreen]</code></li>
<li>Physics schemas — <code>rigidbody.toml</code>, <code>collider.toml</code>, <code>character_controller.toml</code> components + <code>player.toml</code> archetype</li>
<li>Demo scene — walkable tavern with physics colliders on walls, floor, and furniture</li>
</ul>
<p><strong>Stage 2 — Audio: Complete</strong></p>
<ul>
<li><code>flint-audio</code> — Kira 0.11 integration: AudioEngine, AudioSync, AudioTrigger, AudioSystem</li>
<li>Spatial 3D audio with distance attenuation via SpatialTrackHandle</li>
<li>Non-spatial ambient loops on main track</li>
<li>Event-driven sound triggers (collision, interaction)</li>
<li>Audio component schemas — <code>audio_source.toml</code>, <code>audio_listener.toml</code>, <code>audio_trigger.toml</code></li>
<li>Graceful degradation when no audio device available (headless/CI)</li>
<li>Demo audio — CC0 OGG assets: fire crackle, ambient tavern, door open, glass clinks</li>
</ul>
<p><strong>Stage 3 — Animation: Complete</strong></p>
<ul>
<li><code>flint-animation</code> — Two-tier animation system:
<ul>
<li><strong>Tier 1: Property tweens</strong> — TOML-defined <code>.anim.toml</code> keyframe clips with Step/Linear/CubicSpline interpolation, <code>animator</code> component schema, event firing at keyframe times</li>
<li><strong>Tier 2: Skeletal animation</strong> — glTF skin/joint import via <code>flint-import</code>, GPU vertex skinning with storage buffer bone matrices, separate <code>SkinnedVertex</code> pipeline, crossfade blending between clips</li>
</ul>
</li>
<li><code>skeleton</code> component schema for glTF skin references</li>
<li>Skinned shadow mapping with dedicated shader entry point</li>
<li>Demo animations — bobbing platform (4s loop), door swing (0.8s), skeletal test scene</li>
</ul>
<p><strong>Stage 4 — Scripting: Complete</strong></p>
<ul>
<li><code>flint-script</code> — Rhai scripting engine with per-entity scopes and AST management</li>
<li>Entity API (read/write components, spawn/despawn, position/rotation, distance)</li>
<li>Input API (action pressed/just-pressed, mouse delta)</li>
<li>Audio API (play_sound, play_sound_at, stop_sound) via deferred ScriptCommand pattern</li>
<li>Animation API (play_clip, stop_clip, blend_to, set_anim_speed) via direct ECS writes</li>
<li>Math API (clamp, lerp, random, trig, atan2)</li>
<li>Event callbacks: <code>on_init</code>, <code>on_update</code>, <code>on_collision</code>, <code>on_trigger_enter/exit</code>, <code>on_action</code>, <code>on_interact</code></li>
<li>Hot-reload via file timestamp checking (keeps old AST on compile error)</li>
<li><code>script</code> component schema with <code>source</code> and <code>enabled</code> fields</li>
</ul>
<p><strong>Stage 5 — Integration: Complete</strong></p>
<ul>
<li><code>interactable</code> component schema (prompt_text, range, interaction_type, enabled)</li>
<li>Proximity-based interaction with <code>find_nearest_interactable()</code> scanning</li>
<li>egui HUD overlay: crosshair + interaction prompt text with fade in/out</li>
<li>NPC behavior scripts: bartender (wave + glass clink), patron (random fidget), mysterious stranger (ominous reactions)</li>
<li>Footstep sounds synced to player movement</li>
<li>Ambient event system (random sounds: glass clinks, chair creaks)</li>
<li>Full atmospheric tavern integration demo with scripts, audio, animation, and interactables</li>
</ul>
<p><strong>Milestone:</strong> <code>flint play tavern.scene.toml</code> launches a first-person walkable scene with physics, spatial audio, animation, scripted NPCs, and interactive objects.</p>
<h2 id="phase-5-ai-asset-pipeline"><a class="header" href="#phase-5-ai-asset-pipeline">Phase 5: AI Asset Pipeline</a></h2>
<p><strong>Status: Complete</strong></p>
<p>Integrated AI generation workflows for textures, meshes, and audio with style consistency and provenance tracking.</p>
<p><strong>Delivered:</strong></p>
<ul>
<li><code>flint-asset-gen</code> — pluggable <code>GenerationProvider</code> trait with four implementations:
<ul>
<li><strong>Flux</strong> — AI texture generation (PNG output)</li>
<li><strong>Meshy</strong> — text-to-3D model generation (GLB output, async job polling)</li>
<li><strong>ElevenLabs</strong> — AI sound effect and voice generation</li>
<li><strong>Mock</strong> — generates minimal valid files for testing without network access</li>
</ul>
</li>
<li><strong>Style guides</strong> — TOML-defined visual vocabulary (palette, materials, geometry constraints) that enriches generation prompts for consistent asset aesthetics</li>
<li><strong>Semantic asset definitions</strong> — <code>asset_def</code> component schema mapping intent to generation requests (description, material intent, wear level, size class)</li>
<li><strong>Batch scene resolution</strong> — <code>flint asset resolve</code> with strategies: <code>ai_generate</code>, <code>human_task</code>, <code>ai_then_human</code></li>
<li><strong>Model validation</strong> — <code>validate_model()</code> checks GLB geometry and materials against style constraints (triangle count, UVs, normals, roughness/metallic ranges)</li>
<li><strong>Build manifests</strong> — provenance tracking for all generated assets (provider, prompt, content hash)</li>
<li><strong>Layered configuration</strong> — <code>~/.flint/config.toml</code> &lt; <code>.flint/config.toml</code> &lt; environment variables for API keys and provider settings</li>
<li><strong>Runtime catalog integration</strong> — <code>PlayerApp</code> resolves assets by name through catalog → hash → content store → file fallback chain</li>
<li><strong>CLI commands</strong> — <code>flint asset generate</code>, <code>flint asset validate</code>, <code>flint asset manifest</code>, <code>flint asset regenerate</code>, <code>flint asset job status/list</code></li>
</ul>
<p><strong>Milestone:</strong> <code>flint asset generate texture -d "stone wall" --style medieval_tavern</code> produces a style-consistent texture, validates it, and stores it in the content-addressed catalog.</p>
<h2 id="beyond-phase-5"><a class="header" href="#beyond-phase-5">Beyond Phase 5</a></h2>
<p>These are ideas under consideration, not committed plans:</p>
<ul>
<li><strong>Networking</strong> — multiplayer support</li>
<li><strong>Post-processing</strong> — bloom, ambient occlusion, tone mapping, LOD</li>
<li><strong>Plugin system</strong> — third-party extensions</li>
<li><strong>Package manager</strong> — share schemas, constraints, and assets between projects</li>
<li><strong>WebAssembly</strong> — browser-based viewer and potentially runtime</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>All five phases of Flint are complete. Contributions are welcome in these areas:</p>
<ul>
<li><strong>Bug reports</strong> — file issues on GitHub</li>
<li><strong>Schema definitions</strong> — new component and archetype schemas</li>
<li><strong>Documentation</strong> — improvements to this guide</li>
<li><strong>Test coverage</strong> — additional unit and integration tests (217 tests across 18 crates)</li>
<li><strong>Constraint kinds</strong> — new validation rule types</li>
<li><strong>Physics</strong> — additional collider shapes, improved character controller behavior</li>
<li><strong>Rendering</strong> — post-processing effects, LOD, additional debug views</li>
<li><strong>Audio</strong> — additional audio formats, reverb zones, music system</li>
<li><strong>Animation</strong> — blend trees, additive blending, animation state machines</li>
<li><strong>Scripting</strong> — new Rhai API functions, script debugging tools, performance profiling</li>
<li><strong>AI generation</strong> — new provider integrations, improved style validation, prompt engineering</li>
</ul>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<pre><code class="language-bash">git clone https://github.com/chaps/flint.git
cd flint
cargo build
cargo test
cargo clippy
cargo fmt --check
</code></pre>
<h2 id="running-the-demo"><a class="header" href="#running-the-demo">Running the Demo</a></h2>
<pre><code class="language-bash"># Scene viewer with hot-reload
cargo run --bin flint -- serve demo/phase4_runtime.scene.toml --watch

# First-person walkable scene
cargo run --bin flint -- play demo/phase4_runtime.scene.toml
</code></pre>
<h2 id="code-style"><a class="header" href="#code-style">Code Style</a></h2>
<ul>
<li>Run <code>cargo fmt</code> before committing</li>
<li>Run <code>cargo clippy</code> and address warnings</li>
<li>Each crate has its own error type using <code>thiserror</code></li>
<li>Tests live alongside the code they test (<code>#[cfg(test)]</code> modules)</li>
<li>Prefer explicit over clever; readability over brevity</li>
</ul>
<h2 id="architecture-3"><a class="header" href="#architecture-3">Architecture</a></h2>
<p>The project is an 18-crate Cargo workspace. See the <a href="#architecture-overview">Architecture Overview</a> and <a href="#crate-dependency-graph">Crate Dependency Graph</a> for how the crates relate to each other. Key principles:</p>
<ul>
<li>Dependencies flow in one direction (binary crates at the top, <code>flint-core</code> at the bottom)</li>
<li>Components are dynamic <code>toml::Value</code>, not Rust types — schemas are runtime data</li>
<li>Two entry points: <code>flint-cli</code> (scene authoring) and <code>flint-player</code> (interactive gameplay)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
