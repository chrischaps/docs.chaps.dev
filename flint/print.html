<!DOCTYPE HTML>
<html lang="en" class="coal sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Flint Engine</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the Flint CLI-first, AI-agent-optimized 3D game engine">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom-8d5049aa.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "coal";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-54da5ca8.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-0981ad03.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('coal')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Flint Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/chaps/flint" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="flint-engine"><a class="header" href="#flint-engine">Flint Engine</a></h1>
<p><strong>A CLI-first, AI-agent-optimized 3D game engine written in Rust.</strong></p>
<p>Flint is a general-purpose 3D game engine designed from the ground up to provide an excellent interface for AI coding agents, while maintaining effective workflows for human developers. Unlike existing engines that optimize for GUI-driven workflows, Flint prioritizes programmatic interaction, introspection, and validation.</p>
<h2 id="the-core-idea"><a class="header" href="#the-core-idea">The Core Idea</a></h2>
<p>Current game engines are built around visual editors, drag-and-drop workflows, and GUI-heavy tooling. These become friction points when AI agents attempt to make changes programmatically — the agent ends up fighting against abstractions designed for human spatial reasoning and visual feedback loops.</p>
<p>Flint inverts this: <strong>the primary interface is CLI and code</strong>, with visual tools focused on <em>validating</em> results rather than <em>creating</em> them.</p>
<p>Every scene is a TOML file you can read, diff, and version. Every operation is a composable CLI command. Every piece of engine state is queryable as structured data. The viewer exists to answer one question: <em>“Did the agent do what I asked?”</em></p>
<h2 id="what-it-looks-like"><a class="header" href="#what-it-looks-like">What It Looks Like</a></h2>
<p>Create a scene, add entities, query them, and view the result — all from the command line:</p>
<pre><code class="language-bash"># Initialize a project
flint init my-game

# Create a scene and populate it
flint scene create levels/tavern.scene.toml --name "The Tavern"
flint entity create --archetype room --name "main_hall" --scene levels/tavern.scene.toml
flint entity create --archetype door --name "front_door" --parent "main_hall" --scene levels/tavern.scene.toml

# Query what you've built
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml

# Validate against constraints
flint validate levels/tavern.scene.toml --fix --dry-run

# See it in 3D with PBR rendering
flint serve levels/tavern.scene.toml --watch

# Walk around in first person
flint play levels/tavern.scene.toml
</code></pre>
<h2 id="current-status"><a class="header" href="#current-status">Current Status</a></h2>
<p>Flint is in active development through Phase 4. Phases 1–3 are complete, and Phase 4 Stages 1–3 (Game Loop, Audio, Animation) are implemented. The engine currently supports:</p>
<ul>
<li><strong>Entity CRUD</strong> via CLI with archetype-based creation</li>
<li><strong>Scene serialization</strong> in human-readable TOML</li>
<li><strong>Query language</strong> for filtering and inspecting entities</li>
<li><strong>Schema system</strong> for component and archetype definitions</li>
<li><strong>Constraint validation</strong> with auto-fix capabilities</li>
<li><strong>Asset management</strong> with content-addressed storage and glTF import</li>
<li><strong>PBR renderer</strong> with Cook-Torrance shading, cascaded shadow mapping, and glTF mesh rendering</li>
<li><strong>GPU skeletal animation</strong> with glTF skin/joint import, vertex skinning, and crossfade blending</li>
<li><strong>egui inspector</strong> with entity tree, component editing, and constraint overlay</li>
<li><strong>Hot-reload viewer</strong> that watches for file changes</li>
<li><strong>Headless rendering</strong> for CI and automated screenshots</li>
<li><strong>Physics simulation</strong> via Rapier 3D with kinematic character controller</li>
<li><strong>First-person gameplay</strong> with WASD movement, mouse look, jumping, and sprinting</li>
<li><strong>Game loop</strong> with fixed-timestep accumulator for deterministic physics</li>
<li><strong>Spatial audio</strong> via Kira with 3D positioned sounds, ambient loops, and event-driven triggers</li>
<li><strong>Property animation</strong> with TOML-defined keyframe clips (Step, Linear, CubicSpline interpolation)</li>
<li><strong>Skeletal animation</strong> with glTF skin import, GPU bone matrix skinning, and crossfade blending</li>
</ul>
<p>See the <a href="#roadmap">Roadmap</a> for what’s planned next.</p>
<h2 id="who-is-this-for"><a class="header" href="#who-is-this-for">Who Is This For?</a></h2>
<ul>
<li><strong>AI agent developers</strong> building game content programmatically</li>
<li><strong>Technical game developers</strong> who prefer code over visual editors</li>
<li><strong>Tooling enthusiasts</strong> who want to compose game development operations</li>
<li><strong>Rust game developers</strong> looking for a deterministic, introspectable engine</li>
</ul>
<h2 id="reading-this-guide"><a class="header" href="#reading-this-guide">Reading This Guide</a></h2>
<ul>
<li>Start with <a href="#why-flint">Why Flint?</a> to understand the motivation</li>
<li>Follow the <a href="#installation">Getting Started</a> guide to build from source and create your first project</li>
<li>Explore <a href="#entities-and-ecs">Core Concepts</a> to learn about the engine’s systems</li>
<li>Check the <a href="#architecture-overview">Architecture</a> section if you want to understand the codebase</li>
<li>Browse the <a href="/flint/api/flint_core">API Reference</a> for per-crate Rust documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="why-flint"><a class="header" href="#why-flint">Why Flint?</a></h1>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Game engines today — Unity, Unreal, Godot — are designed around visual editors. You drag objects into scenes, connect nodes in graphs, click through property inspectors. These workflows are excellent for humans using a mouse, but they create friction in two growing scenarios:</p>
<ol>
<li>
<p><strong>AI agents building game content.</strong> When an AI coding agent needs to place a door in a scene, it shouldn’t need to simulate mouse clicks on a GUI. It should issue a command and get structured feedback.</p>
</li>
<li>
<p><strong>Automation and CI pipelines.</strong> Validating a scene, running regression tests on visual output, or batch-processing hundreds of entities — these tasks fight against editor-centric architectures.</p>
</li>
</ol>
<p>The core tension: existing engines treat programmatic access as a <em>secondary</em> concern. The API exists, but it’s bolted onto a system designed for spatial interaction. Scene formats are binary or semi-readable. Introspection is limited. Determinism is not guaranteed.</p>
<h2 id="the-thesis"><a class="header" href="#the-thesis">The Thesis</a></h2>
<p>Flint starts from the opposite assumption: <strong>the primary interface is CLI and code</strong>. Visual tools are for <em>validation</em>, not <em>creation</em>.</p>
<p>This doesn’t mean Flint is hostile to humans. It means every operation flows through a composable, scriptable interface first. If you can do it in the CLI, you can automate it. If you can automate it, an AI agent can do it. The viewer is the place where a human confirms: “Yes, that’s what I wanted.”</p>
<h2 id="what-this-enables"><a class="header" href="#what-this-enables">What This Enables</a></h2>
<h3 id="for-ai-agents"><a class="header" href="#for-ai-agents">For AI agents</a></h3>
<p>An agent working with Flint has a clean contract:</p>
<ul>
<li>Issue CLI commands, get structured JSON/TOML responses</li>
<li>Query any aspect of engine state with a SQL-inspired language</li>
<li>Validate work against declarative constraint rules</li>
<li>Produce visual artifacts (headless renders) for verification</li>
</ul>
<p>No simulated GUI interaction. No screen scraping. No ambiguous visual state.</p>
<h3 id="for-humans"><a class="header" href="#for-humans">For humans</a></h3>
<p>A developer working with Flint gets:</p>
<ul>
<li>Scene files that are human-readable TOML, easily diffable in git</li>
<li>A query language for exploring what’s in a scene without opening an editor</li>
<li>Constraint rules that serve as living documentation of what a “correct” scene looks like</li>
<li>A hot-reload viewer that updates in real-time as files change</li>
</ul>
<h3 id="for-teams"><a class="header" href="#for-teams">For teams</a></h3>
<p>A team using Flint gets:</p>
<ul>
<li>Deterministic builds — same inputs always produce identical outputs</li>
<li>Text-based formats that merge cleanly in version control</li>
<li>Structured output for CI pipelines and automated testing</li>
<li>A shared vocabulary between human developers and AI tools</li>
</ul>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>Traditional Engines</th><th>Flint</th></tr>
</thead>
<tbody>
<tr><td>Primary interface</td><td>GUI editor</td><td>CLI</td></tr>
<tr><td>Scene format</td><td>Binary or semi-text</td><td>TOML (fully text)</td></tr>
<tr><td>Programmatic API</td><td>Secondary</td><td>Primary</td></tr>
<tr><td>Introspection</td><td>Limited</td><td>Full (query language)</td></tr>
<tr><td>Deterministic builds</td><td>Generally no</td><td>Yes</td></tr>
<tr><td>AI-agent optimized</td><td>No</td><td>Yes</td></tr>
<tr><td>Validation</td><td>Runtime errors</td><td>Declarative constraints</td></tr>
</tbody>
</table>
</div>
<h2 id="the-name"><a class="header" href="#the-name">The Name</a></h2>
<p>Flint is a tool for starting fires. Simple, reliable, fundamental. Strike it and something sparks into existence. That’s the idea: minimal friction between intent and result.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h1>
<p>Flint’s architecture follows six principles that guide every design decision. They are listed in priority order — when principles conflict, higher-ranked ones win.</p>
<h2 id="1-cli-first"><a class="header" href="#1-cli-first">1. CLI-First</a></h2>
<p>Every operation is expressible as a composable command. There is no operation that <em>requires</em> a GUI. The CLI is the source of truth for what the engine can do.</p>
<p>This means:</p>
<ul>
<li>All commands accept flags for output format (<code>--format json</code>, <code>--format toml</code>)</li>
<li>Commands compose via pipes and standard shell tooling</li>
<li>Batch operations are first-class, not afterthoughts</li>
<li>The viewer is a <em>consumer</em> of state, not a <em>producer</em> of it</li>
</ul>
<h2 id="2-introspectable"><a class="header" href="#2-introspectable">2. Introspectable</a></h2>
<p>You can query any aspect of engine state as structured data. Nothing is hidden behind opaque handles or binary blobs.</p>
<pre><code class="language-bash"># What entities exist?
flint query "entities where archetype == 'door'"

# What does a door look like?
flint schema door

# What would this change break?
flint validate levels/tavern.scene.toml --fix --dry-run
</code></pre>
<p>The query language is the same whether you’re exploring interactively or writing constraint rules. Learn it once, use it everywhere.</p>
<h2 id="3-deterministic"><a class="header" href="#3-deterministic">3. Deterministic</a></h2>
<p>Same inputs always produce identical outputs. No hidden state, no ambient randomness, no order-dependent behavior.</p>
<ul>
<li>Entity IDs are stable across save/load cycles</li>
<li>Procedural generation uses explicit seeds</li>
<li>Build manifests record exact asset hashes</li>
<li>Headless renders are reproducible for regression testing</li>
</ul>
<h2 id="4-text-based"><a class="header" href="#4-text-based">4. Text-Based</a></h2>
<p>Scene and asset formats are human-readable, machine-parseable, and diffable. TOML is the primary format throughout.</p>
<pre><code class="language-toml">[entities.front_door]
archetype = "door"
parent = "main_hall"

[entities.front_door.transform]
position = [5, 0, 0]

[entities.front_door.door]
style = "hinged"
locked = false
</code></pre>
<p>This isn’t just about readability — it’s about <em>collaboration</em>. Text files merge cleanly in version control. Diffs are meaningful. AI agents can read and write them directly.</p>
<h2 id="5-constraint-driven"><a class="header" href="#5-constraint-driven">5. Constraint-Driven</a></h2>
<p>Declarative rules define what a valid scene looks like. The engine validates against these rules and can optionally auto-fix violations.</p>
<p>Constraints serve multiple roles:</p>
<ul>
<li><strong>Validation</strong> — catch errors before they become runtime bugs</li>
<li><strong>Documentation</strong> — constraints describe what “correct” means</li>
<li><strong>Automation</strong> — auto-fix rules handle routine corrections</li>
<li><strong>Communication</strong> — constraints are a shared contract between human and AI</li>
</ul>
<h2 id="6-hybrid-workflows"><a class="header" href="#6-hybrid-workflows">6. Hybrid Workflows</a></h2>
<p>Humans and AI agents collaborate effectively on the same project. Neither workflow is an afterthought.</p>
<p>The typical loop:</p>
<ol>
<li>An AI agent creates or modifies scene content via CLI</li>
<li>Constraints validate the changes automatically</li>
<li>A human reviews the result in the viewer</li>
<li>Feedback flows back to the agent as structured data</li>
</ol>
<p>This principle ensures Flint doesn’t optimize so hard for agents that humans can’t use it, or so hard for humans that agents can’t automate it.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-first-workflow"><a class="header" href="#cli-first-workflow">CLI-First Workflow</a></h1>
<blockquote>
<p>This page is a stub. Content coming soon.</p>
</blockquote>
<p>The CLI-first principle means every engine operation is available as a composable command. This page will cover:</p>
<ul>
<li>How CLI commands compose with pipes and shell tooling</li>
<li>Structured output formats (JSON, TOML) for machine consumption</li>
<li>Transaction mode for atomic multi-step operations</li>
<li>Comparison with GUI-driven workflows in other engines</li>
<li>Practical patterns for scripting scene construction</li>
</ul>
<p>See <a href="#design-principles">Design Principles</a> for an overview of this philosophy.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ai-agent-interface"><a class="header" href="#ai-agent-interface">AI Agent Interface</a></h1>
<blockquote>
<p>This page is a stub. Content coming soon.</p>
</blockquote>
<p>Flint is designed to be an excellent interface for AI coding agents. This page will cover:</p>
<ul>
<li>Why AI agents struggle with GUI-based game engines</li>
<li>The structured input/output contract Flint provides</li>
<li>How the query language enables agent introspection</li>
<li>Constraint validation as an automated feedback loop</li>
<li>Headless rendering for visual verification</li>
<li>Example agent workflows for common tasks</li>
</ul>
<p>See the <a href="#ai-agent-workflow">AI Agent Workflow</a> guide for practical examples.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Flint is built from source using the Rust toolchain. There are no pre-built binaries yet.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><strong>Rust</strong> (stable, 1.75+) — install from <a href="https://rustup.rs/">rustup.rs</a></li>
<li><strong>Git</strong> — for cloning the repository</li>
<li>A GPU with <strong>Vulkan</strong>, <strong>Metal</strong>, or <strong>DX12</strong> support (for the renderer and viewer)</li>
</ul>
<h2 id="build-from-source"><a class="header" href="#build-from-source">Build from Source</a></h2>
<p>Clone the repository and build in release mode:</p>
<pre><code class="language-bash">git clone https://github.com/chaps/flint.git
cd flint
cargo build --release
</code></pre>
<p>The binary is at <code>target/release/flint</code> (or <code>target/release/flint.exe</code> on Windows).</p>
<h2 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h2>
<pre><code class="language-bash">cargo run --bin flint -- --version
</code></pre>
<p>You should see the Flint version string.</p>
<h2 id="running-without-installing"><a class="header" href="#running-without-installing">Running Without Installing</a></h2>
<p>You can run Flint directly through Cargo without installing it system-wide:</p>
<pre><code class="language-bash">cargo run --bin flint -- &lt;command&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-bash">cargo run --bin flint -- init my-game
cargo run --bin flint -- serve demo/showcase.scene.toml --watch
</code></pre>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<p>To verify everything is working:</p>
<pre><code class="language-bash">cargo test
</code></pre>
<p>This runs the full test suite across all crates.</p>
<h2 id="optional-add-to-path"><a class="header" href="#optional-add-to-path">Optional: Add to PATH</a></h2>
<p>To use <code>flint</code> directly without <code>cargo run</code>:</p>
<pre><code class="language-bash">cargo install --path crates/flint-cli
</code></pre>
<p>Or copy the release binary to a directory on your PATH.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What’s Next</a></h2>
<p>With Flint built, follow <a href="#your-first-project">Your First Project</a> to create a scene from scratch.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-project"><a class="header" href="#your-first-project">Your First Project</a></h1>
<p>This guide walks through creating a Flint project and building a simple scene using only CLI commands.</p>
<h2 id="initialize-a-project"><a class="header" href="#initialize-a-project">Initialize a Project</a></h2>
<pre><code class="language-bash">flint init my-tavern
</code></pre>
<p>This creates a project directory with the standard structure:</p>
<pre><code>my-tavern/
├── schemas/
│   ├── components/
│   │   ├── transform.toml
│   │   ├── bounds.toml
│   │   └── door.toml
│   ├── archetypes/
│   │   ├── room.toml
│   │   ├── door.toml
│   │   ├── furniture.toml
│   │   └── character.toml
│   └── constraints/
│       └── basics.toml
├── levels/
└── assets/
</code></pre>
<p>The <code>schemas/</code> directory contains default component definitions, archetype bundles, and constraint rules. You’ll modify and extend these as your project grows.</p>
<h2 id="create-a-scene"><a class="header" href="#create-a-scene">Create a Scene</a></h2>
<pre><code class="language-bash">flint scene create my-tavern/levels/tavern.scene.toml --name "The Rusty Flint Tavern"
</code></pre>
<p>This creates an empty scene file:</p>
<pre><code class="language-toml">[scene]
name = "The Rusty Flint Tavern"
version = "1.0"
</code></pre>
<h2 id="add-rooms"><a class="header" href="#add-rooms">Add Rooms</a></h2>
<p>Build out the space with room entities:</p>
<pre><code class="language-bash">flint entity create --archetype room --name "main_hall" \
    --scene my-tavern/levels/tavern.scene.toml \
    --schemas my-tavern/schemas \
    --props '{"transform":{"position":[0,0,0]},"bounds":{"min":[-7,0,-5],"max":[7,4,5]}}'
</code></pre>
<p>The <code>--archetype room</code> flag tells Flint to create an entity with the components defined in <code>schemas/archetypes/room.toml</code> (transform + bounds). The <code>--props</code> flag provides the specific values.</p>
<p>Add a kitchen connected to the main hall:</p>
<pre><code class="language-bash">flint entity create --archetype room --name "kitchen" \
    --parent "main_hall" \
    --scene my-tavern/levels/tavern.scene.toml \
    --schemas my-tavern/schemas \
    --props '{"transform":{"position":[0,0,-9]},"bounds":{"min":[-4,0,-3],"max":[4,3.5,3]}}'
</code></pre>
<p>The <code>--parent</code> flag establishes a hierarchy — the kitchen is a child of the main hall.</p>
<h2 id="add-a-door"><a class="header" href="#add-a-door">Add a Door</a></h2>
<pre><code class="language-bash">flint entity create --archetype door --name "front_entrance" \
    --parent "main_hall" \
    --scene my-tavern/levels/tavern.scene.toml \
    --schemas my-tavern/schemas \
    --props '{"transform":{"position":[0,0,5]},"door":{"style":"hinged","locked":false}}'
</code></pre>
<h2 id="query-your-scene"><a class="header" href="#query-your-scene">Query Your Scene</a></h2>
<p>See what you’ve built:</p>
<pre><code class="language-bash">flint query "entities" --scene my-tavern/levels/tavern.scene.toml
</code></pre>
<p>Filter for specific archetypes:</p>
<pre><code class="language-bash">flint query "entities where archetype == 'door'" --scene my-tavern/levels/tavern.scene.toml
</code></pre>
<h2 id="inspect-the-scene-file"><a class="header" href="#inspect-the-scene-file">Inspect the Scene File</a></h2>
<p>The scene is plain TOML. Open <code>my-tavern/levels/tavern.scene.toml</code> and you’ll see:</p>
<pre><code class="language-toml">[scene]
name = "The Rusty Flint Tavern"
version = "1.0"

[entities.main_hall]
archetype = "room"

[entities.main_hall.transform]
position = [0, 0, 0]

[entities.main_hall.bounds]
min = [-7, 0, -5]
max = [7, 4, 5]

[entities.kitchen]
archetype = "room"
parent = "main_hall"

[entities.kitchen.transform]
position = [0, 0, -9]

[entities.kitchen.bounds]
min = [-4, 0, -3]
max = [4, 3.5, 3]

[entities.front_entrance]
archetype = "door"
parent = "main_hall"

[entities.front_entrance.transform]
position = [0, 0, 5]

[entities.front_entrance.door]
style = "hinged"
locked = false
</code></pre>
<p>Everything is readable, editable, and diffable. You can modify this file directly — the CLI isn’t the only way to edit scenes.</p>
<h2 id="view-it"><a class="header" href="#view-it">View It</a></h2>
<p>Launch the hot-reload viewer:</p>
<pre><code class="language-bash">flint serve my-tavern/levels/tavern.scene.toml --watch --schemas my-tavern/schemas
</code></pre>
<p>A window opens showing your scene as colored boxes:</p>
<ul>
<li><strong>Blue</strong> wireframes for rooms</li>
<li><strong>Orange</strong> boxes for doors</li>
<li><strong>Green</strong> boxes for furniture</li>
<li><strong>Yellow</strong> boxes for characters</li>
</ul>
<p>The viewer hot-reloads — any change to the scene file (from the CLI, a text editor, or an AI agent) updates the view instantly.</p>
<p><strong>Camera controls:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>Left-drag</td><td>Orbit</td></tr>
<tr><td>Right-drag</td><td>Pan</td></tr>
<tr><td>Scroll</td><td>Zoom</td></tr>
<tr><td>Space</td><td>Reset camera</td></tr>
<tr><td>R</td><td>Force reload</td></tr>
<tr><td>Escape</td><td>Quit</td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What’s Next</a></h2>
<ul>
<li><a href="#your-first-scene">Your First Scene</a> dives deeper into scene file structure</li>
<li><a href="#querying-entities">Querying Entities</a> covers the query language</li>
<li><a href="#building-a-tavern">Building a Tavern</a> walks through a complete scene build</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-scene"><a class="header" href="#your-first-scene">Your First Scene</a></h1>
<p>A Flint scene is a TOML file describing entities, their components, and their relationships. This page explains the scene format by building one from scratch.</p>
<h2 id="scene-structure"><a class="header" href="#scene-structure">Scene Structure</a></h2>
<p>Every scene file has two sections: metadata and entities.</p>
<pre><code class="language-toml"># Metadata
[scene]
name = "My Scene"
version = "1.0"
description = "An optional description"

# Entities
[entities.my_entity]
archetype = "room"

[entities.my_entity.transform]
position = [0, 0, 0]
</code></pre>
<p>The <code>[scene]</code> table holds metadata. Everything under <code>[entities.*]</code> defines the objects in your world.</p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<p>An entity is a named thing in the scene. Its name is the key under <code>[entities]</code>:</p>
<pre><code class="language-toml">[entities.main_hall]
archetype = "room"
</code></pre>
<p>Entities can optionally have:</p>
<ul>
<li>An <strong>archetype</strong> — a schema-defined bundle of components</li>
<li>A <strong>parent</strong> — another entity this one is attached to</li>
<li><strong>Components</strong> — data tables nested under the entity</li>
</ul>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>Components are data attached to entities. They’re defined as nested TOML tables:</p>
<pre><code class="language-toml">[entities.main_hall]
archetype = "room"

[entities.main_hall.transform]
position = [0, 0, 0]

[entities.main_hall.bounds]
min = [-7, 0, -5]
max = [7, 4, 5]
</code></pre>
<p>The <code>transform</code> and <code>bounds</code> components are defined by schema files in <code>schemas/components/</code>. The schema tells Flint what fields are valid and what types they are.</p>
<h2 id="parent-child-relationships"><a class="header" href="#parent-child-relationships">Parent-Child Relationships</a></h2>
<p>Entities form hierarchies through the <code>parent</code> field:</p>
<pre><code class="language-toml">[entities.main_hall]
archetype = "room"

[entities.main_hall.transform]
position = [0, 0, 0]

[entities.kitchen]
archetype = "room"
parent = "main_hall"

[entities.kitchen.transform]
position = [0, 0, -9]
</code></pre>
<p>The kitchen is a child of the main hall. In the viewer, child transforms are relative to their parent.</p>
<h2 id="a-complete-example"><a class="header" href="#a-complete-example">A Complete Example</a></h2>
<p>Here’s a small but complete scene — a room with a door and a table:</p>
<pre><code class="language-toml">[scene]
name = "Simple Room"
version = "1.0"

[entities.room]
archetype = "room"

[entities.room.transform]
position = [0, 0, 0]

[entities.room.bounds]
min = [-5, 0, -5]
max = [5, 3, 5]

[entities.door]
archetype = "door"
parent = "room"

[entities.door.transform]
position = [0, 0, 5]

[entities.door.door]
style = "hinged"
locked = false
open_angle = 90.0

[entities.table]
archetype = "furniture"
parent = "room"

[entities.table.transform]
position = [0, 0, 0]

[entities.table.bounds]
min = [-0.6, 0, -0.6]
max = [0.6, 0.8, 0.6]
</code></pre>
<h2 id="editing-scenes"><a class="header" href="#editing-scenes">Editing Scenes</a></h2>
<p>You can edit scene files in three ways:</p>
<ol>
<li><strong>CLI commands</strong> — <code>flint entity create</code>, <code>flint entity delete</code>, etc.</li>
<li><strong>Text editor</strong> — open the TOML file directly</li>
<li><strong>Programmatically</strong> — any tool that can write TOML</li>
</ol>
<p>All three approaches produce the same result. The <code>flint serve --watch</code> viewer detects changes from any source and reloads automatically.</p>
<h2 id="validating-scenes"><a class="header" href="#validating-scenes">Validating Scenes</a></h2>
<p>Run the constraint checker to verify your scene is well-formed:</p>
<pre><code class="language-bash">flint validate levels/my-scene.scene.toml --schemas schemas
</code></pre>
<p>This checks your scene against the rules defined in <code>schemas/constraints/</code>. See <a href="#constraints">Constraints</a> for details.</p>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What’s Next</a></h2>
<ul>
<li><a href="#entities-and-ecs">Entities and ECS</a> explains the entity-component system</li>
<li><a href="#schemas">Schemas</a> covers how components and archetypes are defined</li>
<li><a href="#scenes">Scenes</a> goes deeper into the scene system internals</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="querying-entities"><a class="header" href="#querying-entities">Querying Entities</a></h1>
<blockquote>
<p>This page is a stub. Content coming soon.</p>
</blockquote>
<p>Flint includes a SQL-inspired query language for filtering and inspecting entities. This page will cover:</p>
<ul>
<li>Basic query syntax: <code>entities where &lt;condition&gt;</code></li>
<li>Comparison operators: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>contains</code></li>
<li>Querying by archetype, component values, and nested fields</li>
<li>Output formats: JSON and TOML</li>
<li>Combining queries with shell tools (<code>jq</code>, pipes)</li>
</ul>
<p>For a full reference, see <a href="#queries">Queries</a>.</p>
<p>Quick example:</p>
<pre><code class="language-bash">flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml
flint query "entities where door.locked == true" --scene levels/tavern.scene.toml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-scene-viewer"><a class="header" href="#the-scene-viewer">The Scene Viewer</a></h1>
<p>The Flint viewer is a real-time 3D window for validating scenes. It renders your scene with full PBR shading and shadows, and provides an egui inspector panel for browsing entities and editing component properties.</p>
<h2 id="launching-the-viewer"><a class="header" href="#launching-the-viewer">Launching the Viewer</a></h2>
<pre><code class="language-bash">flint serve levels/tavern.scene.toml --watch --schemas schemas
</code></pre>
<p>The <code>--watch</code> flag enables hot-reload: edit the scene TOML file, and the viewer re-parses and re-renders automatically. The entire file is re-parsed on each change (not incremental), which keeps the implementation simple and avoids synchronization issues.</p>
<h2 id="camera-controls"><a class="header" href="#camera-controls">Camera Controls</a></h2>
<p>The viewer uses an orbit camera that rotates around a focus point:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>Left-drag</td><td>Orbit around focus</td></tr>
<tr><td>Right-drag</td><td>Pan the view</td></tr>
<tr><td>Scroll</td><td>Zoom in/out</td></tr>
<tr><td>Space</td><td>Reset camera</td></tr>
<tr><td>R</td><td>Force reload</td></tr>
<tr><td>Escape</td><td>Quit</td></tr>
</tbody>
</table>
</div>
<h2 id="the-inspector-panel"><a class="header" href="#the-inspector-panel">The Inspector Panel</a></h2>
<p>The egui-based inspector panel (on the left side of the viewer) provides:</p>
<ul>
<li><strong>Entity tree</strong> — hierarchical list of all entities in the scene, reflecting parent-child relationships</li>
<li><strong>Component editor</strong> — select an entity to view and edit its component values</li>
<li><strong>Constraint overlay</strong> — validation results from <code>flint-constraint</code>, highlighting any rule violations</li>
</ul>
<h2 id="rendering-features"><a class="header" href="#rendering-features">Rendering Features</a></h2>
<p>The viewer renders scenes with the same PBR pipeline used by the player:</p>
<ul>
<li>Cook-Torrance physically-based shading</li>
<li>Cascaded shadow mapping from directional lights</li>
<li>glTF mesh rendering with material support</li>
<li>Debug rendering modes (cycle with <strong>F1</strong>)</li>
<li>Shadow toggle (<strong>F4</strong>)</li>
<li>Fullscreen toggle (<strong>F11</strong>)</li>
</ul>
<h2 id="playing-a-scene"><a class="header" href="#playing-a-scene">Playing a Scene</a></h2>
<p>To experience a scene in first-person with physics, use <code>play</code> instead of <code>serve</code>:</p>
<pre><code class="language-bash">flint play levels/tavern.scene.toml
</code></pre>
<p>See the <a href="#cli-reference">CLI Reference</a> for full <code>play</code> command details and controls.</p>
<h2 id="headless-rendering"><a class="header" href="#headless-rendering">Headless Rendering</a></h2>
<p>For CI pipelines and automated screenshots, render to PNG without opening a window:</p>
<pre><code class="language-bash">flint render levels/tavern.scene.toml --output preview.png --width 1920 --height 1080
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="entities-and-ecs"><a class="header" href="#entities-and-ecs">Entities and ECS</a></h1>
<p>Flint uses an Entity-Component-System (ECS) architecture, built on top of the <a href="https://crates.io/crates/hecs">hecs</a> crate. This page explains how entities, components, and IDs work in Flint.</p>
<h2 id="what-is-ecs"><a class="header" href="#what-is-ecs">What Is ECS?</a></h2>
<p>In an ECS architecture:</p>
<ul>
<li><strong>Entities</strong> are unique identifiers (not objects with methods)</li>
<li><strong>Components</strong> are pure data attached to entities</li>
<li><strong>Systems</strong> are logic that operates on entities with specific component combinations</li>
</ul>
<p>Flint’s twist: components are <strong>dynamic</strong>. Instead of being Rust structs compiled into the engine, they’re defined at runtime as TOML schema files and stored as <code>toml::Value</code>. This means you can define new component types without recompiling the engine.</p>
<h2 id="entity-ids"><a class="header" href="#entity-ids">Entity IDs</a></h2>
<p>Every entity gets a stable <code>EntityId</code> — a 64-bit integer that:</p>
<ul>
<li>Is unique within a scene</li>
<li>Never gets recycled (monotonically increasing)</li>
<li>Persists across save/load cycles</li>
<li>Is deterministic (the same scene always produces the same IDs)</li>
</ul>
<p>Internally, Flint maintains a bidirectional map (<code>BiMap</code>) between <code>EntityId</code> values and hecs <code>Entity</code> handles. This allows efficient lookup in both directions.</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From flint-core
pub struct EntityId(pub u64);
<span class="boring">}</span></code></pre>
<p>When loading a saved scene, the ID counter is adjusted to be higher than any existing ID, preventing collisions when new entities are created.</p>
<h2 id="named-entities"><a class="header" href="#named-entities">Named Entities</a></h2>
<p>While entity IDs are the internal identifier, entities in Flint are also <strong>named</strong>. The name is the key in the scene file:</p>
<pre><code class="language-toml">[entities.front_door]     # "front_door" is the name
archetype = "door"
</code></pre>
<p>Names must be unique within a scene. They’re used in:</p>
<ul>
<li>CLI commands: <code>--name "front_door"</code></li>
<li>Parent references: <code>parent = "main_hall"</code></li>
<li>Query results</li>
<li>Constraint violation messages</li>
</ul>
<h2 id="components-as-dynamic-data"><a class="header" href="#components-as-dynamic-data">Components as Dynamic Data</a></h2>
<p>In most ECS implementations, components are Rust structs:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// NOT how Flint works
struct Transform { position: Vec3, rotation: Vec3 }
<span class="boring">}</span></code></pre>
<p>In Flint, components are <code>toml::Value</code> maps, defined by schema files:</p>
<pre><code class="language-toml"># schemas/components/transform.toml
[component.transform]
description = "Position and rotation in 3D space"

[component.transform.fields]
position = { type = "vec3", default = [0, 0, 0] }
rotation = { type = "vec3", default = [0, 0, 0] }
scale = { type = "vec3", default = [1, 1, 1] }
</code></pre>
<p>This design trades some type safety and performance for flexibility — archetypes and components can be defined, modified, and extended without touching Rust code.</p>
<h2 id="parent-child-relationships-1"><a class="header" href="#parent-child-relationships-1">Parent-Child Relationships</a></h2>
<p>Entities can form hierarchies. A child entity references its parent by name:</p>
<pre><code class="language-toml">[entities.kitchen]
archetype = "room"
parent = "main_hall"
</code></pre>
<p>The ECS layer tracks these relationships, enabling:</p>
<ul>
<li>Hierarchical transforms (child positions are relative to parent)</li>
<li>Tree queries (“find all children of main_hall”)</li>
<li>Cascading operations (deleting a parent removes children)</li>
</ul>
<h2 id="archetypes"><a class="header" href="#archetypes">Archetypes</a></h2>
<p>An archetype is a named bundle of components that defines an entity “type”:</p>
<pre><code class="language-toml"># schemas/archetypes/door.toml
[archetype.door]
description = "A door entity"
components = ["transform", "door"]

[archetype.door.defaults.door]
style = "hinged"
locked = false
</code></pre>
<p>When you create an entity with <code>--archetype door</code>, Flint ensures it has the required components and fills in defaults for any missing values.</p>
<p>Archetypes are not rigid types — an entity can have components beyond what its archetype specifies. The archetype defines the <em>minimum</em> set.</p>
<h2 id="working-with-entities-via-cli"><a class="header" href="#working-with-entities-via-cli">Working with Entities via CLI</a></h2>
<pre><code class="language-bash"># Create an entity
flint entity create --archetype door --name "vault_door" \
    --scene levels/dungeon.scene.toml \
    --schemas schemas \
    --props '{"transform":{"position":[0,0,0]},"door":{"locked":true}}'

# Delete an entity
flint entity delete --name "vault_door" --scene levels/dungeon.scene.toml

# List entities in a scene
flint query "entities" --scene levels/dungeon.scene.toml

# Filter by archetype
flint query "entities where archetype == 'door'" --scene levels/dungeon.scene.toml
</code></pre>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="#schemas">Schemas</a> — how components and archetypes are defined</li>
<li><a href="#scenes">Scenes</a> — how entities are serialized to TOML</li>
<li><a href="#queries">Queries</a> — how to filter and inspect entities</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="schemas"><a class="header" href="#schemas">Schemas</a></h1>
<p>Schemas define the structure of your game world. They specify what components exist, what fields they contain, and how they bundle together into archetypes. Schemas are TOML files stored in the <code>schemas/</code> directory of your project.</p>
<h2 id="component-schemas"><a class="header" href="#component-schemas">Component Schemas</a></h2>
<p>A component schema defines a reusable data type. Components live in <code>schemas/components/</code>:</p>
<pre><code class="language-toml"># schemas/components/door.toml
[component.door]
description = "A door that can connect spaces"

[component.door.fields]
style = { type = "enum", values = ["hinged", "sliding", "rotating"], default = "hinged" }
locked = { type = "bool", default = false }
open_angle = { type = "f32", default = 90.0, min = 0.0, max = 180.0 }
</code></pre>
<h3 id="field-types"><a class="header" href="#field-types">Field Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>bool</code></td><td>Boolean</td><td><code>true</code> / <code>false</code></td></tr>
<tr><td><code>i32</code></td><td>32-bit integer</td><td><code>42</code></td></tr>
<tr><td><code>f32</code></td><td>32-bit float</td><td><code>3.14</code></td></tr>
<tr><td><code>string</code></td><td>Text string</td><td><code>"hello"</code></td></tr>
<tr><td><code>vec3</code></td><td>3D vector (array of 3 floats)</td><td><code>[1.0, 2.0, 3.0]</code></td></tr>
<tr><td><code>enum</code></td><td>One of a set of string values</td><td><code>"hinged"</code></td></tr>
<tr><td><code>entity_ref</code></td><td>Reference to another entity by name</td><td><code>"main_hall"</code></td></tr>
</tbody>
</table>
</div>
<h3 id="field-constraints"><a class="header" href="#field-constraints">Field Constraints</a></h3>
<p>Fields can include validation constraints:</p>
<pre><code class="language-toml">open_angle = { type = "f32", default = 90.0, min = 0.0, max = 180.0 }
required_key = { type = "entity_ref", optional = true }
</code></pre>
<ul>
<li><code>default</code> — value used when not explicitly set</li>
<li><code>min</code> / <code>max</code> — numeric range bounds</li>
<li><code>optional</code> — whether the field can be omitted (defaults to false)</li>
<li><code>values</code> — valid options for enum types</li>
</ul>
<h2 id="built-in-components"><a class="header" href="#built-in-components">Built-in Components</a></h2>
<p>Flint ships with seven built-in component schemas:</p>
<h3 id="transform"><a class="header" href="#transform">Transform</a></h3>
<pre><code class="language-toml"># schemas/components/transform.toml
[component.transform]
description = "Position and rotation in 3D space"

[component.transform.fields]
position = { type = "vec3", default = [0, 0, 0] }
rotation = { type = "vec3", default = [0, 0, 0] }
scale = { type = "vec3", default = [1, 1, 1] }
</code></pre>
<h3 id="bounds"><a class="header" href="#bounds">Bounds</a></h3>
<pre><code class="language-toml"># schemas/components/bounds.toml
[component.bounds]
description = "Axis-aligned bounding box"

[component.bounds.fields]
min = { type = "vec3", default = [0, 0, 0] }
max = { type = "vec3", default = [10, 4, 10] }
</code></pre>
<h3 id="door"><a class="header" href="#door">Door</a></h3>
<pre><code class="language-toml"># schemas/components/door.toml
[component.door]
description = "A door that can connect spaces"

[component.door.fields]
style = { type = "enum", values = ["hinged", "sliding", "rotating"], default = "hinged" }
locked = { type = "bool", default = false }
open_angle = { type = "f32", default = 90.0, min = 0.0, max = 180.0 }
</code></pre>
<h3 id="material"><a class="header" href="#material">Material</a></h3>
<pre><code class="language-toml"># schemas/components/material.toml
[component.material]
description = "PBR material properties"

[component.material.fields]
texture = { type = "string", default = "", optional = true }
roughness = { type = "f32", default = 0.5, min = 0.0, max = 1.0 }
metallic = { type = "f32", default = 0.0, min = 0.0, max = 1.0 }
color = { type = "vec3", default = [1.0, 1.0, 1.0] }
emissive = { type = "vec3", default = [0.0, 0.0, 0.0] }
</code></pre>
<h3 id="rigidbody"><a class="header" href="#rigidbody">Rigidbody</a></h3>
<pre><code class="language-toml"># schemas/components/rigidbody.toml
[component.rigidbody]
description = "Physics rigid body"

[component.rigidbody.fields]
body_type = { type = "enum", values = ["static", "dynamic", "kinematic"], default = "static" }
mass = { type = "f32", default = 1.0, min = 0.0 }
gravity_scale = { type = "f32", default = 1.0 }
</code></pre>
<h3 id="collider"><a class="header" href="#collider">Collider</a></h3>
<pre><code class="language-toml"># schemas/components/collider.toml
[component.collider]
description = "Physics collision shape"

[component.collider.fields]
shape = { type = "enum", values = ["box", "sphere", "capsule"], default = "box" }
size = { type = "vec3", default = [1.0, 1.0, 1.0] }
friction = { type = "f32", default = 0.5, min = 0.0, max = 1.0 }
</code></pre>
<h3 id="character-controller"><a class="header" href="#character-controller">Character Controller</a></h3>
<pre><code class="language-toml"># schemas/components/character_controller.toml
[component.character_controller]
description = "First-person character controller"

[component.character_controller.fields]
move_speed = { type = "f32", default = 5.0, min = 0.0 }
jump_force = { type = "f32", default = 7.0, min = 0.0 }
height = { type = "f32", default = 1.8, min = 0.1 }
radius = { type = "f32", default = 0.4, min = 0.1 }
camera_mode = { type = "enum", values = ["first_person", "orbit"], default = "first_person" }
</code></pre>
<h2 id="archetype-schemas"><a class="header" href="#archetype-schemas">Archetype Schemas</a></h2>
<p>Archetypes bundle components together with defaults. They live in <code>schemas/archetypes/</code>:</p>
<pre><code class="language-toml"># schemas/archetypes/room.toml
[archetype.room]
description = "A room or enclosed space"
components = ["transform", "bounds"]

[archetype.room.defaults.bounds]
min = [0, 0, 0]
max = [10, 4, 10]
</code></pre>
<p>The <code>components</code> array lists which component schemas an entity of this archetype requires. The <code>defaults</code> section provides values used when a component field isn’t explicitly set.</p>
<h3 id="built-in-archetypes"><a class="header" href="#built-in-archetypes">Built-in Archetypes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Archetype</th><th>Components</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>room</code></td><td>transform, bounds</td><td>An enclosed space</td></tr>
<tr><td><code>door</code></td><td>transform, door</td><td>A door entity</td></tr>
<tr><td><code>furniture</code></td><td>transform, bounds</td><td>A piece of furniture</td></tr>
<tr><td><code>character</code></td><td>transform</td><td>A character or NPC</td></tr>
<tr><td><code>wall</code></td><td>transform, bounds, material</td><td>A wall surface</td></tr>
<tr><td><code>floor</code></td><td>transform, bounds, material</td><td>A floor surface</td></tr>
<tr><td><code>ceiling</code></td><td>transform, bounds, material</td><td>A ceiling surface</td></tr>
<tr><td><code>pillar</code></td><td>transform, bounds, material</td><td>A structural pillar</td></tr>
<tr><td><code>player</code></td><td>transform, character_controller, rigidbody, collider</td><td>Player-controlled entity</td></tr>
</tbody>
</table>
</div>
<h2 id="introspecting-schemas"><a class="header" href="#introspecting-schemas">Introspecting Schemas</a></h2>
<p>Use the CLI to inspect schema definitions:</p>
<pre><code class="language-bash"># Show a component schema
flint schema door --schemas schemas

# Show an archetype schema
flint schema room --schemas schemas
</code></pre>
<p>This outputs the component fields, types, defaults, and constraints — useful for both humans exploring the schema and AI agents discovering what fields are available.</p>
<h2 id="creating-custom-schemas"><a class="header" href="#creating-custom-schemas">Creating Custom Schemas</a></h2>
<p>To add a new component:</p>
<ol>
<li>Create a file in <code>schemas/components/</code>:</li>
</ol>
<pre><code class="language-toml"># schemas/components/health.toml
[component.health]
description = "Hit points and damage tracking"

[component.health.fields]
max_hp = { type = "i32", default = 100, min = 1 }
current_hp = { type = "i32", default = 100, min = 0 }
armor = { type = "f32", default = 0.0, min = 0.0, max = 1.0 }
</code></pre>
<ol start="2">
<li>Reference it in an archetype:</li>
</ol>
<pre><code class="language-toml"># schemas/archetypes/enemy.toml
[archetype.enemy]
description = "A hostile NPC"
components = ["transform", "health"]

[archetype.enemy.defaults.health]
max_hp = 50
current_hp = 50
</code></pre>
<ol start="3">
<li>Use it in a scene:</li>
</ol>
<pre><code class="language-toml">[entities.goblin]
archetype = "enemy"

[entities.goblin.transform]
position = [10, 0, 5]

[entities.goblin.health]
max_hp = 30
current_hp = 30
armor = 0.1
</code></pre>
<p>No engine recompilation needed — schemas are loaded at runtime from the TOML files.</p>
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further Reading</a></h2>
<ul>
<li><a href="#entities-and-ecs">Entities and ECS</a> — how schemas connect to the entity system</li>
<li><a href="#constraints">Constraints</a> — rules that validate entities against schemas</li>
<li><a href="#scenes">Scenes</a> — how schema-defined entities are serialized</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="scenes"><a class="header" href="#scenes">Scenes</a></h1>
<p>A scene in Flint is a TOML file that describes a collection of entities and their data. Scenes are the primary unit of content — they’re what you load, save, query, validate, and render.</p>
<h2 id="file-format"><a class="header" href="#file-format">File Format</a></h2>
<p>Scene files use the <code>.scene.toml</code> extension and have two sections:</p>
<pre><code class="language-toml"># Metadata
[scene]
name = "The Rusty Flint Tavern"
version = "1.0"
description = "A showcase scene demonstrating Flint engine capabilities"

# Entity definitions
[entities.main_hall]
archetype = "room"
# ...
</code></pre>
<h3 id="the-scene-table"><a class="header" href="#the-scene-table">The <code>[scene]</code> Table</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Required</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>name</code></td><td>yes</td><td>Human-readable scene name</td></tr>
<tr><td><code>version</code></td><td>yes</td><td>Format version (currently “1.0”)</td></tr>
<tr><td><code>description</code></td><td>no</td><td>Optional description</td></tr>
</tbody>
</table>
</div>
<h3 id="the-entities-tables"><a class="header" href="#the-entities-tables">The <code>[entities.*]</code> Tables</a></h3>
<p>Each entity is a table under <code>[entities]</code>, keyed by its unique name:</p>
<pre><code class="language-toml">[entities.front_door]
archetype = "door"
parent = "main_hall"

[entities.front_door.transform]
position = [0, 0, 5]

[entities.front_door.door]
style = "hinged"
locked = false
open_angle = 90.0
</code></pre>
<p><strong>Top-level fields:</strong></p>
<ul>
<li><code>archetype</code> — the archetype schema name (optional but recommended)</li>
<li><code>parent</code> — name of the parent entity (optional)</li>
</ul>
<p><strong>Component tables</strong> are nested under the entity. Each component name (e.g., <code>transform</code>, <code>door</code>, <code>bounds</code>) corresponds to a schema in <code>schemas/components/</code>.</p>
<h2 id="scene-operations"><a class="header" href="#scene-operations">Scene Operations</a></h2>
<h3 id="creating-a-scene"><a class="header" href="#creating-a-scene">Creating a Scene</a></h3>
<pre><code class="language-bash">flint scene create levels/tavern.scene.toml --name "The Tavern"
</code></pre>
<h3 id="listing-scenes"><a class="header" href="#listing-scenes">Listing Scenes</a></h3>
<pre><code class="language-bash">flint scene list
</code></pre>
<h3 id="getting-scene-info"><a class="header" href="#getting-scene-info">Getting Scene Info</a></h3>
<pre><code class="language-bash">flint scene info levels/tavern.scene.toml
</code></pre>
<h3 id="loading-and-saving"><a class="header" href="#loading-and-saving">Loading and Saving</a></h3>
<p>The <code>flint-scene</code> crate handles serialization. Scenes are loaded into the ECS world as entities with dynamic components, and saved back to TOML with stable ordering.</p>
<p>When a scene is loaded:</p>
<ol>
<li>The TOML is parsed into a scene structure</li>
<li>Each entity definition creates an ECS entity with a stable <code>EntityId</code></li>
<li>Parent-child relationships are established</li>
<li>The entity ID counter is adjusted to be above any existing ID (preventing collisions on subsequent creates)</li>
</ol>
<p>When a scene is saved:</p>
<ol>
<li>All entities are serialized to their TOML representation</li>
<li>Component data is written as nested tables</li>
<li>Parent references use entity names (not internal IDs)</li>
</ol>
<h2 id="reload-behavior"><a class="header" href="#reload-behavior">Reload Behavior</a></h2>
<p>Scene reload is a full re-parse. When <code>flint serve --watch</code> detects a file change:</p>
<ol>
<li>The entire scene file is re-read and re-parsed</li>
<li>The old world state is replaced with the new one</li>
<li>The renderer picks up the new state on the next frame</li>
</ol>
<p>This approach is simple and correct — there’s no incremental diffing that could get out of sync. For the scene sizes Flint targets, re-parsing is fast enough.</p>
<h2 id="scene-as-source-of-truth"><a class="header" href="#scene-as-source-of-truth">Scene as Source of Truth</a></h2>
<p>A key design decision: <strong>the scene file is the source of truth</strong>, not the in-memory state. This means:</p>
<ul>
<li>You can edit the file with any text editor</li>
<li>AI agents can write TOML directly</li>
<li>Git diffs show exactly what changed</li>
<li>No hidden state lives only in memory</li>
</ul>
<p>The CLI commands (<code>entity create</code>, <code>entity delete</code>) modify the scene file, and the in-memory world loads from that file. The viewer watches the file, not the internal state.</p>
<h2 id="example-the-showcase-scene"><a class="header" href="#example-the-showcase-scene">Example: The Showcase Scene</a></h2>
<p>The demo scene <code>demo/showcase.scene.toml</code> demonstrates the full format:</p>
<pre><code class="language-toml">[scene]
name = "The Rusty Flint Tavern"
version = "1.0"
description = "A showcase scene demonstrating Flint engine capabilities"

# Rooms - rendered as blue wireframe boxes
[entities.main_hall]
archetype = "room"

[entities.main_hall.transform]
position = [0, 0, 0]

[entities.main_hall.bounds]
min = [-7, 0, -5]
max = [7, 4, 5]

# Doors - rendered as orange boxes
[entities.front_entrance]
archetype = "door"
parent = "main_hall"

[entities.front_entrance.transform]
position = [0, 0, 5]

[entities.front_entrance.door]
style = "hinged"
locked = false
open_angle = 90.0

# Furniture - rendered as green boxes
[entities.bar_counter]
archetype = "furniture"
parent = "main_hall"

[entities.bar_counter.transform]
position = [-4, 0, 0]

[entities.bar_counter.bounds]
min = [-1.5, 0, -3]
max = [0, 1.2, 3]

# Characters - rendered as yellow boxes
[entities.bartender]
archetype = "character"
parent = "main_hall"

[entities.bartender.transform]
position = [-5, 0, 0]
</code></pre>
<p>This scene defines 4 rooms, 4 doors, 9 pieces of furniture, and 6 characters — all in readable, diffable TOML.</p>
<h2 id="further-reading-2"><a class="header" href="#further-reading-2">Further Reading</a></h2>
<ul>
<li><a href="#your-first-scene">Your First Scene</a> — hands-on guide to building a scene</li>
<li><a href="#entities-and-ecs">Entities and ECS</a> — how scene entities map to the ECS</li>
<li><a href="#schemas">Schemas</a> — how component structure is defined</li>
<li><a href="#constraints">Constraints</a> — how to validate scenes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<blockquote>
<p>This page is a stub. Content coming soon.</p>
</blockquote>
<p>Flint’s query system provides a SQL-inspired language for filtering and inspecting entities. This page will cover:</p>
<ul>
<li>Query grammar (PEG, parsed by pest)</li>
<li>Full operator reference: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>contains</code></li>
<li>Querying nested fields with dot notation (<code>door.locked</code>)</li>
<li>Boolean logic: <code>and</code>, <code>or</code>, <code>not</code></li>
<li>How queries are used in constraint definitions</li>
<li>Performance characteristics and limitations</li>
</ul>
<p>Grammar overview:</p>
<pre><code>entities where &lt;condition&gt;

&lt;condition&gt; := &lt;field&gt; &lt;op&gt; &lt;value&gt;
            | &lt;condition&gt; and &lt;condition&gt;
            | &lt;condition&gt; or &lt;condition&gt;
            | not &lt;condition&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="constraints"><a class="header" href="#constraints">Constraints</a></h1>
<blockquote>
<p>This page is a stub. Content coming soon.</p>
</blockquote>
<p>Constraints are declarative validation rules that define what a correct scene looks like. This page will cover:</p>
<ul>
<li>Constraint file format (TOML in <code>schemas/constraints/</code>)</li>
<li>Constraint kinds: <code>required_component</code>, <code>required_child</code>, <code>value_range</code>, <code>reference_valid</code>, <code>query_rule</code></li>
<li>Auto-fix strategies: <code>add_child</code>, <code>set_default</code>, <code>remove_invalid</code>, <code>assign_from_parent</code></li>
<li>The validation loop: evaluate, fix, re-evaluate, detect cycles</li>
<li>CLI usage: <code>flint validate</code>, <code>--fix</code>, <code>--dry-run</code>, <code>--output-diff</code></li>
<li>JSON and text output formats</li>
</ul>
<p>See the <a href="#writing-constraints">Writing Constraints</a> guide for practical examples.</p>
<p>Quick start:</p>
<pre><code class="language-bash">flint validate levels/tavern.scene.toml --schemas schemas
flint validate levels/tavern.scene.toml --fix --dry-run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="assets"><a class="header" href="#assets">Assets</a></h1>
<p>Flint uses a content-addressed asset system with SHA-256 hashing. Every imported file is identified by its content hash, which means identical files are automatically deduplicated and any change to a file produces a new, distinct hash.</p>
<h2 id="content-addressing"><a class="header" href="#content-addressing">Content Addressing</a></h2>
<p>When you import a file, Flint computes its SHA-256 hash and stores it under a content-addressed path:</p>
<pre><code>.flint/assets/&lt;first-2-hex&gt;/&lt;full-hash&gt;.&lt;ext&gt;
</code></pre>
<p>This means:</p>
<ul>
<li><strong>Deduplication</strong> — importing the same file twice stores it only once</li>
<li><strong>Change detection</strong> — if a source file changes, its hash changes, and the new version is stored separately</li>
<li><strong>Integrity</strong> — the hash verifies the file hasn’t been corrupted</li>
</ul>
<h2 id="asset-catalog"><a class="header" href="#asset-catalog">Asset Catalog</a></h2>
<p>The asset catalog is a searchable index of all imported assets. Each entry tracks:</p>
<ul>
<li><strong>Name</strong> — a human-friendly identifier (e.g., <code>tavern_chair</code>)</li>
<li><strong>Hash</strong> — the SHA-256 content hash</li>
<li><strong>Type</strong> — asset type (<code>mesh</code>, <code>texture</code>, <code>material</code>, etc.)</li>
<li><strong>Tags</strong> — arbitrary labels for organization and filtering</li>
<li><strong>Source path</strong> — where the file was originally imported from</li>
</ul>
<h2 id="importing-assets"><a class="header" href="#importing-assets">Importing Assets</a></h2>
<p>Use the CLI to import files into the asset store:</p>
<pre><code class="language-bash"># Import a glTF model with name and tags
flint asset import models/chair.glb --name tavern_chair --tags furniture,medieval

# Browse the catalog
flint asset list --type mesh

# Check asset references in a scene
flint asset resolve levels/tavern.scene.toml --strategy strict
</code></pre>
<h2 id="gltfglb-import"><a class="header" href="#gltfglb-import">glTF/GLB Import</a></h2>
<p>The <code>flint-import</code> crate provides full glTF/GLB support, extracting:</p>
<ul>
<li><strong>Meshes</strong> — vertex positions, normals, texture coordinates, and indices</li>
<li><strong>Materials</strong> — PBR properties (base color, roughness, metallic, emissive)</li>
<li><strong>Textures</strong> — embedded or referenced image files</li>
</ul>
<p>Imported meshes are rendered by <code>flint-render</code> with full PBR shading.</p>
<h2 id="resolution-strategies"><a class="header" href="#resolution-strategies">Resolution Strategies</a></h2>
<p>When a scene references assets, Flint can resolve them using different strategies:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Strategy</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>strict</code></td><td>All referenced assets must exist in the catalog. Missing assets are errors.</td></tr>
<tr><td><code>placeholder</code></td><td>Missing assets are replaced with placeholder geometry. Useful during development.</td></tr>
</tbody>
</table>
</div>
<h2 id="asset-sidecar-files"><a class="header" href="#asset-sidecar-files">Asset Sidecar Files</a></h2>
<p>Each asset in the catalog has a <code>.asset.toml</code> sidecar file storing metadata:</p>
<pre><code class="language-toml">[asset]
name = "tavern_chair"
type = "mesh"
hash = "sha256:a1b2c3..."
source_path = "models/chair.glb"
tags = ["furniture", "medieval"]
</code></pre>
<h2 id="further-reading-3"><a class="header" href="#further-reading-3">Further Reading</a></h2>
<ul>
<li><a href="#importing-assets-1">Importing Assets</a> — step-by-step import guide</li>
<li><a href="#schemas">Schemas</a> — the <code>material</code> component schema for PBR properties</li>
<li><a href="#file-formats">File Formats</a> — asset sidecar TOML format reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rendering"><a class="header" href="#rendering">Rendering</a></h1>
<p>Flint uses wgpu 23 for cross-platform GPU rendering, providing physically-based rendering (PBR) with a Cook-Torrance BRDF, cascaded shadow mapping, and full glTF mesh support.</p>
<h2 id="pbr-shading"><a class="header" href="#pbr-shading">PBR Shading</a></h2>
<p>The renderer implements a metallic-roughness PBR workflow based on the Cook-Torrance specular BRDF:</p>
<ul>
<li><strong>Base color</strong> — the surface albedo, optionally sampled from a texture</li>
<li><strong>Roughness</strong> — controls specular highlight spread (0.0 = mirror, 1.0 = diffuse)</li>
<li><strong>Metallic</strong> — interpolates between dielectric and metallic response</li>
<li><strong>Emissive</strong> — self-illumination for light sources and glowing objects</li>
</ul>
<p>Materials are defined in scene TOML via the <code>material</code> component, matching the fields in <code>schemas/components/material.toml</code>.</p>
<h2 id="shadow-mapping"><a class="header" href="#shadow-mapping">Shadow Mapping</a></h2>
<p>Directional lights cast shadows via cascaded shadow maps. Multiple shadow cascades cover different distance ranges from the camera, giving high-resolution shadows close up and broader coverage at distance.</p>
<p>Toggle shadows at runtime with <strong>F4</strong>.</p>
<h2 id="camera-modes"><a class="header" href="#camera-modes">Camera Modes</a></h2>
<p>The renderer supports two camera modes that share the same view/projection math:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Usage</th><th>Controls</th></tr>
</thead>
<tbody>
<tr><td><strong>Orbit</strong></td><td>Scene viewer (<code>serve</code>)</td><td>Left-drag to orbit, right-drag to pan, scroll to zoom</td></tr>
<tr><td><strong>First-person</strong></td><td>Player (<code>play</code>)</td><td>WASD to move, mouse to look, Space to jump, Shift to sprint</td></tr>
</tbody>
</table>
</div>
<p>The camera mode is determined by the entry point: <code>serve</code> uses orbit, <code>play</code> uses first-person. Both produce the same view and projection matrices.</p>
<h2 id="gltf-mesh-rendering"><a class="header" href="#gltf-mesh-rendering">glTF Mesh Rendering</a></h2>
<p>Imported glTF models are rendered with their full mesh geometry and materials. The <code>flint-import</code> crate extracts meshes, materials, and textures from <code>.glb</code>/<code>.gltf</code> files, which the renderer draws with PBR shading.</p>
<h2 id="skinned-mesh-pipeline"><a class="header" href="#skinned-mesh-pipeline">Skinned Mesh Pipeline</a></h2>
<p>For skeletal animation, the renderer provides a separate GPU pipeline that applies bone matrix skinning in the vertex shader. This avoids the 32-byte overhead of bone data on static geometry.</p>
<p><strong>How it works:</strong></p>
<ol>
<li><code>flint-import</code> extracts joint indices and weights from glTF skins alongside the mesh data</li>
<li><code>flint-animation</code> evaluates keyframes and computes bone matrices each frame (local pose -&gt; global hierarchy -&gt; inverse bind matrix)</li>
<li>The renderer uploads bone matrices to a storage buffer and applies them in the vertex shader</li>
</ol>
<p><strong>Key types:</strong></p>
<ul>
<li><code>SkinnedVertex</code> — extends the standard vertex with <code>joint_indices: [u32; 4]</code> and <code>joint_weights: [f32; 4]</code> (6 attributes total vs. 4 for static geometry)</li>
<li><code>GpuSkinnedMesh</code> — holds the vertex/index buffers, material, and a bone matrix storage buffer with its bind group</li>
<li>Skinned pipeline uses bind groups 0–3: transform, material, lights, and bones (storage buffer, read-only, vertex-visible)</li>
</ul>
<p>Skinned meshes also cast shadows through a dedicated <code>vs_skinned_shadow</code> shader entry point that applies bone transforms before depth rendering.</p>
<h2 id="viewer-vs-headless"><a class="header" href="#viewer-vs-headless">Viewer vs Headless</a></h2>
<p>The renderer operates in two modes:</p>
<p><strong>Viewer mode</strong> (<code>flint serve --watch</code>) opens an interactive window with:</p>
<ul>
<li>Real-time PBR rendering</li>
<li>egui inspector panel (entity tree, component editor, constraint overlay)</li>
<li>Hot-reload: edit the scene TOML and the viewer updates automatically</li>
<li>Debug rendering modes (cycle with <strong>F1</strong>)</li>
</ul>
<p><strong>Headless mode</strong> (<code>flint render</code>) renders to a PNG file without opening a window — useful for CI pipelines and automated screenshots:</p>
<pre><code class="language-bash">flint render levels/tavern.scene.toml --output preview.png --width 1920 --height 1080
</code></pre>
<h2 id="technology"><a class="header" href="#technology">Technology</a></h2>
<p>The rendering stack uses winit 0.30’s <code>ApplicationHandler</code> trait pattern (not the older event-loop closure style). wgpu 23 provides the GPU abstraction, selecting the best available backend (Vulkan, Metal, or DX12) at runtime.</p>
<h2 id="further-reading-4"><a class="header" href="#further-reading-4">Further Reading</a></h2>
<ul>
<li><a href="#the-scene-viewer">The Scene Viewer</a> — getting started with the viewer</li>
<li><a href="#animation">Animation</a> — the animation system that drives skinned meshes</li>
<li><a href="#physics-and-runtime">Physics and Runtime</a> — the game loop and first-person gameplay</li>
<li><a href="#headless-rendering-1">Headless Rendering</a> — CI integration guide</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="audio"><a class="header" href="#audio">Audio</a></h1>
<p>Flint’s audio system provides spatial 3D sound via the <code>flint-audio</code> crate, built on <a href="https://github.com/tesselode/kira">Kira</a> 0.11. Sounds can be positioned in 3D space with distance attenuation, played as ambient loops, or triggered by game events like collisions.</p>
<h2 id="spatial-audio"><a class="header" href="#spatial-audio">Spatial Audio</a></h2>
<p>Spatial sounds are attached to entities via the <code>audio_source</code> component. The sound’s volume attenuates with distance from the listener (the player camera):</p>
<ul>
<li><strong>min_distance</strong> — full volume within this radius</li>
<li><strong>max_distance</strong> — silence beyond this radius</li>
<li>Volume falls off smoothly between the two</li>
</ul>
<p>The listener position and orientation are updated each frame to match the first-person camera, so sounds pan and attenuate as you move through the scene.</p>
<h2 id="ambient-loops"><a class="header" href="#ambient-loops">Ambient Loops</a></h2>
<p>Non-spatial sounds play on the main audio track at constant volume regardless of listener position. Set <code>spatial = false</code> on an <code>audio_source</code> to use this mode — useful for background music, ambient atmosphere, and UI sounds.</p>
<h2 id="audio-schemas"><a class="header" href="#audio-schemas">Audio Schemas</a></h2>
<p>Three component schemas define audio behavior:</p>
<p><strong>audio_source</strong> (<code>audio_source.toml</code>) — a sound attached to an entity:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>file</code></td><td>string</td><td></td><td>Path to audio file (relative to scene directory)</td></tr>
<tr><td><code>volume</code></td><td>f32</td><td>1.0</td><td>Playback volume (0.0–2.0)</td></tr>
<tr><td><code>pitch</code></td><td>f32</td><td>1.0</td><td>Playback speed/pitch (0.1–4.0)</td></tr>
<tr><td><code>loop</code></td><td>bool</td><td>false</td><td>Loop the sound continuously</td></tr>
<tr><td><code>spatial</code></td><td>bool</td><td>true</td><td>3D positioned (uses entity transform)</td></tr>
<tr><td><code>min_distance</code></td><td>f32</td><td>1.0</td><td>Distance at full volume</td></tr>
<tr><td><code>max_distance</code></td><td>f32</td><td>25.0</td><td>Distance at silence</td></tr>
<tr><td><code>autoplay</code></td><td>bool</td><td>true</td><td>Start playing on scene load</td></tr>
</tbody>
</table>
</div>
<p><strong>audio_listener</strong> (<code>audio_listener.toml</code>) — marks which entity receives audio:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>active</code></td><td>bool</td><td>true</td><td>Whether this listener is active</td></tr>
</tbody>
</table>
</div>
<p><strong>audio_trigger</strong> (<code>audio_trigger.toml</code>) — event-driven sounds:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>on_collision</code></td><td>string</td><td></td><td>Sound to play on collision start</td></tr>
<tr><td><code>on_interact</code></td><td>string</td><td></td><td>Sound to play on player interaction</td></tr>
<tr><td><code>on_enter</code></td><td>string</td><td></td><td>Sound when entering a trigger volume</td></tr>
<tr><td><code>on_exit</code></td><td>string</td><td></td><td>Sound when exiting a trigger volume</td></tr>
</tbody>
</table>
</div>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The audio system has three main components:</p>
<ul>
<li><strong>AudioEngine</strong> — wraps Kira’s <code>AudioManager</code>, handles sound file loading, listener positioning, and spatial track creation. Sounds route through spatial tracks for 3D positioning or the main track for ambient playback.</li>
<li><strong>AudioSync</strong> — bridges TOML <code>audio_source</code> components to Kira spatial tracks. Discovers new audio entities each frame and updates spatial positions from entity transforms.</li>
<li><strong>AudioTrigger</strong> — maps game events (collisions, interactions) to <code>AudioCommand</code>s that play sounds at specific positions.</li>
</ul>
<p>The system implements the <code>RuntimeSystem</code> trait, ticking in the <code>update()</code> phase of the game loop (not <code>fixed_update()</code>, since audio doesn’t need fixed-timestep processing).</p>
<h2 id="graceful-degradation"><a class="header" href="#graceful-degradation">Graceful Degradation</a></h2>
<p><code>AudioManager::new()</code> can fail on headless machines or CI environments without an audio device. The engine wraps the manager in <code>Option</code> and silently skips audio operations when unavailable. This means scenes with audio components work correctly in all environments — you just won’t hear anything.</p>
<h2 id="adding-audio-to-a-scene"><a class="header" href="#adding-audio-to-a-scene">Adding Audio to a Scene</a></h2>
<pre><code class="language-toml"># A crackling fire with spatial falloff
[entities.fireplace]
archetype = "furniture"

[entities.fireplace.transform]
position = [5.0, 0.5, 3.0]

[entities.fireplace.audio_source]
file = "audio/fire_crackle.ogg"
volume = 0.8
loop = true
spatial = true
min_distance = 1.0
max_distance = 15.0

# Background tavern ambience (non-spatial)
[entities.ambience]

[entities.ambience.audio_source]
file = "audio/tavern_ambient.ogg"
volume = 0.3
loop = true
spatial = false
</code></pre>
<p>Supported audio formats: OGG, WAV, MP3, FLAC (via Kira’s symphonia backend).</p>
<h2 id="further-reading-5"><a class="header" href="#further-reading-5">Further Reading</a></h2>
<ul>
<li><a href="#animation">Animation</a> — animation system that can trigger audio events</li>
<li><a href="#physics-and-runtime">Physics and Runtime</a> — the game loop and event bus that drives audio triggers</li>
<li><a href="#schemas">Schemas</a> — component and archetype definitions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="animation"><a class="header" href="#animation">Animation</a></h1>
<p>Flint’s animation system provides two tiers of animation through the <code>flint-animation</code> crate: <strong>property tweens</strong> for simple transform animations defined in TOML, and <strong>skeletal animation</strong> for character rigs imported from glTF files with GPU vertex skinning.</p>
<h2 id="tier-1-property-animation"><a class="header" href="#tier-1-property-animation">Tier 1: Property Animation</a></h2>
<p>Property animations are the simplest form — animate any transform property (position, rotation, scale) or custom float field over time using keyframes. No 3D modeling tool required; clips are defined entirely in TOML.</p>
<h3 id="animation-clips"><a class="header" href="#animation-clips">Animation Clips</a></h3>
<p>Clips are <code>.anim.toml</code> files stored in the <code>demo/animations/</code> directory:</p>
<pre><code class="language-toml"># animations/door_swing.anim.toml
name = "door_swing"
duration = 0.8

[[tracks]]
interpolation = "Linear"

[tracks.target]
type = "Rotation"

[[tracks.keyframes]]
time = 0.0
value = [0.0, 0.0, 0.0]

[[tracks.keyframes]]
time = 0.8
value = [0.0, 90.0, 0.0]

[[events]]
time = 0.0
event_name = "door_creak"
</code></pre>
<h3 id="interpolation-modes"><a class="header" href="#interpolation-modes">Interpolation Modes</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><strong>Step</strong></td><td>Jumps instantly to the next keyframe value</td></tr>
<tr><td><strong>Linear</strong></td><td>Linearly interpolates between keyframes</td></tr>
<tr><td><strong>CubicSpline</strong></td><td>Smooth interpolation with in/out tangents (matches glTF spec)</td></tr>
</tbody>
</table>
</div>
<h3 id="track-targets"><a class="header" href="#track-targets">Track Targets</a></h3>
<p>Each track animates a specific property:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Target</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>Position</code></td><td>Entity position <code>[x, y, z]</code></td></tr>
<tr><td><code>Rotation</code></td><td>Entity rotation in euler degrees <code>[x, y, z]</code></td></tr>
<tr><td><code>Scale</code></td><td>Entity scale <code>[x, y, z]</code></td></tr>
<tr><td><code>CustomFloat</code></td><td>Any numeric component field (specify <code>component</code> and <code>field</code>)</td></tr>
</tbody>
</table>
</div>
<h3 id="animation-events"><a class="header" href="#animation-events">Animation Events</a></h3>
<p>Clips can fire game events at specific times — useful for triggering sounds (footstep at a specific frame), spawning particles, or notifying scripts. Events fire once per loop cycle.</p>
<h3 id="attaching-an-animation"><a class="header" href="#attaching-an-animation">Attaching an Animation</a></h3>
<p>Add an <code>animator</code> component to any entity in your scene:</p>
<pre><code class="language-toml">[entities.platform]
archetype = "furniture"

[entities.platform.transform]
position = [2.0, 0.5, 3.0]

[entities.platform.animator]
clip = "platform_bob"
autoplay = true
loop = true
speed = 1.0
</code></pre>
<p>The animation system scans for <code>.anim.toml</code> files at startup and matches clip names to <code>animator</code> components.</p>
<h2 id="tier-2-skeletal-animation"><a class="header" href="#tier-2-skeletal-animation">Tier 2: Skeletal Animation</a></h2>
<p>For characters and complex articulated meshes, skeletal animation imports bone hierarchies from glTF files and drives them with GPU vertex skinning.</p>
<h3 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h3>
<pre><code>glTF file (.glb)
  ├── Skin: joint hierarchy + inverse bind matrices
  ├── Mesh: positions, normals, UVs, joint_indices, joint_weights
  └── Animations: per-joint translation/rotation/scale channels
         │
         ▼
  ┌──────────────────────┐
  │   flint-import        │  Extract skeleton, clips, skinned vertices
  └──────────┬───────────┘
             │
  ┌──────────▼───────────┐
  │   flint-animation     │  Evaluate keyframes → bone matrices each frame
  └──────────┬───────────┘
             │
  ┌──────────▼───────────┐
  │   flint-render        │  Upload bone matrices → vertex shader skinning
  └──────────────────────┘
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Import</strong> — <code>flint-import</code> extracts the skeleton (joint hierarchy, inverse bind matrices) and animation clips (per-joint keyframe channels) from glTF files</li>
<li><strong>Evaluate</strong> — each frame, <code>flint-animation</code> samples the current clip time to produce local joint poses, walks the bone hierarchy to compute global transforms, and multiplies by inverse bind matrices to get final bone matrices</li>
<li><strong>Render</strong> — bone matrices are uploaded to a GPU storage buffer. The skinned vertex shader transforms each vertex by its weighted bone influences</li>
</ol>
<h3 id="skinned-vertices"><a class="header" href="#skinned-vertices">Skinned Vertices</a></h3>
<p>Skeletal meshes use a separate <code>SkinnedVertex</code> type with 6 attributes (vs. 4 for static geometry), avoiding 32 bytes of wasted bone data on every static vertex in the scene:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>position</code></td><td>vec3</td><td>Vertex position</td></tr>
<tr><td><code>normal</code></td><td>vec3</td><td>Vertex normal</td></tr>
<tr><td><code>color</code></td><td>vec4</td><td>Vertex color</td></tr>
<tr><td><code>uv</code></td><td>vec2</td><td>Texture coordinates</td></tr>
<tr><td><code>joint_indices</code></td><td>uvec4</td><td>Indices of 4 influencing bones</td></tr>
<tr><td><code>joint_weights</code></td><td>vec4</td><td>Weights for each bone (sum to 1.0)</td></tr>
</tbody>
</table>
</div>
<h3 id="crossfade-blending"><a class="header" href="#crossfade-blending">Crossfade Blending</a></h3>
<p>Smooth transitions between skeletal clips (e.g., idle to walk) use crossfade blending controlled by the <code>animator</code> component:</p>
<pre><code class="language-toml">[entities.character.animator]
clip = "idle"
playing = true
loop = true
blend_target = "walk"      # Crossfade into this clip
blend_duration = 0.3       # Over 0.3 seconds
</code></pre>
<p>Blending uses slerp for rotation quaternions and lerp for translation/scale, producing smooth pose interpolation.</p>
<h3 id="skeleton-schema"><a class="header" href="#skeleton-schema">Skeleton Schema</a></h3>
<p>The <code>skeleton</code> component references a glTF skin:</p>
<pre><code class="language-toml">[entities.character.skeleton]
skin = "Armature"           # Name of the glTF skin
</code></pre>
<p>Entities with both <code>animator</code> and <code>skeleton</code> components use the skeletal animation path. Entities with only <code>animator</code> use property tweens.</p>
<h2 id="animator-schema"><a class="header" href="#animator-schema">Animator Schema</a></h2>
<p>The <code>animator</code> component controls playback for both tiers:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Field</th><th>Type</th><th>Default</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>clip</code></td><td>string</td><td>“”</td><td>Current animation clip name</td></tr>
<tr><td><code>playing</code></td><td>bool</td><td>false</td><td>Whether the animation is playing</td></tr>
<tr><td><code>autoplay</code></td><td>bool</td><td>false</td><td>Start playing on scene load</td></tr>
<tr><td><code>loop</code></td><td>bool</td><td>true</td><td>Loop when the clip ends</td></tr>
<tr><td><code>speed</code></td><td>f32</td><td>1.0</td><td>Playback speed (-10.0 to 10.0)</td></tr>
<tr><td><code>blend_target</code></td><td>string</td><td>“”</td><td>Clip to crossfade into</td></tr>
<tr><td><code>blend_duration</code></td><td>f32</td><td>0.3</td><td>Crossfade duration in seconds</td></tr>
</tbody>
</table>
</div>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<ul>
<li><strong>AnimationPlayer</strong> — clip registry and per-entity playback state for property tweens</li>
<li><strong>AnimationSync</strong> — bridges ECS <code>animator</code> components to property animation playback, auto-discovers new entities each frame</li>
<li><strong>SkeletalSync</strong> — bridges ECS to skeletal animation, manages per-entity skeleton state and bone matrix computation</li>
<li><strong>AnimationSystem</strong> — top-level <code>RuntimeSystem</code> implementation that ticks both tiers</li>
</ul>
<p>Animation runs in <code>update()</code> (variable-rate), not <code>fixed_update()</code>, because smooth interpolation benefits from matching the rendering frame rate rather than the physics tick rate.</p>
<h2 id="further-reading-6"><a class="header" href="#further-reading-6">Further Reading</a></h2>
<ul>
<li><a href="#audio">Audio</a> — audio system that responds to animation events</li>
<li><a href="#rendering">Rendering</a> — the skinned mesh GPU pipeline</li>
<li><a href="#physics-and-runtime">Physics and Runtime</a> — the game loop that drives animation</li>
<li><a href="#file-formats">File Formats</a> — <code>.anim.toml</code> format reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="physics-and-runtime"><a class="header" href="#physics-and-runtime">Physics and Runtime</a></h1>
<p>Flint’s runtime layer transforms static scenes into interactive, playable experiences. The <code>flint-runtime</code> crate provides the game loop infrastructure, and <code>flint-physics</code> integrates the Rapier 3D physics engine for collision detection and character movement.</p>
<h2 id="the-game-loop"><a class="header" href="#the-game-loop">The Game Loop</a></h2>
<p>The game loop uses a <strong>fixed-timestep accumulator</strong> pattern. Physics simulation steps at a constant rate (1/60s by default) regardless of how fast or slow the rendering runs. This ensures deterministic behavior across different hardware.</p>
<p>The loop structure:</p>
<ol>
<li><strong>Tick the clock</strong> — advance time, accumulate delta into the physics budget</li>
<li><strong>Process input</strong> — read keyboard and mouse state into <code>InputState</code></li>
<li><strong>Fixed-step physics</strong> — while enough time has accumulated, step the physics simulation</li>
<li><strong>Character controller</strong> — apply player movement based on input and physics state</li>
<li><strong>Update audio</strong> — sync listener position to camera, process trigger events, update spatial tracks</li>
<li><strong>Advance animation</strong> — tick property tweens and skeletal playback, write updated transforms to ECS, upload bone matrices to GPU</li>
<li><strong>Render</strong> — draw the frame with the current entity positions</li>
</ol>
<p>The <code>RuntimeSystem</code> trait provides a standard interface for systems that plug into this loop. Physics, audio, and animation each implement <code>RuntimeSystem</code> with <code>initialize()</code>, <code>fixed_update()</code>, <code>update()</code>, and <code>shutdown()</code> methods.</p>
<h2 id="physics-with-rapier-3d"><a class="header" href="#physics-with-rapier-3d">Physics with Rapier 3D</a></h2>
<p>The <code>flint-physics</code> crate wraps Rapier 3D and bridges it to Flint’s TOML-based component system:</p>
<ul>
<li><strong>PhysicsWorld</strong> — manages Rapier’s rigid body set, collider set, and simulation pipeline</li>
<li><strong>PhysicsSync</strong> — reads <code>rigidbody</code> and <code>collider</code> components from entities and creates corresponding Rapier bodies. Static bodies for world geometry (walls, floors, furniture), kinematic bodies for the player.</li>
<li><strong>CharacterController</strong> — kinematic first-person movement with gravity, jumping, ground detection, and sprint</li>
</ul>
<h2 id="physics-schemas"><a class="header" href="#physics-schemas">Physics Schemas</a></h2>
<p>Three component schemas define physics properties:</p>
<p><strong>Rigidbody</strong> (<code>rigidbody.toml</code>) — determines how an entity participates in physics:</p>
<ul>
<li><code>body_type</code>: <code>"static"</code> (immovable world geometry), <code>"dynamic"</code> (simulated), or <code>"kinematic"</code> (script-controlled)</li>
<li><code>mass</code>, <code>gravity_scale</code></li>
</ul>
<p><strong>Collider</strong> (<code>collider.toml</code>) — defines the collision shape:</p>
<ul>
<li><code>shape</code>: <code>"box"</code>, <code>"sphere"</code>, or <code>"capsule"</code></li>
<li><code>size</code>: dimensions of the collision volume</li>
<li><code>friction</code>: surface friction coefficient</li>
</ul>
<p><strong>Character Controller</strong> (<code>character_controller.toml</code>) — first-person movement parameters:</p>
<ul>
<li><code>move_speed</code>, <code>jump_force</code>, <code>height</code>, <code>radius</code>, <code>camera_mode</code></li>
</ul>
<p>The <strong>player</strong> archetype (<code>player.toml</code>) bundles these together with a <code>transform</code> for a ready-to-use player entity.</p>
<h2 id="adding-physics-to-a-scene"><a class="header" href="#adding-physics-to-a-scene">Adding Physics to a Scene</a></h2>
<p>To make a scene playable, add physics components to entities:</p>
<pre><code class="language-toml"># The player entity
[entities.player]
archetype = "player"

[entities.player.transform]
position = [0, 1, 0]

[entities.player.character_controller]
move_speed = 6.0
jump_force = 7.0

# A wall with a static collider
[entities.north_wall]
archetype = "wall"

[entities.north_wall.transform]
position = [0, 2, -10]

[entities.north_wall.collider]
shape = "box"
size = [20, 4, 0.5]

[entities.north_wall.rigidbody]
body_type = "static"
</code></pre>
<p>Then play the scene:</p>
<pre><code class="language-bash">flint play my_scene.scene.toml
</code></pre>
<h2 id="input-system"><a class="header" href="#input-system">Input System</a></h2>
<p>The <code>InputState</code> struct tracks keyboard and mouse state each frame:</p>
<ul>
<li>Keyboard keys are tracked as pressed/released</li>
<li>Mouse provides raw delta movement (via <code>DeviceEvent::MouseMotion</code>) for smooth camera look</li>
<li>Action bindings map keys to game actions (move forward, jump, sprint, etc.)</li>
</ul>
<h2 id="further-reading-7"><a class="header" href="#further-reading-7">Further Reading</a></h2>
<ul>
<li><a href="#audio">Audio</a> — spatial audio with Kira</li>
<li><a href="#animation">Animation</a> — property tweens and skeletal animation</li>
<li><a href="#rendering">Rendering</a> — the PBR rendering pipeline</li>
<li><a href="#schemas">Schemas</a> — component and archetype definitions including physics schemas</li>
<li><a href="#cli-reference">CLI Reference</a> — the <code>play</code> command and player binary</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="building-a-tavern"><a class="header" href="#building-a-tavern">Building a Tavern</a></h1>
<blockquote>
<p>This page is a stub. Full tutorial coming soon.</p>
</blockquote>
<p>A step-by-step tutorial that builds a complete tavern scene from scratch using only CLI commands. This guide will cover:</p>
<ul>
<li>Project initialization with <code>flint init</code></li>
<li>Building rooms with parent-child hierarchies</li>
<li>Placing doors with component properties</li>
<li>Furnishing spaces with tables, chairs, and decorations</li>
<li>Adding characters (bartender, patrons, a mysterious stranger)</li>
<li>Adding physics colliders for walkable geometry</li>
<li>Creating a player entity with first-person controls</li>
<li>Running queries to inspect the scene</li>
<li>Validating against constraints</li>
<li>Viewing the result with <code>flint serve --watch</code></li>
<li>Walking through the tavern with <code>flint play</code></li>
</ul>
<p>This tutorial follows the same steps as the <code>demo/build-tavern.ps1</code> showcase script, explained in detail.</p>
<p>In the meantime, you can explore the finished result:</p>
<pre><code class="language-bash"># View the tavern in the scene viewer
cargo run --bin flint -- serve demo/phase4_runtime.scene.toml --watch

# Walk through the tavern in first person
cargo run --bin flint -- play demo/phase4_runtime.scene.toml
</code></pre>
<p>The <code>demo/phase4_runtime.scene.toml</code> scene contains a three-room tavern with a main hall, kitchen, and storage room, furnished with a bar counter, tables, fireplace, and barrels. Four NPCs populate the space: a bartender, two patrons, and a mysterious stranger. All surfaces have physics colliders for first-person exploration.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="writing-constraints"><a class="header" href="#writing-constraints">Writing Constraints</a></h1>
<blockquote>
<p>This page is a stub. Content coming soon.</p>
</blockquote>
<p>A practical guide to authoring constraint rules for your project. This guide will cover:</p>
<ul>
<li>Anatomy of a constraint TOML file</li>
<li>Choosing the right constraint kind for your rule</li>
<li>Writing effective query selectors</li>
<li>Adding auto-fix strategies</li>
<li>Testing constraints with <code>--dry-run</code></li>
<li>Debugging constraint evaluation order</li>
<li>Cascade detection and cycle prevention</li>
<li>Best practices for organizing constraint files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="importing-assets-1"><a class="header" href="#importing-assets-1">Importing Assets</a></h1>
<blockquote>
<p>This page is a stub. Content coming soon.</p>
</blockquote>
<p>A practical guide to importing and managing assets in Flint. This guide will cover:</p>
<ul>
<li>Importing glTF/GLB files with <code>flint asset import</code></li>
<li>Understanding the content-addressed storage layout</li>
<li>Working with <code>.asset.toml</code> sidecar metadata</li>
<li>Tagging and organizing assets</li>
<li>Resolving asset references in scenes</li>
<li>Deduplication: what happens when you import the same file twice</li>
<li>Preparing assets for future rendering (mesh, material, texture extraction)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="headless-rendering-1"><a class="header" href="#headless-rendering-1">Headless Rendering</a></h1>
<blockquote>
<p>This page is a stub. Content coming soon.</p>
</blockquote>
<p>A guide to rendering scenes without a window, for CI pipelines and automated screenshots. This guide will cover:</p>
<ul>
<li>The <code>flint render</code> command and its options</li>
<li>Setting camera position, angle, and field of view</li>
<li>Output resolution and format</li>
<li>Using headless rendering in CI/CD pipelines</li>
<li>Visual regression testing with baseline comparisons</li>
<li>Disabling the ground grid for clean screenshots</li>
</ul>
<p>Quick example:</p>
<pre><code class="language-bash">flint render levels/tavern.scene.toml \
    --output preview.png \
    --width 1920 --height 1080 \
    --distance 30 --yaw 45 --pitch 30
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="ai-agent-workflow"><a class="header" href="#ai-agent-workflow">AI Agent Workflow</a></h1>
<blockquote>
<p>This page is a stub. Content coming soon.</p>
</blockquote>
<p>A guide for AI agents (and their developers) working with Flint. This guide will cover:</p>
<ul>
<li>The agent interaction loop: create, validate, query, render</li>
<li>Structured I/O: JSON output for machine parsing</li>
<li>Using queries for state inspection</li>
<li>Constraint validation as automated feedback</li>
<li>Headless rendering for visual verification</li>
<li>Example: an agent building a complete scene from a text description</li>
<li>Error handling patterns for agent workflows</li>
<li>Best practices for deterministic scene construction</li>
</ul>
<p>Example agent workflow:</p>
<pre><code class="language-bash"># 1. Create scene and entities
flint scene create levels/dungeon.scene.toml --name "Dungeon Level 1"
flint entity create --archetype room --name "entrance" --scene levels/dungeon.scene.toml ...

# 2. Validate
flint validate levels/dungeon.scene.toml --format json

# 3. Query to verify
flint query "entities where archetype == 'door'" --scene levels/dungeon.scene.toml --format json

# 4. Render a preview
flint render levels/dungeon.scene.toml --output preview.png
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cli-reference"><a class="header" href="#cli-reference">CLI Reference</a></h1>
<p>Flint’s CLI is the primary interface for all engine operations. Below is a reference of available commands.</p>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>flint init &lt;name&gt;</code></td><td>Initialize a new project</td></tr>
<tr><td><code>flint entity create</code></td><td>Create an entity in a scene</td></tr>
<tr><td><code>flint entity delete</code></td><td>Delete an entity from a scene</td></tr>
<tr><td><code>flint scene create</code></td><td>Create a new scene file</td></tr>
<tr><td><code>flint scene list</code></td><td>List scene files</td></tr>
<tr><td><code>flint scene info</code></td><td>Show scene metadata and entity count</td></tr>
<tr><td><code>flint query "&lt;query&gt;"</code></td><td>Query entities with the Flint query language</td></tr>
<tr><td><code>flint schema &lt;name&gt;</code></td><td>Inspect a component or archetype schema</td></tr>
<tr><td><code>flint validate &lt;scene&gt;</code></td><td>Validate a scene against constraints</td></tr>
<tr><td><code>flint asset import</code></td><td>Import a file into the asset store</td></tr>
<tr><td><code>flint asset list</code></td><td>List assets in the catalog</td></tr>
<tr><td><code>flint asset info</code></td><td>Show details for a specific asset</td></tr>
<tr><td><code>flint asset resolve</code></td><td>Check asset references in a scene</td></tr>
<tr><td><code>flint serve &lt;scene&gt;</code></td><td>Launch the hot-reload PBR viewer with egui inspector</td></tr>
<tr><td><code>flint play &lt;scene&gt;</code></td><td>Play a scene with first-person controls and physics</td></tr>
<tr><td><code>flint render &lt;scene&gt;</code></td><td>Render a scene to PNG (headless)</td></tr>
</tbody>
</table>
</div>
<h2 id="the-play-command"><a class="header" href="#the-play-command">The <code>play</code> Command</a></h2>
<p>Launch a scene as an interactive first-person experience with physics:</p>
<pre><code class="language-bash">flint play demo/phase4_runtime.scene.toml
flint play levels/tavern.scene.toml --schemas schemas --fullscreen
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>--schemas &lt;path&gt;</code></td><td>Path to schemas directory (default: <code>schemas</code>)</td></tr>
<tr><td><code>--fullscreen</code></td><td>Launch in fullscreen mode</td></tr>
</tbody>
</table>
</div>
<h3 id="player-controls"><a class="header" href="#player-controls">Player Controls</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Input</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>WASD</td><td>Move</td></tr>
<tr><td>Mouse</td><td>Look around</td></tr>
<tr><td>Space</td><td>Jump</td></tr>
<tr><td>Shift</td><td>Sprint</td></tr>
<tr><td>Escape</td><td>Release cursor / Exit</td></tr>
<tr><td>F1</td><td>Cycle debug rendering mode</td></tr>
<tr><td>F4</td><td>Toggle shadows</td></tr>
<tr><td>F11</td><td>Toggle fullscreen</td></tr>
</tbody>
</table>
</div>
<p>The <code>play</code> command requires the scene to have a <code>player</code> archetype entity with a <code>character_controller</code> component. Physics colliders on other entities define the walkable geometry.</p>
<h3 id="standalone-player-binary"><a class="header" href="#standalone-player-binary">Standalone Player Binary</a></h3>
<p>The player is also available as a standalone binary for distribution:</p>
<pre><code class="language-bash">cargo run --bin flint-player -- demo/phase4_runtime.scene.toml --schemas schemas
</code></pre>
<h2 id="common-flags"><a class="header" href="#common-flags">Common Flags</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>--scene &lt;path&gt;</code></td><td>Path to scene file</td></tr>
<tr><td><code>--schemas &lt;path&gt;</code></td><td>Path to schemas directory (default: <code>schemas</code>)</td></tr>
<tr><td><code>--format &lt;fmt&gt;</code></td><td>Output format: <code>json</code>, <code>toml</code>, or <code>text</code></td></tr>
<tr><td><code>--watch</code></td><td>Watch for file changes (with <code>serve</code>)</td></tr>
<tr><td><code>--fix</code></td><td>Apply auto-fixes (with <code>validate</code>)</td></tr>
<tr><td><code>--dry-run</code></td><td>Preview changes without applying</td></tr>
</tbody>
</table>
</div>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-bash"># Get help
flint --help
flint &lt;command&gt; --help

# Examples
flint init my-game
flint serve levels/tavern.scene.toml --watch --schemas schemas
flint play levels/tavern.scene.toml
flint query "entities where archetype == 'door'" --scene levels/tavern.scene.toml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="file-formats"><a class="header" href="#file-formats">File Formats</a></h1>
<blockquote>
<p>This page is a stub. Full reference coming soon.</p>
</blockquote>
<p>All Flint data formats use TOML. This page will provide a complete reference for:</p>
<h2 id="scene-files-scenetoml"><a class="header" href="#scene-files-scenetoml">Scene Files (<code>.scene.toml</code>)</a></h2>
<pre><code class="language-toml">[scene]
name = "Scene Name"
version = "1.0"

[entities.&lt;name&gt;]
archetype = "&lt;archetype&gt;"
parent = "&lt;parent_name&gt;"

[entities.&lt;name&gt;.&lt;component&gt;]
field = value
</code></pre>
<h2 id="component-schemas-schemascomponentstoml"><a class="header" href="#component-schemas-schemascomponentstoml">Component Schemas (<code>schemas/components/*.toml</code>)</a></h2>
<pre><code class="language-toml">[component.&lt;name&gt;]
description = "..."

[component.&lt;name&gt;.fields]
field_name = { type = "&lt;type&gt;", default = &lt;value&gt; }
</code></pre>
<h2 id="archetype-schemas-schemasarchetypestoml"><a class="header" href="#archetype-schemas-schemasarchetypestoml">Archetype Schemas (<code>schemas/archetypes/*.toml</code>)</a></h2>
<pre><code class="language-toml">[archetype.&lt;name&gt;]
description = "..."
components = ["comp1", "comp2"]

[archetype.&lt;name&gt;.defaults.&lt;component&gt;]
field = value
</code></pre>
<h2 id="constraint-files-schemasconstraintstoml"><a class="header" href="#constraint-files-schemasconstraintstoml">Constraint Files (<code>schemas/constraints/*.toml</code>)</a></h2>
<pre><code class="language-toml">[[constraint]]
name = "rule_name"
query = "entities where ..."
severity = "error"
message = "..."

[constraint.kind]
type = "&lt;kind&gt;"
</code></pre>
<h2 id="animation-clips-demoanimationsanimtoml"><a class="header" href="#animation-clips-demoanimationsanimtoml">Animation Clips (<code>demo/animations/*.anim.toml</code>)</a></h2>
<pre><code class="language-toml">name = "clip_name"
duration = 0.8

[[tracks]]
interpolation = "Linear"       # "Step", "Linear", or "CubicSpline"

[tracks.target]
type = "Rotation"              # "Position", "Rotation", "Scale", or "CustomFloat"

[[tracks.keyframes]]
time = 0.0
value = [0.0, 0.0, 0.0]       # [x, y, z] (euler degrees for rotation)

[[tracks.keyframes]]
time = 0.8
value = [0.0, 90.0, 0.0]
# in_tangent = [...]           # Optional, for CubicSpline
# out_tangent = [...]

[[events]]                     # Optional timed events
time = 0.0
event_name = "door_start"
</code></pre>
<h2 id="asset-sidecars-assetsassettoml"><a class="header" href="#asset-sidecars-assetsassettoml">Asset Sidecars (<code>assets/**/*.asset.toml</code>)</a></h2>
<pre><code class="language-toml">[asset]
name = "asset_name"
type = "mesh"
hash = "sha256:..."
source_path = "..."
tags = ["tag1", "tag2"]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>Flint is structured as a sixteen-crate Cargo workspace with clear dependency layering. Each crate has a focused responsibility, and dependencies flow in one direction — from the binaries down to core types.</p>
<h2 id="workspace-structure"><a class="header" href="#workspace-structure">Workspace Structure</a></h2>
<pre><code>flint/
├── crates/
│   ├── flint-cli/          # CLI binary (clap). Entry point for all commands.
│   ├── flint-player/       # Standalone player binary with game loop, physics, audio, animation
│   ├── flint-viewer/       # egui-based GUI inspector with hot-reload
│   ├── flint-animation/    # Two-tier animation: property tweens + skeletal/glTF
│   ├── flint-audio/        # Kira spatial audio: 3D sounds, ambient loops, triggers
│   ├── flint-runtime/      # Game loop infrastructure (GameClock, InputState, EventBus)
│   ├── flint-physics/      # Rapier 3D integration (PhysicsWorld, CharacterController)
│   ├── flint-render/       # wgpu PBR renderer with Cook-Torrance shading + skinned mesh pipeline
│   ├── flint-import/       # File importers (glTF/GLB with skeleton/skin extraction)
│   ├── flint-asset/        # Content-addressed asset storage and catalog
│   ├── flint-constraint/   # Constraint definitions and validation engine
│   ├── flint-query/        # PEG query language (pest parser)
│   ├── flint-scene/        # TOML scene serialization/deserialization
│   ├── flint-ecs/          # hecs wrapper with stable IDs, names, hierarchy
│   ├── flint-schema/       # Component/archetype schema loading and validation
│   └── flint-core/         # Fundamental types: EntityId, Transform, Vec3, etc.
├── schemas/                # Default component, archetype, and constraint definitions
├── demo/                   # Showcase scenes and build scripts
└── docs/                   # This documentation (mdBook)
</code></pre>
<h2 id="design-decisions"><a class="header" href="#design-decisions">Design Decisions</a></h2>
<h3 id="dynamic-components"><a class="header" href="#dynamic-components">Dynamic Components</a></h3>
<p>The most significant architectural choice: components are stored as <code>toml::Value</code> rather than Rust types. This means:</p>
<ul>
<li><strong>Archetypes are runtime data</strong>, not compiled types</li>
<li>New components can be defined in TOML without recompiling</li>
<li>The schema system validates component data against definitions</li>
<li>Trade-off: less compile-time safety, more flexibility</li>
</ul>
<h3 id="stable-entity-ids"><a class="header" href="#stable-entity-ids">Stable Entity IDs</a></h3>
<p>Entity IDs are monotonically increasing 64-bit integers that never recycle. A <code>BiMap</code> maintains the mapping between <code>EntityId</code> and hecs <code>Entity</code> handles. On scene load, the ID counter adjusts to be above the maximum existing ID.</p>
<h3 id="scene-as-source-of-truth-1"><a class="header" href="#scene-as-source-of-truth-1">Scene as Source of Truth</a></h3>
<p>The TOML file on disk is canonical. In-memory state is derived from it. The <code>serve --watch</code> viewer re-parses the entire file on change rather than attempting incremental updates. This is simpler and avoids synchronization bugs.</p>
<h3 id="fixed-timestep-physics"><a class="header" href="#fixed-timestep-physics">Fixed-Timestep Physics</a></h3>
<p>The game loop uses a fixed-timestep accumulator pattern (1/60s default). Physics simulation steps at a constant rate regardless of frame rate, ensuring deterministic behavior. Rendering interpolates between physics states for smooth visuals.</p>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>All crates use <code>thiserror</code> for error types. Each crate defines its own error enum and a <code>Result&lt;T&gt;</code> type alias. Errors propagate upward through the crate hierarchy.</p>
<h2 id="technology-choices"><a class="header" href="#technology-choices">Technology Choices</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Technology</th><th>Rationale</th></tr>
</thead>
<tbody>
<tr><td>Language</td><td>Rust</td><td>Performance, safety, game ecosystem</td></tr>
<tr><td>ECS</td><td>hecs</td><td>Lightweight, standalone, well-tested</td></tr>
<tr><td>Rendering</td><td>wgpu 23</td><td>Cross-platform, modern GPU API</td></tr>
<tr><td>Windowing</td><td>winit 0.30</td><td><code>ApplicationHandler</code> trait pattern</td></tr>
<tr><td>Physics</td><td>Rapier 3D 0.22</td><td>Mature Rust physics, character controller</td></tr>
<tr><td>Audio</td><td>Kira 0.11</td><td>Rust-native, game-focused, spatial audio</td></tr>
<tr><td>GUI</td><td>egui 0.30</td><td>Immediate-mode, easy integration with wgpu</td></tr>
<tr><td>Scene format</td><td>TOML</td><td>Human-readable, diffable, good Rust support</td></tr>
<tr><td>Query parser</td><td>pest</td><td>PEG grammar, good error messages</td></tr>
<tr><td>CLI framework</td><td>clap (derive)</td><td>Ergonomic, well-documented</td></tr>
<tr><td>Error handling</td><td>thiserror + anyhow</td><td>Typed errors in libraries, flexible in binary</td></tr>
</tbody>
</table>
</div>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<p>Flint has two entry points: the CLI for scene authoring and validation, and the player for interactive gameplay. Both flow through the same crate hierarchy:</p>
<pre><code>User / AI Agent
      │
      ├──────────────────────────────────┐
      ▼                                  ▼
  flint-cli                        flint-player
  (scene authoring)                (interactive gameplay)
      │                                  │
      ├──► flint-viewer (GUI)            ├──► flint-runtime   (game loop, input)
      ├──► flint-query  (queries)        ├──► flint-physics   (Rapier 3D)
      ├──► flint-scene  (load/save)      ├──► flint-audio     (Kira spatial audio)
      ├──► flint-render (renderer)       ├──► flint-animation (tweens + skeletal)
      ├──► flint-constraint (validation) └──► flint-render    (PBR + skinned mesh)
      ├──► flint-asset  (asset catalog)          │
      └──► flint-import (glTF import)            ▼
              │                              flint-import  (glTF meshes + skins)
              ▼                                  │
          flint-ecs                              ▼
          flint-schema                       flint-ecs
          flint-core                         flint-schema
                                             flint-core
</code></pre>
<h2 id="crate-details"><a class="header" href="#crate-details">Crate Details</a></h2>
<h3 id="flint-core"><a class="header" href="#flint-core">flint-core</a></h3>
<p>Fundamental types shared by all crates. Minimal external dependencies (<code>thiserror</code>, <code>serde</code>, <code>sha2</code>).</p>
<ul>
<li><code>EntityId</code> — stable 64-bit entity identifier</li>
<li><code>ContentHash</code> — SHA-256 based content addressing</li>
<li><code>Transform</code>, <code>Vec3</code>, <code>Color</code> — geometric primitives</li>
<li><code>FlintError</code> — base error type</li>
</ul>
<h3 id="flint-schema"><a class="header" href="#flint-schema">flint-schema</a></h3>
<p>Loads component and archetype definitions from TOML files. Provides a registry for introspection. Supports field types (<code>bool</code>, <code>i32</code>, <code>f32</code>, <code>string</code>, <code>vec3</code>, <code>enum</code>, <code>entity_ref</code>) with validation constraints.</p>
<h3 id="flint-ecs"><a class="header" href="#flint-ecs">flint-ecs</a></h3>
<p>Wraps hecs with:</p>
<ul>
<li><code>BiMap&lt;EntityId, hecs::Entity&gt;</code> for stable ID mapping</li>
<li>Named entity lookup</li>
<li>Parent-child relationship tracking</li>
<li>Atomic ID counter for deterministic allocation</li>
</ul>
<h3 id="flint-scene"><a class="header" href="#flint-scene">flint-scene</a></h3>
<p>TOML serialization and deserialization for scenes. Handles the mapping between on-disk format and in-memory ECS world.</p>
<h3 id="flint-query"><a class="header" href="#flint-query">flint-query</a></h3>
<p>PEG parser (pest) for the query language. Parses queries like <code>entities where archetype == 'door'</code> and executes them against the ECS world.</p>
<p>Supported operators: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>contains</code></p>
<h3 id="flint-constraint"><a class="header" href="#flint-constraint">flint-constraint</a></h3>
<p>Constraint engine that validates scenes against declarative TOML rules. Supports required components, value ranges, reference validity, and custom query rules. Includes an auto-fix system with cascade detection.</p>
<h3 id="flint-asset"><a class="header" href="#flint-asset">flint-asset</a></h3>
<p>Content-addressed asset storage with SHA-256 hashing. Manages an asset catalog with name/hash/type/tag indexing. Supports resolution strategies (strict, placeholder).</p>
<h3 id="flint-import"><a class="header" href="#flint-import">flint-import</a></h3>
<p>File importers for bringing external assets into the content-addressed store. Supports glTF/GLB with mesh, material, and texture extraction.</p>
<h3 id="flint-render"><a class="header" href="#flint-render">flint-render</a></h3>
<p>wgpu 23 PBR renderer with:</p>
<ul>
<li><strong>Cook-Torrance shading</strong> — physically-based BRDF with roughness/metallic workflow</li>
<li><strong>Cascaded shadow mapping</strong> — directional light shadows across multiple distance ranges</li>
<li><strong>glTF mesh rendering</strong> — imported models rendered with full material support</li>
<li><strong>Camera modes</strong> — orbit (scene viewer) and first-person (player), sharing view/projection math</li>
<li><strong>Headless mode</strong> — render to PNG for CI and automated screenshots</li>
</ul>
<h3 id="flint-viewer"><a class="header" href="#flint-viewer">flint-viewer</a></h3>
<p>egui-based GUI inspector built on top of <code>flint-render</code>:</p>
<ul>
<li>Entity tree with selection</li>
<li>Component property editor</li>
<li>Constraint violation overlay</li>
<li>Hot-reload via file watching (<code>serve --watch</code>)</li>
</ul>
<h3 id="flint-runtime"><a class="header" href="#flint-runtime">flint-runtime</a></h3>
<p>Game loop infrastructure for interactive scenes:</p>
<ul>
<li><code>GameClock</code> — fixed-timestep accumulator (1/60s default)</li>
<li><code>InputState</code> — keyboard and mouse tracking with action bindings</li>
<li><code>EventBus</code> — decoupled event dispatch between systems</li>
<li><code>RuntimeSystem</code> trait — standard interface for update/render systems</li>
</ul>
<h3 id="flint-physics"><a class="header" href="#flint-physics">flint-physics</a></h3>
<p>Rapier 3D integration:</p>
<ul>
<li><code>PhysicsWorld</code> — manages Rapier rigid body and collider sets</li>
<li><code>PhysicsSync</code> — bridges TOML component data to Rapier bodies</li>
<li><code>CharacterController</code> — kinematic first-person movement with gravity, jumping, and ground detection</li>
<li>Uses kinematic bodies for player control, static bodies for world geometry</li>
</ul>
<h3 id="flint-audio"><a class="header" href="#flint-audio">flint-audio</a></h3>
<p>Kira 0.11 integration for game audio:</p>
<ul>
<li><code>AudioEngine</code> — wraps Kira AudioManager, handles sound loading and listener positioning</li>
<li><code>AudioSync</code> — bridges TOML <code>audio_source</code> components to Kira spatial tracks</li>
<li><code>AudioTrigger</code> — maps game events (collision, interaction) to sound playback</li>
<li>Spatial 3D audio with distance attenuation, non-spatial ambient loops</li>
<li>Graceful degradation when no audio device is available (headless/CI)</li>
</ul>
<h3 id="flint-animation"><a class="header" href="#flint-animation">flint-animation</a></h3>
<p>Two-tier animation system:</p>
<ul>
<li><strong>Tier 1: Property tweens</strong> — <code>AnimationClip</code> with keyframe tracks targeting transform properties (position, rotation, scale) or custom fields. Step, Linear, and CubicSpline interpolation. Clips defined in <code>.anim.toml</code> files.</li>
<li><strong>Tier 2: Skeletal animation</strong> — <code>Skeleton</code> and <code>SkeletalClip</code> types for glTF skin/joint hierarchies. GPU vertex skinning via bone matrix storage buffer. Crossfade blending between clips.</li>
<li><code>AnimationSync</code> bridges ECS <code>animator</code> components to property playback</li>
<li><code>SkeletalSync</code> bridges ECS to skeletal playback with bone matrix computation</li>
</ul>
<h3 id="flint-player"><a class="header" href="#flint-player">flint-player</a></h3>
<p>Standalone player binary that wires together runtime, physics, audio, animation, and rendering:</p>
<ul>
<li>Full game loop: clock tick, fixed-step physics, audio sync, animation advance, first-person rendering</li>
<li>Scene loading with physics body creation from TOML collider/rigidbody components</li>
<li>Audio source loading and spatial listener tracking</li>
<li>Skeletal animation with bone matrix upload to GPU each frame</li>
<li>First-person controls (WASD, mouse look, jump, sprint)</li>
</ul>
<h3 id="flint-cli"><a class="header" href="#flint-cli">flint-cli</a></h3>
<p>Binary crate with clap-derived command definitions. Routes commands to the appropriate subsystem crate. Commands: <code>init</code>, <code>entity</code>, <code>scene</code>, <code>query</code>, <code>schema</code>, <code>serve</code>, <code>play</code>, <code>validate</code>, <code>asset</code>, <code>render</code>.</p>
<h2 id="further-reading-8"><a class="header" href="#further-reading-8">Further Reading</a></h2>
<ul>
<li><a href="#crate-dependency-graph">Crate Dependency Graph</a> — visual dependency diagram</li>
<li><a href="#design-principles">Design Principles</a> — the principles behind these decisions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="crate-dependency-graph"><a class="header" href="#crate-dependency-graph">Crate Dependency Graph</a></h1>
<p>This page shows how Flint’s sixteen crates depend on each other. Dependencies flow downward — higher crates depend on lower ones, never the reverse.</p>
<h2 id="dependency-diagram"><a class="header" href="#dependency-diagram">Dependency Diagram</a></h2>
<pre><code>          ┌─────────────┐                ┌──────────────┐
          │  flint-cli  │                │ flint-player │
          │  (binary)   │                │   (binary)   │
          └──────┬──────┘                └──────┬───────┘
                 │                              │
    ┌────┬───┬──┴──┬────┬────┬────┐    ┌───┬───┴───┬───┬───┬───┐
    │    │   │     │    │    │    │    │   │       │   │   │   │
    ▼    │   ▼     ▼    ▼    ▼    ▼    ▼   ▼       ▼   │   │   │
 ┌──────┐│┌─────┐┌────┐│ ┌─────┐│ ┌────────┐┌────────┐│   │   │
 │viewer│││scene││qry ││ │const││ │runtime ││physics ││   │   │
 └──┬───┘│└──┬──┘└─┬──┘│ └──┬──┘│ └───┬────┘└───┬────┘│   │   │
    │    │   │     │   │    │   │     │          │     │   │   │
    │    ▼   │     │   │    │   │     │          │     ▼   ▼   │
    │ ┌──────────┐ │   │    │   │     │          │  ┌─────────┐│
    ├►│  render  │◄┘   │    │   │     │          │  │  audio  ││
    │ └────┬─────┘     │    │   │     │          │  └────┬────┘│
    │      │           │    │   │     │          │       │     │
    │      │           │    │   │     │          │       │     ▼
    │      │           │    │   │     │          │       │  ┌──────────┐
    │      │           │    │   │     │          │       │  │animation │
    │      ▼           │    │   │     │          │       │  └────┬─────┘
    │ ┌──────────┐     │   ┌┘   │     │          │       │       │
    │ │  import  │     │   │    │     │          │       │       │
    │ └────┬─────┘     │   │    │     │          │       │       │
    │      │           ▼   ▼    ▼     ▼          ▼       ▼       ▼
    │      │    ┌──────────────────────────────────────────────────┐
    │      │    │              flint-ecs                            │
    │      │    │  (hecs wrapper, stable IDs, hierarchy)           │
    │      │    └────────────────┬─────────────────────────────────┘
    │      │                    │
    │      │                    ▼
    │      │             ┌──────────────┐
    │      │             │ flint-schema │
    │      │             └──────┬───────┘
    │      │                    │
    │      ▼                    ▼
    │ ┌──────────┐  ┌─────────────────────────────────────┐
    │ │  asset   │  │            flint-core                │
    │ └────┬─────┘  │ (EntityId, Vec3, Transform, Hash)   │
    │      │        └─────────────────────────────────────┘
    │      │                    ▲
    └──────┴────────────────────┘
</code></pre>
<h2 id="dependency-details"><a class="header" href="#dependency-details">Dependency Details</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Depends On</th><th>Depended On By</th></tr>
</thead>
<tbody>
<tr><td><code>flint-core</code></td><td><em>(none)</em></td><td>all other crates</td></tr>
<tr><td><code>flint-schema</code></td><td>core</td><td>ecs, constraint</td></tr>
<tr><td><code>flint-ecs</code></td><td>core, schema</td><td>scene, query, render, constraint, runtime, physics, audio, animation, viewer, player, cli</td></tr>
<tr><td><code>flint-asset</code></td><td>core</td><td>import, cli</td></tr>
<tr><td><code>flint-import</code></td><td>core, asset</td><td>render, animation, viewer, cli, player</td></tr>
<tr><td><code>flint-query</code></td><td>core, ecs</td><td>constraint, cli</td></tr>
<tr><td><code>flint-scene</code></td><td>core, ecs, schema</td><td>viewer, player, cli</td></tr>
<tr><td><code>flint-constraint</code></td><td>core, ecs, schema, query</td><td>viewer, cli</td></tr>
<tr><td><code>flint-render</code></td><td>core, ecs, import</td><td>viewer, player, cli</td></tr>
<tr><td><code>flint-runtime</code></td><td>core, ecs</td><td>physics, audio, animation, player</td></tr>
<tr><td><code>flint-physics</code></td><td>core, ecs, runtime</td><td>player</td></tr>
<tr><td><code>flint-audio</code></td><td>core, ecs, runtime</td><td>player</td></tr>
<tr><td><code>flint-animation</code></td><td>core, ecs, import, runtime</td><td>player</td></tr>
<tr><td><code>flint-viewer</code></td><td>core, ecs, scene, schema, render, import, constraint</td><td>cli</td></tr>
<tr><td><code>flint-player</code></td><td>core, schema, ecs, scene, render, runtime, physics, audio, animation, import</td><td><em>(binary entry point)</em></td></tr>
<tr><td><code>flint-cli</code></td><td>all crates</td><td><em>(binary entry point)</em></td></tr>
</tbody>
</table>
</div>
<h2 id="key-properties"><a class="header" href="#key-properties">Key Properties</a></h2>
<p><strong>Acyclic.</strong> The dependency graph has no cycles. This is enforced by Cargo and ensures clean compilation ordering.</p>
<p><strong>Layered.</strong> Crates form clear layers:</p>
<ol>
<li><strong>Core</strong> — fundamental types (<code>flint-core</code>)</li>
<li><strong>Schema</strong> — data definitions (<code>flint-schema</code>)</li>
<li><strong>Storage</strong> — entity and asset management (<code>flint-ecs</code>, <code>flint-asset</code>)</li>
<li><strong>Logic</strong> — query, scene, constraint, import</li>
<li><strong>Systems</strong> — render, runtime, physics, audio, animation</li>
<li><strong>Applications</strong> — viewer, player</li>
<li><strong>Interface</strong> — CLI binary (<code>flint-cli</code>), player binary (<code>flint-player</code>)</li>
</ol>
<p><strong>Two entry points.</strong> The CLI binary (<code>flint-cli</code>) serves scene authoring and validation workflows. The player binary (<code>flint-player</code>) serves interactive gameplay. Both share the same underlying crate hierarchy.</p>
<p><strong>Independent subsystems.</strong> The constraint system, asset system, physics system, audio system, animation system, and render system don’t depend on each other. This means you can build and test each subsystem in isolation.</p>
<h2 id="external-dependencies"><a class="header" href="#external-dependencies">External Dependencies</a></h2>
<p>Key third-party crates used across the workspace:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Crate</th><th>Used By</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>hecs</code></td><td>flint-ecs</td><td>Underlying ECS implementation</td></tr>
<tr><td><code>toml</code></td><td>most crates</td><td>TOML parsing and serialization</td></tr>
<tr><td><code>serde</code></td><td>all crates</td><td>Serialization framework</td></tr>
<tr><td><code>pest</code></td><td>flint-query</td><td>PEG parser generator</td></tr>
<tr><td><code>wgpu</code></td><td>flint-render, flint-viewer, flint-player</td><td>GPU abstraction layer</td></tr>
<tr><td><code>winit</code></td><td>flint-render, flint-viewer, flint-runtime, flint-player</td><td>Window and input management</td></tr>
<tr><td><code>rapier3d</code></td><td>flint-physics</td><td>3D physics simulation</td></tr>
<tr><td><code>kira</code></td><td>flint-audio</td><td>Spatial audio engine</td></tr>
<tr><td><code>glam</code></td><td>flint-audio</td><td>Vec3/Quat types for Kira spatial positioning (via mint interop)</td></tr>
<tr><td><code>egui</code></td><td>flint-viewer</td><td>Immediate-mode GUI framework</td></tr>
<tr><td><code>clap</code></td><td>flint-cli, flint-player</td><td>Command-line argument parsing</td></tr>
<tr><td><code>thiserror</code></td><td>all library crates</td><td>Error derive macros</td></tr>
<tr><td><code>sha2</code></td><td>flint-core, flint-asset</td><td>SHA-256 hashing</td></tr>
<tr><td><code>gltf</code></td><td>flint-import</td><td>glTF file parsing (meshes, materials, skins, animations)</td></tr>
<tr><td><code>crossbeam</code></td><td>flint-physics</td><td>Channel-based event collection (Rapier)</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<p>Flint’s development is organized into five phases. Each phase delivers a usable milestone that builds on the previous one.</p>
<h2 id="phase-1-foundation--cli--query--schema"><a class="header" href="#phase-1-foundation--cli--query--schema">Phase 1: Foundation — CLI + Query + Schema</a></h2>
<p><strong>Status: Complete</strong></p>
<p>The foundation phase established the core data model and CLI interface. An agent (or human) can create, query, and modify scenes entirely through commands.</p>
<p><strong>Delivered:</strong></p>
<ul>
<li><code>flint-core</code> — Entity IDs, content hashing, fundamental types</li>
<li><code>flint-schema</code> — Component registry, archetype definitions, TOML-based introspection</li>
<li><code>flint-ecs</code> — hecs integration with stable IDs, named entities, parent-child hierarchy</li>
<li><code>flint-scene</code> — TOML scene serialization and deserialization</li>
<li><code>flint-query</code> — PEG query language with pest parser</li>
<li><code>flint-cli</code> — CRUD operations for entities and scenes</li>
</ul>
<p><strong>Milestone:</strong> <code>flint entity create --archetype door</code> works. <code>flint query "entities"</code> returns results.</p>
<h2 id="phase-2-constraints--assets"><a class="header" href="#phase-2-constraints--assets">Phase 2: Constraints + Assets</a></h2>
<p><strong>Status: Complete</strong></p>
<p>The validation and asset management phase. Scenes can now be checked against declarative rules, and external files can be imported into a content-addressed store.</p>
<p><strong>Delivered:</strong></p>
<ul>
<li><code>flint-constraint</code> — Constraint definitions, validation engine, auto-fix with cascade detection</li>
<li><code>flint-asset</code> — Content-addressed storage (SHA-256), asset catalog with name/hash/type/tag indexing</li>
<li><code>flint-import</code> — glTF/GLB importer with mesh, material, and texture extraction</li>
</ul>
<p><strong>Milestone:</strong> <code>flint validate --fix</code> automatically fixes constraint violations. <code>flint asset import model.glb</code> stores and catalogs assets.</p>
<h2 id="phase-3-rendering--visual-validation"><a class="header" href="#phase-3-rendering--visual-validation">Phase 3: Rendering + Visual Validation</a></h2>
<p><strong>Status: Complete</strong></p>
<p>The visual validation phase. Physically-based rendering with a full-featured scene viewer.</p>
<p><strong>Delivered:</strong></p>
<ul>
<li><code>flint-render</code> — wgpu 23 PBR renderer with Cook-Torrance shading, cascaded shadow mapping, and glTF mesh rendering</li>
<li><code>flint-viewer</code> — egui-based GUI inspector with entity tree, component editing, and constraint overlay</li>
<li>Scene viewer with orbit camera, hot-reload via <code>serve --watch</code></li>
<li>Headless rendering for CI (<code>flint render --headless</code>)</li>
<li>Material system with roughness, metallic, emissive, and texture support</li>
</ul>
<p><strong>Milestone:</strong> <code>flint serve --watch</code> shows a live PBR scene with shadows that updates when files change.</p>
<h2 id="phase-4-interactive-runtime"><a class="header" href="#phase-4-interactive-runtime">Phase 4: Interactive Runtime</a></h2>
<p><strong>Status: In Progress (Stages 1–3 of 5 complete)</strong></p>
<p>The game runtime phase. A playable game loop with physics, audio, animation, and eventually scripting.</p>
<p><strong>Stage 1 — Game Loop + Physics: Complete</strong></p>
<ul>
<li><code>flint-runtime</code> — GameClock (fixed-timestep accumulator), InputState (keyboard/mouse with action bindings), EventBus, RuntimeSystem trait</li>
<li><code>flint-physics</code> — Rapier 3D integration: PhysicsWorld, PhysicsSync (TOML-to-Rapier bridge), CharacterController (kinematic first-person movement with gravity and jumping)</li>
<li><code>flint-player</code> — Standalone player binary with full game loop</li>
<li>First-person camera mode (backward-compatible with orbit)</li>
<li>CLI <code>play</code> command — <code>flint play &lt;scene&gt; [--schemas] [--fullscreen]</code></li>
<li>Physics schemas — <code>rigidbody.toml</code>, <code>collider.toml</code>, <code>character_controller.toml</code> components + <code>player.toml</code> archetype</li>
<li>Demo scene — walkable tavern with physics colliders on walls, floor, and furniture</li>
</ul>
<p><strong>Stage 2 — Audio: Complete</strong></p>
<ul>
<li><code>flint-audio</code> — Kira 0.11 integration: AudioEngine, AudioSync, AudioTrigger, AudioSystem</li>
<li>Spatial 3D audio with distance attenuation via SpatialTrackHandle</li>
<li>Non-spatial ambient loops on main track</li>
<li>Event-driven sound triggers (collision, interaction)</li>
<li>Audio component schemas — <code>audio_source.toml</code>, <code>audio_listener.toml</code>, <code>audio_trigger.toml</code></li>
<li>Graceful degradation when no audio device available (headless/CI)</li>
<li>Demo audio — CC0 OGG assets: fire crackle, ambient tavern, door open, glass clinks</li>
</ul>
<p><strong>Stage 3 — Animation: Complete</strong></p>
<ul>
<li><code>flint-animation</code> — Two-tier animation system:
<ul>
<li><strong>Tier 1: Property tweens</strong> — TOML-defined <code>.anim.toml</code> keyframe clips with Step/Linear/CubicSpline interpolation, <code>animator</code> component schema, event firing at keyframe times</li>
<li><strong>Tier 2: Skeletal animation</strong> — glTF skin/joint import via <code>flint-import</code>, GPU vertex skinning with storage buffer bone matrices, separate <code>SkinnedVertex</code> pipeline, crossfade blending between clips</li>
</ul>
</li>
<li><code>skeleton</code> component schema for glTF skin references</li>
<li>Skinned shadow mapping with dedicated shader entry point</li>
<li>Demo animations — bobbing platform (4s loop), door swing (0.8s), skeletal test scene</li>
</ul>
<p><strong>Stage 4 — Scripting: Planned</strong></p>
<ul>
<li><code>flint-script</code> — Rhai scripting for game logic (sandboxed)</li>
<li>Entity API, event callbacks (<code>on_collision</code>, <code>on_trigger</code>, <code>on_action</code>)</li>
<li>Animation and audio APIs for scripts</li>
<li>Hot-reload for script files</li>
</ul>
<p><strong>Stage 5 — Integration: Planned</strong></p>
<ul>
<li>Interactable component with scripted behaviors</li>
<li>Full demo: walk around, open animated doors, see NPC idle animations, hear sounds</li>
</ul>
<p><strong>Milestone:</strong> <code>flint play tavern.scene.toml</code> launches a first-person walkable scene with physics, spatial audio, and animation.</p>
<h2 id="phase-5-ai-asset-pipeline"><a class="header" href="#phase-5-ai-asset-pipeline">Phase 5: AI Asset Pipeline</a></h2>
<p><strong>Status: Planned</strong></p>
<p>Integrated AI generation workflows for textures, meshes, and audio.</p>
<p><strong>Planned:</strong></p>
<ul>
<li><code>flint-asset-gen</code> — Provider integrations (texture generation, mesh generation, audio generation)</li>
<li>Style consistency validation against style guide TOML files</li>
<li>Human task generation for assets that need manual creation</li>
<li>Resolution strategy: <code>ai_generate</code> alongside existing <code>strict</code> and <code>placeholder</code></li>
</ul>
<p><strong>Milestone:</strong> <code>flint asset generate model --provider meshy</code> produces usable game assets.</p>
<h2 id="beyond-phase-5"><a class="header" href="#beyond-phase-5">Beyond Phase 5</a></h2>
<p>These are ideas under consideration, not committed plans:</p>
<ul>
<li><strong>Networking</strong> — multiplayer support</li>
<li><strong>Post-processing</strong> — bloom, ambient occlusion, tone mapping, LOD</li>
<li><strong>Plugin system</strong> — third-party extensions</li>
<li><strong>Package manager</strong> — share schemas, constraints, and assets between projects</li>
<li><strong>WebAssembly</strong> — browser-based viewer and potentially runtime</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Flint is in active development (Phase 4 of 5). Contributions are welcome in these areas:</p>
<ul>
<li><strong>Bug reports</strong> — file issues on GitHub</li>
<li><strong>Schema definitions</strong> — new component and archetype schemas</li>
<li><strong>Documentation</strong> — improvements to this guide</li>
<li><strong>Test coverage</strong> — additional unit and integration tests (146 tests across 16 crates)</li>
<li><strong>Constraint kinds</strong> — new validation rule types</li>
<li><strong>Physics</strong> — additional collider shapes, improved character controller behavior</li>
<li><strong>Rendering</strong> — post-processing effects, LOD, additional debug views</li>
<li><strong>Audio</strong> — additional audio formats, reverb zones, music system</li>
<li><strong>Animation</strong> — blend trees, additive blending, animation state machines</li>
</ul>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<pre><code class="language-bash">git clone https://github.com/chaps/flint.git
cd flint
cargo build
cargo test
cargo clippy
cargo fmt --check
</code></pre>
<h2 id="running-the-demo"><a class="header" href="#running-the-demo">Running the Demo</a></h2>
<pre><code class="language-bash"># Scene viewer with hot-reload
cargo run --bin flint -- serve demo/phase4_runtime.scene.toml --watch

# First-person walkable scene
cargo run --bin flint -- play demo/phase4_runtime.scene.toml
</code></pre>
<h2 id="code-style"><a class="header" href="#code-style">Code Style</a></h2>
<ul>
<li>Run <code>cargo fmt</code> before committing</li>
<li>Run <code>cargo clippy</code> and address warnings</li>
<li>Each crate has its own error type using <code>thiserror</code></li>
<li>Tests live alongside the code they test (<code>#[cfg(test)]</code> modules)</li>
<li>Prefer explicit over clever; readability over brevity</li>
</ul>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<p>The project is a 16-crate Cargo workspace. See the <a href="#architecture-overview">Architecture Overview</a> and <a href="#crate-dependency-graph">Crate Dependency Graph</a> for how the crates relate to each other. Key principles:</p>
<ul>
<li>Dependencies flow in one direction (binary crates at the top, <code>flint-core</code> at the bottom)</li>
<li>Components are dynamic <code>toml::Value</code>, not Rust types — schemas are runtime data</li>
<li>Two entry points: <code>flint-cli</code> (scene authoring) and <code>flint-player</code> (interactive gameplay)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
